#include "runtime_text_options.h"
#include "json_helper.h"

#include <util/string/builder.h>

namespace NCatboostOptions {
    TTokenizedFeatureDescription::TTokenizedFeatureDescription()
        : FeatureId("feature_id", "TokenizedFeature")
        , DictionaryId("dictionary_id", "DictionaryName")
        , TextFeatureId("text_feature_id", -1)
        , FeatureEstimators("feature_estimators", TVector<TFeatureCalcerDescription>{})
    {
    }

    TTokenizedFeatureDescription::TTokenizedFeatureDescription(
        TString dictionaryId,
        ui32 textFeatureIdx,
        TConstArrayRef<TFeatureCalcerDescription> featureEstimators
    )
        : TTokenizedFeatureDescription()
    {
        FeatureId.Set(
            TStringBuilder() << "AutoGenerated:TokenizedTextFeature=" << textFeatureIdx
                << ";Dictionary=" << dictionaryId
        );
        DictionaryId.Set(std::move(dictionaryId));
        TextFeatureId.Set(textFeatureIdx);
        FeatureEstimators.Set(
            TVector<TFeatureCalcerDescription>(featureEstimators.begin(), featureEstimators.end())
        );
    }

    void TTokenizedFeatureDescription::Save(NJson::TJsonValue* optionsJson) const {
        SaveFields(optionsJson, FeatureId, DictionaryId, TextFeatureId, FeatureEstimators);
    }

    void TTokenizedFeatureDescription::Load(const NJson::TJsonValue& options) {
        CheckedLoad(options, &FeatureId, &DictionaryId, &TextFeatureId, &FeatureEstimators);
        CB_ENSURE(
            TextFeatureId.IsSet(),
            "TokenizedFeatureDescription: text_feature_id is not specified for tokenized feature "
                << FeatureId.Get()
        );
    }

    bool TTokenizedFeatureDescription::operator==(const TTokenizedFeatureDescription& rhs) const {
        return std::tie(FeatureId, DictionaryId, TextFeatureId, FeatureEstimators)
            == std::tie(rhs.FeatureId, rhs.DictionaryId, rhs.TextFeatureId, rhs.FeatureEstimators);
    }

    bool TTokenizedFeatureDescription::operator!=(const TTokenizedFeatureDescription& rhs) const {
        return !(*this == rhs);
    }

    static void CreateTokenizedFeatures(
        ui32 textFeatureIdx,
        const TVector<TTextFeatureProcessing>& textFeatureProcessings,
        TVector<TTokenizedFeatureDescription>* tokenizedFeatures
    ) {
        THashMap<TString, ui32> dictionaryToFeatureIdx;

        for (const auto& featureProcessing: textFeatureProcessings) {
            for (const TString& dictionaryId: featureProcessing.DictionariesNames.Get()) {
                if (!dictionaryToFeatureIdx.contains(dictionaryId)) {
                    dictionaryToFeatureIdx[dictionaryId] = tokenizedFeatures->size();

                    TTokenizedFeatureDescription tokenizedFeature{
                        dictionaryId,
                        textFeatureIdx,
                        TVector<TFeatureCalcerDescription>{}
                    };
                    tokenizedFeatures->push_back(tokenizedFeature);
                }

                auto& tokenizedFeature = tokenizedFeatures->at(dictionaryToFeatureIdx[dictionaryId]);
                tokenizedFeature.FeatureEstimators->push_back(featureProcessing.FeatureCalcer);
            }
        }
    }

    TRuntimeTextOptions::TRuntimeTextOptions(
        const TVector<ui32>& textFeatureIndices,
        const TTextProcessingOptions& textOptions
    ) : TRuntimeTextOptions()
    {
        for (const auto& dictionary: textOptions.GetDictionaries()) {
            Dictionaries->insert({dictionary.DictionaryId.Get(), dictionary});
        }

        const auto& defaultFeatureCalcerDictionaries =
            NCatboostOptions::TTextProcessingOptions::GetDefaultCalcerDictionaries();

        TVector<TTokenizedFeatureDescription> tokenizedFeatures;
        for (ui32 textFeatureIdx: textFeatureIndices) {
            auto featureProcessing = textOptions.GetFeatureProcessing(textFeatureIdx);
            for (auto& processingUnit: featureProcessing) {
                TVector<TString>& dictionaryNames = processingUnit.DictionariesNames.Get();
                if (dictionaryNames.empty()) {
                    EFeatureCalcerType featureCalcer = processingUnit.FeatureCalcer->CalcerType;
                    CB_ENSURE(
                        textOptions.HasOnlyDefaultDictionaries(),
                        "TextProcessingOptions: no dictionaries were specified for feature estimator "
                            << ToString(featureCalcer)
                    );
                    CB_ENSURE_INTERNAL(
                        defaultFeatureCalcerDictionaries.contains(featureCalcer),
                        "No default dictionaries for feature calcer " << ToString(featureCalcer)
                    );
                    const auto& currentCalcerDictionaries = defaultFeatureCalcerDictionaries.at(featureCalcer);
                    dictionaryNames.insert(
                        dictionaryNames.end(),
                        currentCalcerDictionaries.begin(),
                        currentCalcerDictionaries.end()
                    );
                }
            }
            CreateTokenizedFeatures(
                textFeatureIdx,
                featureProcessing,
                &tokenizedFeatures
            );
        }
        TokenizedFeatures.Set(tokenizedFeatures);
    }

    TRuntimeTextOptions::TRuntimeTextOptions()
        : Dictionaries("dictionaries", TMap<TString, TTextColumnDictionaryOptions>{})
        , TokenizedFeatures("tokenized_features", TVector<TTokenizedFeatureDescription>{})
    {
    }

    TRuntimeTextOptions::TRuntimeTextOptions(
        TConstArrayRef<TTextColumnDictionaryOptions> dictionaries,
        TConstArrayRef<TTokenizedFeatureDescription> tokenizedFeatures)
        : TRuntimeTextOptions()
    {
        for (const auto& dictionary: dictionaries) {
            Dictionaries->insert({dictionary.DictionaryId.Get(), dictionary});
        }
        TokenizedFeatures.Set(
            TVector<TTokenizedFeatureDescription>{tokenizedFeatures.begin(), tokenizedFeatures.end()}
        );
    }

    const TTextColumnDictionaryOptions& TRuntimeTextOptions::GetDictionaryOptions(TStringBuf dictionaryId) const {
        CB_ENSURE(
            Dictionaries->contains(TString(dictionaryId)),
            "No options for dictionaryId " << dictionaryId
        );
        return Dictionaries->at(TString(dictionaryId));
    }

    const TTokenizedFeatureDescription& TRuntimeTextOptions::GetTokenizedFeatureDescription(
        ui32 tokenizedFeatureIdx
    ) const {
        return TokenizedFeatures->at(tokenizedFeatureIdx);
    }

    void TRuntimeTextOptions::Save(NJson::TJsonValue* optionsJson) const {
        SaveFields(optionsJson, Dictionaries, TokenizedFeatures);
    }

    void TRuntimeTextOptions::Load(const NJson::TJsonValue& options) {
        CheckedLoad(options, &Dictionaries, &TokenizedFeatures);
    }

    bool TRuntimeTextOptions::operator==(const TRuntimeTextOptions& rhs) const {
        return std::tie(Dictionaries, TokenizedFeatures) == std::tie(rhs.Dictionaries, rhs.TokenizedFeatures);
    }

    bool TRuntimeTextOptions::operator!=(const TRuntimeTextOptions& rhs) const {
        return !(rhs == *this);
    }

    ui32 TRuntimeTextOptions::TokenizedFeatureCount() const {
        return TokenizedFeatures->size();
    }

    const TVector<TTokenizedFeatureDescription>& TRuntimeTextOptions::GetTokenizedFeatureDescriptions() const {
        return TokenizedFeatures;
    }
}
