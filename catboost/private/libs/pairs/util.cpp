#include "util.h"

#include <catboost/libs/data/util.h>
#include <catboost/private/libs/options/loss_description.h>

#include <util/generic/set.h>
#include <util/generic/hash.h>
#include <util/random/shuffle.h>


using namespace NCB;


static void GenerateBruteForce(
    ui32 groupBegin,
    ui32 groupEnd,
    float groupWeight,
    int maxPairCount,
    int pairCount,
    TConstArrayRef<float> targetId,
    TRestorableFastRng64* rand,
    TVector<TPair>* result
) {
    auto resultShift = result->size();
    for (ui32 firstIdx = groupBegin; firstIdx < groupEnd; ++firstIdx) {
        for (ui32 secondIdx = firstIdx + 1; secondIdx < groupEnd; ++secondIdx) {
            if (targetId[firstIdx] == targetId[secondIdx]) {
                continue;
            }
            if (targetId[firstIdx] > targetId[secondIdx]) {
                result->push_back(TPair(firstIdx, secondIdx, groupWeight));
            } else {
                result->push_back(TPair(secondIdx, firstIdx, groupWeight));
            }
        }
    }
    if (maxPairCount != NCatboostOptions::MAX_AUTOGENERATED_PAIRS_COUNT && maxPairCount < pairCount) {
        Shuffle(result->begin() + resultShift, result->end(), *rand);
        result->resize(resultShift + maxPairCount);
    }
}

static bool TryGeneratePair(
    ui32 groupBegin,
    ui32 groupEnd,
    TConstArrayRef<float> targetId,
    TRestorableFastRng64* rand,
    ui32* firstIdxPtr,
    ui32* secondIdxPtr
) {
    auto& firstIdx = *firstIdxPtr;
    auto& secondIdx = *secondIdxPtr;
    auto size = groupEnd - groupBegin;
    firstIdx = rand->Uniform(size) + groupBegin;
    secondIdx = rand->Uniform(size) + groupBegin;
    if (firstIdx == secondIdx || targetId[firstIdx] == targetId[secondIdx]) {
        return false;
    }
    if (targetId[firstIdx] < targetId[secondIdx]) {
        std::swap(firstIdx, secondIdx);
    }
    return true;
}

static void GenerateRandomly(
    ui32 groupBegin,
    ui32 groupEnd,
    float groupWeight,
    int maxPairCount,
    TConstArrayRef<float> targetId,
    TRestorableFastRng64* rand,
    TVector<TPair>* result
) {
    TSet<std::pair<ui32, ui32>> generatedPairs;
    while (int(generatedPairs.size()) < maxPairCount) {
        ui32 firstIdx, secondIdx;
        if (TryGeneratePair(groupBegin, groupEnd, targetId, rand, &firstIdx, &secondIdx) && !generatedPairs.contains(std::make_pair(firstIdx, secondIdx))) {
            generatedPairs.insert({firstIdx, secondIdx});
        }
    }
    for (const auto& pair : generatedPairs) {
        result->push_back(TPair(pair.first, pair.second, groupWeight));
    }
}

void GeneratePairLogitPairs(
    const TObjectsGrouping& objectsGrouping,
    const TMaybe<NCB::TSharedWeights<float>>& weights,
    TConstArrayRef<float> targetId,
    int maxPairCount,
    TRestorableFastRng64* rand,
    TVector<TPair>* result
) {
    CB_ENSURE(!objectsGrouping.IsTrivial(), "Cannot generate pairs for data without groups");

    CheckDataSize(
        targetId.size(),
        (size_t)objectsGrouping.GetObjectCount(),
        "target",
        false,
        "object count",
        true);

    THashMap<float, int> targetCount;
    for (const auto& group : objectsGrouping.GetNonTrivialGroups()) {
        for (auto objectIdx : group.Iter()) {
            targetCount[targetId[objectIdx]]++;
        }
        uint64_t pairCount = 0;
        for (auto target: targetCount) {
            pairCount += target.second * static_cast<unsigned long long>(group.GetSize() - target.second);
        }
        pairCount /= 2;
        const float groupWeight = weights.Defined() ? (**weights)[group.Begin] : 1.0f;
        if (maxPairCount == NCatboostOptions::MAX_AUTOGENERATED_PAIRS_COUNT || pairCount / 2 < static_cast<uint64_t>(maxPairCount)) {
            CB_ENSURE(pairCount <= MAX_PAIR_COUNT_ON_GPU,
                "ToÐ¾ many pairs should be generated for group: " << pairCount << " , use max_pairs option to limit generated pair count");
            GenerateBruteForce(group.Begin, group.End, groupWeight, maxPairCount, static_cast<int>(pairCount), targetId, rand, result);
        } else {
            GenerateRandomly(group.Begin, group.End, groupWeight, maxPairCount, targetId, rand, result);
        }
        targetCount.clear();
    }
}

