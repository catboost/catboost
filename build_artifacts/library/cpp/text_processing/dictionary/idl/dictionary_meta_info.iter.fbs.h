// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DICTIONARYMETAINFO_NTEXTPROCESSINGFBS_ITER_H_
#define FLATBUFFERS_GENERATED_DICTIONARYMETAINFO_NTEXTPROCESSINGFBS_ITER_H_

#include "dictionary_meta_info.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

namespace NTextProcessingFbs {
namespace iter {

template <typename Iter>
struct TDictionaryOptions;

template <typename Iter>
struct TDictionaryMetaInfo;

template <typename Iter>
struct TDictionaryOptions FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_TOKENLEVELTYPE = 4,
    VT_GRAMORDER = 6,
    VT_SKIPSTEP = 8,
    VT_STARTTOKENID = 10,
    VT_ENDOFWORDTOKENPOLICY = 12,
    VT_ENDOFSENTENCETOKENPOLICY = 14
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  ETokenLevelType TokenLevelType() const {
    return static_cast<ETokenLevelType>(this->template GetField<int8_t>(VT_TOKENLEVELTYPE, 0));
  }
  int32_t GramOrder() const {
    return this->template GetField<int32_t>(VT_GRAMORDER, 1);
  }
  int32_t SkipStep() const {
    return this->template GetField<int32_t>(VT_SKIPSTEP, 0);
  }
  int32_t StartTokenId() const {
    return this->template GetField<int32_t>(VT_STARTTOKENID, 0);
  }
  EEndOfWordTokenPolicy EndOfWordTokenPolicy() const {
    return static_cast<EEndOfWordTokenPolicy>(this->template GetField<int8_t>(VT_ENDOFWORDTOKENPOLICY, 1));
  }
  EEndOfSentenceTokenPolicy EndOfSentenceTokenPolicy() const {
    return static_cast<EEndOfSentenceTokenPolicy>(this->template GetField<int8_t>(VT_ENDOFSENTENCETOKENPOLICY, 0));
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int8_t>(verifier, VT_TOKENLEVELTYPE, 1) &&
           this->template VerifyField<int32_t>(verifier, VT_GRAMORDER, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_SKIPSTEP, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_STARTTOKENID, 4) &&
           this->template VerifyField<int8_t>(verifier, VT_ENDOFWORDTOKENPOLICY, 1) &&
           this->template VerifyField<int8_t>(verifier, VT_ENDOFSENTENCETOKENPOLICY, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TDictionaryMetaInfo FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_DICTIONARYSIZE = 4,
    VT_DICTIONARYOPTIONS = 6,
    VT_UNKNOWNTOKENID = 8,
    VT_ENDOFSENTENCETOKENID = 10
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t DictionarySize() const {
    return this->template GetField<int32_t>(VT_DICTIONARYSIZE, 0);
  }
  std::optional<TDictionaryOptions<Iter>> DictionaryOptions() const {
    return this->template GetPointer<TDictionaryOptions<Iter>>(VT_DICTIONARYOPTIONS);
  }
  int32_t UnknownTokenId() const {
    return this->template GetField<int32_t>(VT_UNKNOWNTOKENID, 0);
  }
  int32_t EndOfSentenceTokenId() const {
    return this->template GetField<int32_t>(VT_ENDOFSENTENCETOKENID, 0);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_DICTIONARYSIZE, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_DICTIONARYOPTIONS) &&
           verifier.VerifyTable(DictionaryOptions()) &&
           this->template VerifyField<int32_t>(verifier, VT_UNKNOWNTOKENID, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_ENDOFSENTENCETOKENID, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
inline std::optional<NTextProcessingFbs::iter::TDictionaryMetaInfo<Iter>> GetTDictionaryMetaInfo(const Iter& buf) {
  return yandex::maps::flatbuffers_iter::GetRoot<NTextProcessingFbs::iter::TDictionaryMetaInfo<Iter>, Iter>(buf);
}

inline const NTextProcessingFbs::TDictionaryMetaInfo *GetTDictionaryMetaInfo(const char *buf) {
  return NTextProcessingFbs::GetTDictionaryMetaInfo(buf);
}

template <typename Iter>
inline bool VerifyTDictionaryMetaInfoBuffer(
    yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) {
  return verifier.template VerifyBuffer<NTextProcessingFbs::iter::TDictionaryMetaInfo<Iter>>(nullptr);
}

inline const char *TDictionaryMetaInfoExtension() {
  return "bfbs";
}

}  // namespace iter
}  // namespace NTextProcessingFbs

#endif  // FLATBUFFERS_GENERATED_DICTIONARYMETAINFO_NTEXTPROCESSINGFBS_ITER_H_
