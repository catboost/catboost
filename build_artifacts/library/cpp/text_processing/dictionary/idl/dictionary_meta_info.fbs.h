// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DICTIONARYMETAINFO_NTEXTPROCESSINGFBS_H_
#define FLATBUFFERS_GENERATED_DICTIONARYMETAINFO_NTEXTPROCESSINGFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace NTextProcessingFbs {

struct TDictionaryOptions;
struct TDictionaryOptionsBuilder;
struct TDictionaryOptionsT;

struct TDictionaryMetaInfo;
struct TDictionaryMetaInfoBuilder;
struct TDictionaryMetaInfoT;

enum ETokenLevelType : int8_t {
  ETokenLevelType_Word = 0,
  ETokenLevelType_Letter = 1,
  ETokenLevelType_MIN = ETokenLevelType_Word,
  ETokenLevelType_MAX = ETokenLevelType_Letter
};

inline const ETokenLevelType (&EnumValuesETokenLevelType())[2] {
  static const ETokenLevelType values[] = {
    ETokenLevelType_Word,
    ETokenLevelType_Letter
  };
  return values;
}

inline const char * const *EnumNamesETokenLevelType() {
  static const char * const names[3] = {
    "Word",
    "Letter",
    nullptr
  };
  return names;
}

inline const char *EnumNameETokenLevelType(ETokenLevelType e) {
  if (::flatbuffers::IsOutRange(e, ETokenLevelType_Word, ETokenLevelType_Letter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesETokenLevelType()[index];
}

enum EEndOfWordTokenPolicy : int8_t {
  EEndOfWordTokenPolicy_Skip = 0,
  EEndOfWordTokenPolicy_Insert = 1,
  EEndOfWordTokenPolicy_MIN = EEndOfWordTokenPolicy_Skip,
  EEndOfWordTokenPolicy_MAX = EEndOfWordTokenPolicy_Insert
};

inline const EEndOfWordTokenPolicy (&EnumValuesEEndOfWordTokenPolicy())[2] {
  static const EEndOfWordTokenPolicy values[] = {
    EEndOfWordTokenPolicy_Skip,
    EEndOfWordTokenPolicy_Insert
  };
  return values;
}

inline const char * const *EnumNamesEEndOfWordTokenPolicy() {
  static const char * const names[3] = {
    "Skip",
    "Insert",
    nullptr
  };
  return names;
}

inline const char *EnumNameEEndOfWordTokenPolicy(EEndOfWordTokenPolicy e) {
  if (::flatbuffers::IsOutRange(e, EEndOfWordTokenPolicy_Skip, EEndOfWordTokenPolicy_Insert)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEEndOfWordTokenPolicy()[index];
}

enum EEndOfSentenceTokenPolicy : int8_t {
  EEndOfSentenceTokenPolicy_Skip = 0,
  EEndOfSentenceTokenPolicy_Insert = 1,
  EEndOfSentenceTokenPolicy_MIN = EEndOfSentenceTokenPolicy_Skip,
  EEndOfSentenceTokenPolicy_MAX = EEndOfSentenceTokenPolicy_Insert
};

inline const EEndOfSentenceTokenPolicy (&EnumValuesEEndOfSentenceTokenPolicy())[2] {
  static const EEndOfSentenceTokenPolicy values[] = {
    EEndOfSentenceTokenPolicy_Skip,
    EEndOfSentenceTokenPolicy_Insert
  };
  return values;
}

inline const char * const *EnumNamesEEndOfSentenceTokenPolicy() {
  static const char * const names[3] = {
    "Skip",
    "Insert",
    nullptr
  };
  return names;
}

inline const char *EnumNameEEndOfSentenceTokenPolicy(EEndOfSentenceTokenPolicy e) {
  if (::flatbuffers::IsOutRange(e, EEndOfSentenceTokenPolicy_Skip, EEndOfSentenceTokenPolicy_Insert)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEEndOfSentenceTokenPolicy()[index];
}

struct TDictionaryOptionsT : public ::flatbuffers::NativeTable {
  typedef TDictionaryOptions TableType;
  NTextProcessingFbs::ETokenLevelType TokenLevelType = NTextProcessingFbs::ETokenLevelType_Word;
  int32_t GramOrder = 1;
  int32_t SkipStep = 0;
  int32_t StartTokenId = 0;
  NTextProcessingFbs::EEndOfWordTokenPolicy EndOfWordTokenPolicy = NTextProcessingFbs::EEndOfWordTokenPolicy_Insert;
  NTextProcessingFbs::EEndOfSentenceTokenPolicy EndOfSentenceTokenPolicy = NTextProcessingFbs::EEndOfSentenceTokenPolicy_Skip;
};

struct TDictionaryOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDictionaryOptionsT NativeTableType;
  typedef TDictionaryOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENLEVELTYPE = 4,
    VT_GRAMORDER = 6,
    VT_SKIPSTEP = 8,
    VT_STARTTOKENID = 10,
    VT_ENDOFWORDTOKENPOLICY = 12,
    VT_ENDOFSENTENCETOKENPOLICY = 14
  };
  NTextProcessingFbs::ETokenLevelType TokenLevelType() const {
    return static_cast<NTextProcessingFbs::ETokenLevelType>(GetField<int8_t>(VT_TOKENLEVELTYPE, 0));
  }
  bool mutate_TokenLevelType(NTextProcessingFbs::ETokenLevelType _TokenLevelType = static_cast<NTextProcessingFbs::ETokenLevelType>(0)) {
    return SetField<int8_t>(VT_TOKENLEVELTYPE, static_cast<int8_t>(_TokenLevelType), 0);
  }
  int32_t GramOrder() const {
    return GetField<int32_t>(VT_GRAMORDER, 1);
  }
  bool mutate_GramOrder(int32_t _GramOrder = 1) {
    return SetField<int32_t>(VT_GRAMORDER, _GramOrder, 1);
  }
  int32_t SkipStep() const {
    return GetField<int32_t>(VT_SKIPSTEP, 0);
  }
  bool mutate_SkipStep(int32_t _SkipStep = 0) {
    return SetField<int32_t>(VT_SKIPSTEP, _SkipStep, 0);
  }
  int32_t StartTokenId() const {
    return GetField<int32_t>(VT_STARTTOKENID, 0);
  }
  bool mutate_StartTokenId(int32_t _StartTokenId = 0) {
    return SetField<int32_t>(VT_STARTTOKENID, _StartTokenId, 0);
  }
  NTextProcessingFbs::EEndOfWordTokenPolicy EndOfWordTokenPolicy() const {
    return static_cast<NTextProcessingFbs::EEndOfWordTokenPolicy>(GetField<int8_t>(VT_ENDOFWORDTOKENPOLICY, 1));
  }
  bool mutate_EndOfWordTokenPolicy(NTextProcessingFbs::EEndOfWordTokenPolicy _EndOfWordTokenPolicy = static_cast<NTextProcessingFbs::EEndOfWordTokenPolicy>(1)) {
    return SetField<int8_t>(VT_ENDOFWORDTOKENPOLICY, static_cast<int8_t>(_EndOfWordTokenPolicy), 1);
  }
  NTextProcessingFbs::EEndOfSentenceTokenPolicy EndOfSentenceTokenPolicy() const {
    return static_cast<NTextProcessingFbs::EEndOfSentenceTokenPolicy>(GetField<int8_t>(VT_ENDOFSENTENCETOKENPOLICY, 0));
  }
  bool mutate_EndOfSentenceTokenPolicy(NTextProcessingFbs::EEndOfSentenceTokenPolicy _EndOfSentenceTokenPolicy = static_cast<NTextProcessingFbs::EEndOfSentenceTokenPolicy>(0)) {
    return SetField<int8_t>(VT_ENDOFSENTENCETOKENPOLICY, static_cast<int8_t>(_EndOfSentenceTokenPolicy), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TOKENLEVELTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_GRAMORDER, 4) &&
           VerifyField<int32_t>(verifier, VT_SKIPSTEP, 4) &&
           VerifyField<int32_t>(verifier, VT_STARTTOKENID, 4) &&
           VerifyField<int8_t>(verifier, VT_ENDOFWORDTOKENPOLICY, 1) &&
           VerifyField<int8_t>(verifier, VT_ENDOFSENTENCETOKENPOLICY, 1) &&
           verifier.EndTable();
  }
  TDictionaryOptionsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDictionaryOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TDictionaryOptions> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TDictionaryOptionsBuilder {
  typedef TDictionaryOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TokenLevelType(NTextProcessingFbs::ETokenLevelType TokenLevelType) {
    fbb_.AddElement<int8_t>(TDictionaryOptions::VT_TOKENLEVELTYPE, static_cast<int8_t>(TokenLevelType), 0);
  }
  void add_GramOrder(int32_t GramOrder) {
    fbb_.AddElement<int32_t>(TDictionaryOptions::VT_GRAMORDER, GramOrder, 1);
  }
  void add_SkipStep(int32_t SkipStep) {
    fbb_.AddElement<int32_t>(TDictionaryOptions::VT_SKIPSTEP, SkipStep, 0);
  }
  void add_StartTokenId(int32_t StartTokenId) {
    fbb_.AddElement<int32_t>(TDictionaryOptions::VT_STARTTOKENID, StartTokenId, 0);
  }
  void add_EndOfWordTokenPolicy(NTextProcessingFbs::EEndOfWordTokenPolicy EndOfWordTokenPolicy) {
    fbb_.AddElement<int8_t>(TDictionaryOptions::VT_ENDOFWORDTOKENPOLICY, static_cast<int8_t>(EndOfWordTokenPolicy), 1);
  }
  void add_EndOfSentenceTokenPolicy(NTextProcessingFbs::EEndOfSentenceTokenPolicy EndOfSentenceTokenPolicy) {
    fbb_.AddElement<int8_t>(TDictionaryOptions::VT_ENDOFSENTENCETOKENPOLICY, static_cast<int8_t>(EndOfSentenceTokenPolicy), 0);
  }
  explicit TDictionaryOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TDictionaryOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TDictionaryOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TDictionaryOptions> CreateTDictionaryOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NTextProcessingFbs::ETokenLevelType TokenLevelType = NTextProcessingFbs::ETokenLevelType_Word,
    int32_t GramOrder = 1,
    int32_t SkipStep = 0,
    int32_t StartTokenId = 0,
    NTextProcessingFbs::EEndOfWordTokenPolicy EndOfWordTokenPolicy = NTextProcessingFbs::EEndOfWordTokenPolicy_Insert,
    NTextProcessingFbs::EEndOfSentenceTokenPolicy EndOfSentenceTokenPolicy = NTextProcessingFbs::EEndOfSentenceTokenPolicy_Skip) {
  TDictionaryOptionsBuilder builder_(_fbb);
  builder_.add_StartTokenId(StartTokenId);
  builder_.add_SkipStep(SkipStep);
  builder_.add_GramOrder(GramOrder);
  builder_.add_EndOfSentenceTokenPolicy(EndOfSentenceTokenPolicy);
  builder_.add_EndOfWordTokenPolicy(EndOfWordTokenPolicy);
  builder_.add_TokenLevelType(TokenLevelType);
  return builder_.Finish();
}

::flatbuffers::Offset<TDictionaryOptions> CreateTDictionaryOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TDictionaryMetaInfoT : public ::flatbuffers::NativeTable {
  typedef TDictionaryMetaInfo TableType;
  int32_t DictionarySize = 0;
  std::unique_ptr<NTextProcessingFbs::TDictionaryOptionsT> DictionaryOptions{};
  int32_t UnknownTokenId = 0;
  int32_t EndOfSentenceTokenId = 0;
  TDictionaryMetaInfoT() = default;
  TDictionaryMetaInfoT(const TDictionaryMetaInfoT &o);
  TDictionaryMetaInfoT(TDictionaryMetaInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  TDictionaryMetaInfoT &operator=(TDictionaryMetaInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct TDictionaryMetaInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDictionaryMetaInfoT NativeTableType;
  typedef TDictionaryMetaInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DICTIONARYSIZE = 4,
    VT_DICTIONARYOPTIONS = 6,
    VT_UNKNOWNTOKENID = 8,
    VT_ENDOFSENTENCETOKENID = 10
  };
  int32_t DictionarySize() const {
    return GetField<int32_t>(VT_DICTIONARYSIZE, 0);
  }
  bool mutate_DictionarySize(int32_t _DictionarySize = 0) {
    return SetField<int32_t>(VT_DICTIONARYSIZE, _DictionarySize, 0);
  }
  const NTextProcessingFbs::TDictionaryOptions *DictionaryOptions() const {
    return GetPointer<const NTextProcessingFbs::TDictionaryOptions *>(VT_DICTIONARYOPTIONS);
  }
  NTextProcessingFbs::TDictionaryOptions *mutable_DictionaryOptions() {
    return GetPointer<NTextProcessingFbs::TDictionaryOptions *>(VT_DICTIONARYOPTIONS);
  }
  int32_t UnknownTokenId() const {
    return GetField<int32_t>(VT_UNKNOWNTOKENID, 0);
  }
  bool mutate_UnknownTokenId(int32_t _UnknownTokenId = 0) {
    return SetField<int32_t>(VT_UNKNOWNTOKENID, _UnknownTokenId, 0);
  }
  int32_t EndOfSentenceTokenId() const {
    return GetField<int32_t>(VT_ENDOFSENTENCETOKENID, 0);
  }
  bool mutate_EndOfSentenceTokenId(int32_t _EndOfSentenceTokenId = 0) {
    return SetField<int32_t>(VT_ENDOFSENTENCETOKENID, _EndOfSentenceTokenId, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DICTIONARYSIZE, 4) &&
           VerifyOffset(verifier, VT_DICTIONARYOPTIONS) &&
           verifier.VerifyTable(DictionaryOptions()) &&
           VerifyField<int32_t>(verifier, VT_UNKNOWNTOKENID, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDOFSENTENCETOKENID, 4) &&
           verifier.EndTable();
  }
  TDictionaryMetaInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDictionaryMetaInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TDictionaryMetaInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryMetaInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TDictionaryMetaInfoBuilder {
  typedef TDictionaryMetaInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DictionarySize(int32_t DictionarySize) {
    fbb_.AddElement<int32_t>(TDictionaryMetaInfo::VT_DICTIONARYSIZE, DictionarySize, 0);
  }
  void add_DictionaryOptions(::flatbuffers::Offset<NTextProcessingFbs::TDictionaryOptions> DictionaryOptions) {
    fbb_.AddOffset(TDictionaryMetaInfo::VT_DICTIONARYOPTIONS, DictionaryOptions);
  }
  void add_UnknownTokenId(int32_t UnknownTokenId) {
    fbb_.AddElement<int32_t>(TDictionaryMetaInfo::VT_UNKNOWNTOKENID, UnknownTokenId, 0);
  }
  void add_EndOfSentenceTokenId(int32_t EndOfSentenceTokenId) {
    fbb_.AddElement<int32_t>(TDictionaryMetaInfo::VT_ENDOFSENTENCETOKENID, EndOfSentenceTokenId, 0);
  }
  explicit TDictionaryMetaInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TDictionaryMetaInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TDictionaryMetaInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TDictionaryMetaInfo> CreateTDictionaryMetaInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t DictionarySize = 0,
    ::flatbuffers::Offset<NTextProcessingFbs::TDictionaryOptions> DictionaryOptions = 0,
    int32_t UnknownTokenId = 0,
    int32_t EndOfSentenceTokenId = 0) {
  TDictionaryMetaInfoBuilder builder_(_fbb);
  builder_.add_EndOfSentenceTokenId(EndOfSentenceTokenId);
  builder_.add_UnknownTokenId(UnknownTokenId);
  builder_.add_DictionaryOptions(DictionaryOptions);
  builder_.add_DictionarySize(DictionarySize);
  return builder_.Finish();
}

::flatbuffers::Offset<TDictionaryMetaInfo> CreateTDictionaryMetaInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryMetaInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TDictionaryOptionsT *TDictionaryOptions::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TDictionaryOptionsT>(new TDictionaryOptionsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TDictionaryOptions::UnPackTo(TDictionaryOptionsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = TokenLevelType(); _o->TokenLevelType = _e; }
  { auto _e = GramOrder(); _o->GramOrder = _e; }
  { auto _e = SkipStep(); _o->SkipStep = _e; }
  { auto _e = StartTokenId(); _o->StartTokenId = _e; }
  { auto _e = EndOfWordTokenPolicy(); _o->EndOfWordTokenPolicy = _e; }
  { auto _e = EndOfSentenceTokenPolicy(); _o->EndOfSentenceTokenPolicy = _e; }
}

inline ::flatbuffers::Offset<TDictionaryOptions> TDictionaryOptions::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryOptionsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTDictionaryOptions(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TDictionaryOptions> CreateTDictionaryOptions(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryOptionsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDictionaryOptionsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _TokenLevelType = _o->TokenLevelType;
  auto _GramOrder = _o->GramOrder;
  auto _SkipStep = _o->SkipStep;
  auto _StartTokenId = _o->StartTokenId;
  auto _EndOfWordTokenPolicy = _o->EndOfWordTokenPolicy;
  auto _EndOfSentenceTokenPolicy = _o->EndOfSentenceTokenPolicy;
  return NTextProcessingFbs::CreateTDictionaryOptions(
      _fbb,
      _TokenLevelType,
      _GramOrder,
      _SkipStep,
      _StartTokenId,
      _EndOfWordTokenPolicy,
      _EndOfSentenceTokenPolicy);
}

inline TDictionaryMetaInfoT::TDictionaryMetaInfoT(const TDictionaryMetaInfoT &o)
      : DictionarySize(o.DictionarySize),
        DictionaryOptions((o.DictionaryOptions) ? new NTextProcessingFbs::TDictionaryOptionsT(*o.DictionaryOptions) : nullptr),
        UnknownTokenId(o.UnknownTokenId),
        EndOfSentenceTokenId(o.EndOfSentenceTokenId) {
}

inline TDictionaryMetaInfoT &TDictionaryMetaInfoT::operator=(TDictionaryMetaInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(DictionarySize, o.DictionarySize);
  std::swap(DictionaryOptions, o.DictionaryOptions);
  std::swap(UnknownTokenId, o.UnknownTokenId);
  std::swap(EndOfSentenceTokenId, o.EndOfSentenceTokenId);
  return *this;
}

inline TDictionaryMetaInfoT *TDictionaryMetaInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TDictionaryMetaInfoT>(new TDictionaryMetaInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TDictionaryMetaInfo::UnPackTo(TDictionaryMetaInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = DictionarySize(); _o->DictionarySize = _e; }
  { auto _e = DictionaryOptions(); if (_e) { if(_o->DictionaryOptions) { _e->UnPackTo(_o->DictionaryOptions.get(), _resolver); } else { _o->DictionaryOptions = std::unique_ptr<NTextProcessingFbs::TDictionaryOptionsT>(_e->UnPack(_resolver)); } } else if (_o->DictionaryOptions) { _o->DictionaryOptions.reset(); } }
  { auto _e = UnknownTokenId(); _o->UnknownTokenId = _e; }
  { auto _e = EndOfSentenceTokenId(); _o->EndOfSentenceTokenId = _e; }
}

inline ::flatbuffers::Offset<TDictionaryMetaInfo> TDictionaryMetaInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryMetaInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTDictionaryMetaInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TDictionaryMetaInfo> CreateTDictionaryMetaInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TDictionaryMetaInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDictionaryMetaInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _DictionarySize = _o->DictionarySize;
  auto _DictionaryOptions = _o->DictionaryOptions ? CreateTDictionaryOptions(_fbb, _o->DictionaryOptions.get(), _rehasher) : 0;
  auto _UnknownTokenId = _o->UnknownTokenId;
  auto _EndOfSentenceTokenId = _o->EndOfSentenceTokenId;
  return NTextProcessingFbs::CreateTDictionaryMetaInfo(
      _fbb,
      _DictionarySize,
      _DictionaryOptions,
      _UnknownTokenId,
      _EndOfSentenceTokenId);
}

inline const NTextProcessingFbs::TDictionaryMetaInfo *GetTDictionaryMetaInfo(const void *buf) {
  return ::flatbuffers::GetRoot<NTextProcessingFbs::TDictionaryMetaInfo>(buf);
}

inline const NTextProcessingFbs::TDictionaryMetaInfo *GetSizePrefixedTDictionaryMetaInfo(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NTextProcessingFbs::TDictionaryMetaInfo>(buf);
}

inline TDictionaryMetaInfo *GetMutableTDictionaryMetaInfo(void *buf) {
  return ::flatbuffers::GetMutableRoot<TDictionaryMetaInfo>(buf);
}

inline NTextProcessingFbs::TDictionaryMetaInfo *GetMutableSizePrefixedTDictionaryMetaInfo(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NTextProcessingFbs::TDictionaryMetaInfo>(buf);
}

inline bool VerifyTDictionaryMetaInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NTextProcessingFbs::TDictionaryMetaInfo>(nullptr);
}

inline bool VerifySizePrefixedTDictionaryMetaInfoBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NTextProcessingFbs::TDictionaryMetaInfo>(nullptr);
}

inline const char *TDictionaryMetaInfoExtension() {
  return "bfbs";
}

inline void FinishTDictionaryMetaInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NTextProcessingFbs::TDictionaryMetaInfo> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTDictionaryMetaInfoBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NTextProcessingFbs::TDictionaryMetaInfo> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NTextProcessingFbs::TDictionaryMetaInfoT> UnPackTDictionaryMetaInfo(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NTextProcessingFbs::TDictionaryMetaInfoT>(GetTDictionaryMetaInfo(buf)->UnPack(res));
}

inline std::unique_ptr<NTextProcessingFbs::TDictionaryMetaInfoT> UnPackSizePrefixedTDictionaryMetaInfo(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NTextProcessingFbs::TDictionaryMetaInfoT>(GetSizePrefixedTDictionaryMetaInfo(buf)->UnPack(res));
}

}  // namespace NTextProcessingFbs

#endif  // FLATBUFFERS_GENERATED_DICTIONARYMETAINFO_NTEXTPROCESSINGFBS_H_
