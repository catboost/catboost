// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_ITER_H_
#define FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_ITER_H_

#include "features.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

#include "catboost/libs/helpers/flatbuffers/guid.iter.fbs.h"

namespace NCatBoostFbs {
namespace iter {

template <typename Iter>
struct TFloatFeature;

template <typename Iter>
struct TCatFeature;

template <typename Iter>
struct TTextFeature;

template <typename Iter>
struct TEmbeddingFeature;

template <typename Iter>
struct TEstimatedFeature;

template <typename Iter>
struct TOneHotFeature;

template <typename Iter>
struct TFeatureCombination;

template <typename Iter>
struct TFloatFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_HASNANS = 4,
    VT_INDEX = 6,
    VT_FLATINDEX = 8,
    VT_BORDERS = 10,
    VT_FEATUREID = 12,
    VT_NANVALUETREATMENT = 14
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  bool HasNans() const {
    return this->template GetField<uint8_t>(VT_HASNANS, 0) != 0;
  }
  int32_t Index() const {
    return this->template GetField<int32_t>(VT_INDEX, -1);
  }
  int32_t FlatIndex() const {
    return this->template GetField<int32_t>(VT_FLATINDEX, -1);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<float, Iter>> Borders() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<float, Iter>>(VT_BORDERS);
  }
  std::optional<yandex::maps::flatbuffers_iter::String<Iter>> FeatureId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::String<Iter>>(VT_FEATUREID);
  }
  ENanValueTreatment NanValueTreatment() const {
    return static_cast<ENanValueTreatment>(this->template GetField<int8_t>(VT_NANVALUETREATMENT, 0));
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<uint8_t>(verifier, VT_HASNANS, 1) &&
           this->template VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_BORDERS) &&
           verifier.Verify(Borders()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATUREID) &&
           verifier.Verify(FeatureId()) &&
           this->template VerifyField<int8_t>(verifier, VT_NANVALUETREATMENT, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCatFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_USEDINMODEL = 10
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t Index() const {
    return this->template GetField<int32_t>(VT_INDEX, -1);
  }
  int32_t FlatIndex() const {
    return this->template GetField<int32_t>(VT_FLATINDEX, -1);
  }
  std::optional<yandex::maps::flatbuffers_iter::String<Iter>> FeatureId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::String<Iter>>(VT_FEATUREID);
  }
  bool UsedInModel() const {
    return this->template GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATUREID) &&
           verifier.Verify(FeatureId()) &&
           this->template VerifyField<uint8_t>(verifier, VT_USEDINMODEL, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TTextFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_USEDINMODEL = 10
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t Index() const {
    return this->template GetField<int32_t>(VT_INDEX, -1);
  }
  int32_t FlatIndex() const {
    return this->template GetField<int32_t>(VT_FLATINDEX, -1);
  }
  std::optional<yandex::maps::flatbuffers_iter::String<Iter>> FeatureId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::String<Iter>>(VT_FEATUREID);
  }
  bool UsedInModel() const {
    return this->template GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATUREID) &&
           verifier.Verify(FeatureId()) &&
           this->template VerifyField<uint8_t>(verifier, VT_USEDINMODEL, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TEmbeddingFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_DIMENSION = 10,
    VT_USEDINMODEL = 12
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t Index() const {
    return this->template GetField<int32_t>(VT_INDEX, -1);
  }
  int32_t FlatIndex() const {
    return this->template GetField<int32_t>(VT_FLATINDEX, -1);
  }
  std::optional<yandex::maps::flatbuffers_iter::String<Iter>> FeatureId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::String<Iter>>(VT_FEATUREID);
  }
  int32_t Dimension() const {
    return this->template GetField<int32_t>(VT_DIMENSION, 0);
  }
  bool UsedInModel() const {
    return this->template GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATUREID) &&
           verifier.Verify(FeatureId()) &&
           this->template VerifyField<int32_t>(verifier, VT_DIMENSION, 4) &&
           this->template VerifyField<uint8_t>(verifier, VT_USEDINMODEL, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TEstimatedFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_SOURCEFEATUREINDEX = 4,
    VT_CALCERID = 6,
    VT_LOCALINDEX = 8,
    VT_BORDERS = 10,
    VT_SOURCEFEATURETYPE = 12
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t SourceFeatureIndex() const {
    return this->template GetField<int32_t>(VT_SOURCEFEATUREINDEX, -1);
  }
  std::optional<TGuid> CalcerId() const {
    return this->template GetStruct<TGuid>(VT_CALCERID);
  }
  int32_t LocalIndex() const {
    return this->template GetField<int32_t>(VT_LOCALINDEX, -1);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<float, Iter>> Borders() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<float, Iter>>(VT_BORDERS);
  }
  ESourceFeatureType SourceFeatureType() const {
    return static_cast<ESourceFeatureType>(this->template GetField<int8_t>(VT_SOURCEFEATURETYPE, 0));
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_SOURCEFEATUREINDEX, 4) &&
           this->template VerifyField<TGuid>(verifier, VT_CALCERID, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_LOCALINDEX, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_BORDERS) &&
           verifier.Verify(Borders()) &&
           this->template VerifyField<int8_t>(verifier, VT_SOURCEFEATURETYPE, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TOneHotFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_INDEX = 4,
    VT_VALUES = 6,
    VT_STRINGVALUES = 8
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t Index() const {
    return this->template GetField<int32_t>(VT_INDEX, -1);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<int32_t, Iter>> Values() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<int32_t, Iter>>(VT_VALUES);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<yandex::maps::flatbuffers_iter::String<Iter>>, Iter>> StringValues() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<yandex::maps::flatbuffers_iter::String<Iter>>, Iter>>(VT_STRINGVALUES);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_VALUES) &&
           verifier.Verify(Values()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_STRINGVALUES) &&
           verifier.Verify(StringValues()) &&
           verifier.VerifyVectorOfStrings(StringValues()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TFeatureCombination FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_CATFEATURES = 4,
    VT_FLOATSPLITS = 6,
    VT_ONEHOTSPLITS = 8
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<yandex::maps::flatbuffers_iter::Vector<int32_t, Iter>> CatFeatures() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<int32_t, Iter>>(VT_CATFEATURES);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<TFloatSplit, Iter>> FloatSplits() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<TFloatSplit, Iter>>(VT_FLOATSPLITS);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<TOneHotSplit, Iter>> OneHotSplits() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<TOneHotSplit, Iter>>(VT_ONEHOTSPLITS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CATFEATURES) &&
           verifier.Verify(CatFeatures()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FLOATSPLITS) &&
           verifier.Verify(FloatSplits()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_ONEHOTSPLITS) &&
           verifier.Verify(OneHotSplits()) &&
           verifier.EndTable();
  }
};

}  // namespace iter
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_ITER_H_
