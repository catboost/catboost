// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/model/flatbuffers/features.fbs.h"

namespace NCatBoostFbs {

struct TModelCtrBase;
struct TModelCtrBaseBuilder;
struct TModelCtrBaseT;

struct TModelCtr;
struct TModelCtrBuilder;
struct TModelCtrT;

struct TCtrFeature;
struct TCtrFeatureBuilder;
struct TCtrFeatureT;

struct TCtrValueTable;
struct TCtrValueTableBuilder;
struct TCtrValueTableT;

enum ECtrType : int8_t {
  ECtrType_Borders = 0,
  ECtrType_Buckets = 1,
  ECtrType_BinarizedTargetMeanValue = 2,
  ECtrType_FloatTargetMeanValue = 3,
  ECtrType_Counter = 4,
  ECtrType_FeatureFreq = 5,
  ECtrType_MIN = ECtrType_Borders,
  ECtrType_MAX = ECtrType_FeatureFreq
};

inline const ECtrType (&EnumValuesECtrType())[6] {
  static const ECtrType values[] = {
    ECtrType_Borders,
    ECtrType_Buckets,
    ECtrType_BinarizedTargetMeanValue,
    ECtrType_FloatTargetMeanValue,
    ECtrType_Counter,
    ECtrType_FeatureFreq
  };
  return values;
}

inline const char * const *EnumNamesECtrType() {
  static const char * const names[7] = {
    "Borders",
    "Buckets",
    "BinarizedTargetMeanValue",
    "FloatTargetMeanValue",
    "Counter",
    "FeatureFreq",
    nullptr
  };
  return names;
}

inline const char *EnumNameECtrType(ECtrType e) {
  if (::flatbuffers::IsOutRange(e, ECtrType_Borders, ECtrType_FeatureFreq)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesECtrType()[index];
}

struct TModelCtrBaseT : public ::flatbuffers::NativeTable {
  typedef TModelCtrBase TableType;
  std::unique_ptr<NCatBoostFbs::TFeatureCombinationT> FeatureCombination{};
  NCatBoostFbs::ECtrType CtrType = NCatBoostFbs::ECtrType_Borders;
  int32_t TargetBorderClassifierIdx = 0;
  TModelCtrBaseT() = default;
  TModelCtrBaseT(const TModelCtrBaseT &o);
  TModelCtrBaseT(TModelCtrBaseT&&) FLATBUFFERS_NOEXCEPT = default;
  TModelCtrBaseT &operator=(TModelCtrBaseT o) FLATBUFFERS_NOEXCEPT;
};

struct TModelCtrBase FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TModelCtrBaseT NativeTableType;
  typedef TModelCtrBaseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURECOMBINATION = 4,
    VT_CTRTYPE = 6,
    VT_TARGETBORDERCLASSIFIERIDX = 8
  };
  const NCatBoostFbs::TFeatureCombination *FeatureCombination() const {
    return GetPointer<const NCatBoostFbs::TFeatureCombination *>(VT_FEATURECOMBINATION);
  }
  NCatBoostFbs::TFeatureCombination *mutable_FeatureCombination() {
    return GetPointer<NCatBoostFbs::TFeatureCombination *>(VT_FEATURECOMBINATION);
  }
  NCatBoostFbs::ECtrType CtrType() const {
    return static_cast<NCatBoostFbs::ECtrType>(GetField<int8_t>(VT_CTRTYPE, 0));
  }
  bool mutate_CtrType(NCatBoostFbs::ECtrType _CtrType = static_cast<NCatBoostFbs::ECtrType>(0)) {
    return SetField<int8_t>(VT_CTRTYPE, static_cast<int8_t>(_CtrType), 0);
  }
  int32_t TargetBorderClassifierIdx() const {
    return GetField<int32_t>(VT_TARGETBORDERCLASSIFIERIDX, 0);
  }
  bool mutate_TargetBorderClassifierIdx(int32_t _TargetBorderClassifierIdx = 0) {
    return SetField<int32_t>(VT_TARGETBORDERCLASSIFIERIDX, _TargetBorderClassifierIdx, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FEATURECOMBINATION) &&
           verifier.VerifyTable(FeatureCombination()) &&
           VerifyField<int8_t>(verifier, VT_CTRTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_TARGETBORDERCLASSIFIERIDX, 4) &&
           verifier.EndTable();
  }
  TModelCtrBaseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TModelCtrBaseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TModelCtrBase> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrBaseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TModelCtrBaseBuilder {
  typedef TModelCtrBase Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FeatureCombination(::flatbuffers::Offset<NCatBoostFbs::TFeatureCombination> FeatureCombination) {
    fbb_.AddOffset(TModelCtrBase::VT_FEATURECOMBINATION, FeatureCombination);
  }
  void add_CtrType(NCatBoostFbs::ECtrType CtrType) {
    fbb_.AddElement<int8_t>(TModelCtrBase::VT_CTRTYPE, static_cast<int8_t>(CtrType), 0);
  }
  void add_TargetBorderClassifierIdx(int32_t TargetBorderClassifierIdx) {
    fbb_.AddElement<int32_t>(TModelCtrBase::VT_TARGETBORDERCLASSIFIERIDX, TargetBorderClassifierIdx, 0);
  }
  explicit TModelCtrBaseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TModelCtrBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TModelCtrBase>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TModelCtrBase> CreateTModelCtrBase(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TFeatureCombination> FeatureCombination = 0,
    NCatBoostFbs::ECtrType CtrType = NCatBoostFbs::ECtrType_Borders,
    int32_t TargetBorderClassifierIdx = 0) {
  TModelCtrBaseBuilder builder_(_fbb);
  builder_.add_TargetBorderClassifierIdx(TargetBorderClassifierIdx);
  builder_.add_FeatureCombination(FeatureCombination);
  builder_.add_CtrType(CtrType);
  return builder_.Finish();
}

::flatbuffers::Offset<TModelCtrBase> CreateTModelCtrBase(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrBaseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TModelCtrT : public ::flatbuffers::NativeTable {
  typedef TModelCtr TableType;
  std::unique_ptr<NCatBoostFbs::TModelCtrBaseT> Base{};
  int32_t TargetBorderIdx = 0;
  float PriorNum = 0.0f;
  float PriorDenom = 1.0f;
  float Shift = 0.0f;
  float Scale = 1.0f;
  TModelCtrT() = default;
  TModelCtrT(const TModelCtrT &o);
  TModelCtrT(TModelCtrT&&) FLATBUFFERS_NOEXCEPT = default;
  TModelCtrT &operator=(TModelCtrT o) FLATBUFFERS_NOEXCEPT;
};

struct TModelCtr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TModelCtrT NativeTableType;
  typedef TModelCtrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_TARGETBORDERIDX = 6,
    VT_PRIORNUM = 8,
    VT_PRIORDENOM = 10,
    VT_SHIFT = 12,
    VT_SCALE = 14
  };
  const NCatBoostFbs::TModelCtrBase *Base() const {
    return GetPointer<const NCatBoostFbs::TModelCtrBase *>(VT_BASE);
  }
  NCatBoostFbs::TModelCtrBase *mutable_Base() {
    return GetPointer<NCatBoostFbs::TModelCtrBase *>(VT_BASE);
  }
  int32_t TargetBorderIdx() const {
    return GetField<int32_t>(VT_TARGETBORDERIDX, 0);
  }
  bool mutate_TargetBorderIdx(int32_t _TargetBorderIdx = 0) {
    return SetField<int32_t>(VT_TARGETBORDERIDX, _TargetBorderIdx, 0);
  }
  float PriorNum() const {
    return GetField<float>(VT_PRIORNUM, 0.0f);
  }
  bool mutate_PriorNum(float _PriorNum = 0.0f) {
    return SetField<float>(VT_PRIORNUM, _PriorNum, 0.0f);
  }
  float PriorDenom() const {
    return GetField<float>(VT_PRIORDENOM, 1.0f);
  }
  bool mutate_PriorDenom(float _PriorDenom = 1.0f) {
    return SetField<float>(VT_PRIORDENOM, _PriorDenom, 1.0f);
  }
  float Shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_Shift(float _Shift = 0.0f) {
    return SetField<float>(VT_SHIFT, _Shift, 0.0f);
  }
  float Scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool mutate_Scale(float _Scale = 1.0f) {
    return SetField<float>(VT_SCALE, _Scale, 1.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(Base()) &&
           VerifyField<int32_t>(verifier, VT_TARGETBORDERIDX, 4) &&
           VerifyField<float>(verifier, VT_PRIORNUM, 4) &&
           VerifyField<float>(verifier, VT_PRIORDENOM, 4) &&
           VerifyField<float>(verifier, VT_SHIFT, 4) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
  TModelCtrT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TModelCtrT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TModelCtr> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TModelCtrBuilder {
  typedef TModelCtr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Base(::flatbuffers::Offset<NCatBoostFbs::TModelCtrBase> Base) {
    fbb_.AddOffset(TModelCtr::VT_BASE, Base);
  }
  void add_TargetBorderIdx(int32_t TargetBorderIdx) {
    fbb_.AddElement<int32_t>(TModelCtr::VT_TARGETBORDERIDX, TargetBorderIdx, 0);
  }
  void add_PriorNum(float PriorNum) {
    fbb_.AddElement<float>(TModelCtr::VT_PRIORNUM, PriorNum, 0.0f);
  }
  void add_PriorDenom(float PriorDenom) {
    fbb_.AddElement<float>(TModelCtr::VT_PRIORDENOM, PriorDenom, 1.0f);
  }
  void add_Shift(float Shift) {
    fbb_.AddElement<float>(TModelCtr::VT_SHIFT, Shift, 0.0f);
  }
  void add_Scale(float Scale) {
    fbb_.AddElement<float>(TModelCtr::VT_SCALE, Scale, 1.0f);
  }
  explicit TModelCtrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TModelCtr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TModelCtr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TModelCtr> CreateTModelCtr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCtrBase> Base = 0,
    int32_t TargetBorderIdx = 0,
    float PriorNum = 0.0f,
    float PriorDenom = 1.0f,
    float Shift = 0.0f,
    float Scale = 1.0f) {
  TModelCtrBuilder builder_(_fbb);
  builder_.add_Scale(Scale);
  builder_.add_Shift(Shift);
  builder_.add_PriorDenom(PriorDenom);
  builder_.add_PriorNum(PriorNum);
  builder_.add_TargetBorderIdx(TargetBorderIdx);
  builder_.add_Base(Base);
  return builder_.Finish();
}

::flatbuffers::Offset<TModelCtr> CreateTModelCtr(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCtrFeatureT : public ::flatbuffers::NativeTable {
  typedef TCtrFeature TableType;
  std::unique_ptr<NCatBoostFbs::TModelCtrT> Ctr{};
  std::vector<float> Borders{};
  TCtrFeatureT() = default;
  TCtrFeatureT(const TCtrFeatureT &o);
  TCtrFeatureT(TCtrFeatureT&&) FLATBUFFERS_NOEXCEPT = default;
  TCtrFeatureT &operator=(TCtrFeatureT o) FLATBUFFERS_NOEXCEPT;
};

struct TCtrFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCtrFeatureT NativeTableType;
  typedef TCtrFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CTR = 4,
    VT_BORDERS = 6
  };
  const NCatBoostFbs::TModelCtr *Ctr() const {
    return GetPointer<const NCatBoostFbs::TModelCtr *>(VT_CTR);
  }
  NCatBoostFbs::TModelCtr *mutable_Ctr() {
    return GetPointer<NCatBoostFbs::TModelCtr *>(VT_CTR);
  }
  const ::flatbuffers::Vector<float> *Borders() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  ::flatbuffers::Vector<float> *mutable_Borders() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CTR) &&
           verifier.VerifyTable(Ctr()) &&
           VerifyOffset(verifier, VT_BORDERS) &&
           verifier.VerifyVector(Borders()) &&
           verifier.EndTable();
  }
  TCtrFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCtrFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCtrFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCtrFeatureBuilder {
  typedef TCtrFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Ctr(::flatbuffers::Offset<NCatBoostFbs::TModelCtr> Ctr) {
    fbb_.AddOffset(TCtrFeature::VT_CTR, Ctr);
  }
  void add_Borders(::flatbuffers::Offset<::flatbuffers::Vector<float>> Borders) {
    fbb_.AddOffset(TCtrFeature::VT_BORDERS, Borders);
  }
  explicit TCtrFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCtrFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCtrFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCtrFeature> CreateTCtrFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCtr> Ctr = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> Borders = 0) {
  TCtrFeatureBuilder builder_(_fbb);
  builder_.add_Borders(Borders);
  builder_.add_Ctr(Ctr);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TCtrFeature> CreateTCtrFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCtr> Ctr = 0,
    const std::vector<float> *Borders = nullptr) {
  auto Borders__ = Borders ? _fbb.CreateVector<float>(*Borders) : 0;
  return NCatBoostFbs::CreateTCtrFeature(
      _fbb,
      Ctr,
      Borders__);
}

::flatbuffers::Offset<TCtrFeature> CreateTCtrFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCtrValueTableT : public ::flatbuffers::NativeTable {
  typedef TCtrValueTable TableType;
  std::unique_ptr<NCatBoostFbs::TModelCtrBaseT> ModelCtrBase{};
  std::vector<uint8_t> IndexHashRaw{};
  std::vector<uint8_t> CTRBlob{};
  int32_t CounterDenominator = 0;
  int32_t TargetClassesCount = 0;
  TCtrValueTableT() = default;
  TCtrValueTableT(const TCtrValueTableT &o);
  TCtrValueTableT(TCtrValueTableT&&) FLATBUFFERS_NOEXCEPT = default;
  TCtrValueTableT &operator=(TCtrValueTableT o) FLATBUFFERS_NOEXCEPT;
};

struct TCtrValueTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCtrValueTableT NativeTableType;
  typedef TCtrValueTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODELCTRBASE = 4,
    VT_INDEXHASHRAW = 6,
    VT_CTRBLOB = 8,
    VT_COUNTERDENOMINATOR = 10,
    VT_TARGETCLASSESCOUNT = 12
  };
  const NCatBoostFbs::TModelCtrBase *ModelCtrBase() const {
    return GetPointer<const NCatBoostFbs::TModelCtrBase *>(VT_MODELCTRBASE);
  }
  NCatBoostFbs::TModelCtrBase *mutable_ModelCtrBase() {
    return GetPointer<NCatBoostFbs::TModelCtrBase *>(VT_MODELCTRBASE);
  }
  const ::flatbuffers::Vector<uint8_t> *IndexHashRaw() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INDEXHASHRAW);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_IndexHashRaw() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_INDEXHASHRAW);
  }
  const ::flatbuffers::Vector<uint8_t> *CTRBlob() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CTRBLOB);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_CTRBlob() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_CTRBLOB);
  }
  int32_t CounterDenominator() const {
    return GetField<int32_t>(VT_COUNTERDENOMINATOR, 0);
  }
  bool mutate_CounterDenominator(int32_t _CounterDenominator = 0) {
    return SetField<int32_t>(VT_COUNTERDENOMINATOR, _CounterDenominator, 0);
  }
  int32_t TargetClassesCount() const {
    return GetField<int32_t>(VT_TARGETCLASSESCOUNT, 0);
  }
  bool mutate_TargetClassesCount(int32_t _TargetClassesCount = 0) {
    return SetField<int32_t>(VT_TARGETCLASSESCOUNT, _TargetClassesCount, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODELCTRBASE) &&
           verifier.VerifyTable(ModelCtrBase()) &&
           VerifyOffset(verifier, VT_INDEXHASHRAW) &&
           verifier.VerifyVector(IndexHashRaw()) &&
           VerifyOffset(verifier, VT_CTRBLOB) &&
           verifier.VerifyVector(CTRBlob()) &&
           VerifyField<int32_t>(verifier, VT_COUNTERDENOMINATOR, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGETCLASSESCOUNT, 4) &&
           verifier.EndTable();
  }
  TCtrValueTableT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCtrValueTableT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCtrValueTable> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrValueTableT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCtrValueTableBuilder {
  typedef TCtrValueTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ModelCtrBase(::flatbuffers::Offset<NCatBoostFbs::TModelCtrBase> ModelCtrBase) {
    fbb_.AddOffset(TCtrValueTable::VT_MODELCTRBASE, ModelCtrBase);
  }
  void add_IndexHashRaw(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> IndexHashRaw) {
    fbb_.AddOffset(TCtrValueTable::VT_INDEXHASHRAW, IndexHashRaw);
  }
  void add_CTRBlob(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> CTRBlob) {
    fbb_.AddOffset(TCtrValueTable::VT_CTRBLOB, CTRBlob);
  }
  void add_CounterDenominator(int32_t CounterDenominator) {
    fbb_.AddElement<int32_t>(TCtrValueTable::VT_COUNTERDENOMINATOR, CounterDenominator, 0);
  }
  void add_TargetClassesCount(int32_t TargetClassesCount) {
    fbb_.AddElement<int32_t>(TCtrValueTable::VT_TARGETCLASSESCOUNT, TargetClassesCount, 0);
  }
  explicit TCtrValueTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCtrValueTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCtrValueTable>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCtrValueTable> CreateTCtrValueTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCtrBase> ModelCtrBase = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> IndexHashRaw = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> CTRBlob = 0,
    int32_t CounterDenominator = 0,
    int32_t TargetClassesCount = 0) {
  TCtrValueTableBuilder builder_(_fbb);
  builder_.add_TargetClassesCount(TargetClassesCount);
  builder_.add_CounterDenominator(CounterDenominator);
  builder_.add_CTRBlob(CTRBlob);
  builder_.add_IndexHashRaw(IndexHashRaw);
  builder_.add_ModelCtrBase(ModelCtrBase);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TCtrValueTable> CreateTCtrValueTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCtrBase> ModelCtrBase = 0,
    const std::vector<uint8_t> *IndexHashRaw = nullptr,
    const std::vector<uint8_t> *CTRBlob = nullptr,
    int32_t CounterDenominator = 0,
    int32_t TargetClassesCount = 0) {
  auto IndexHashRaw__ = IndexHashRaw ? _fbb.CreateVector<uint8_t>(*IndexHashRaw) : 0;
  auto CTRBlob__ = CTRBlob ? _fbb.CreateVector<uint8_t>(*CTRBlob) : 0;
  return NCatBoostFbs::CreateTCtrValueTable(
      _fbb,
      ModelCtrBase,
      IndexHashRaw__,
      CTRBlob__,
      CounterDenominator,
      TargetClassesCount);
}

::flatbuffers::Offset<TCtrValueTable> CreateTCtrValueTable(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrValueTableT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TModelCtrBaseT::TModelCtrBaseT(const TModelCtrBaseT &o)
      : FeatureCombination((o.FeatureCombination) ? new NCatBoostFbs::TFeatureCombinationT(*o.FeatureCombination) : nullptr),
        CtrType(o.CtrType),
        TargetBorderClassifierIdx(o.TargetBorderClassifierIdx) {
}

inline TModelCtrBaseT &TModelCtrBaseT::operator=(TModelCtrBaseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(FeatureCombination, o.FeatureCombination);
  std::swap(CtrType, o.CtrType);
  std::swap(TargetBorderClassifierIdx, o.TargetBorderClassifierIdx);
  return *this;
}

inline TModelCtrBaseT *TModelCtrBase::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TModelCtrBaseT>(new TModelCtrBaseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TModelCtrBase::UnPackTo(TModelCtrBaseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = FeatureCombination(); if (_e) { if(_o->FeatureCombination) { _e->UnPackTo(_o->FeatureCombination.get(), _resolver); } else { _o->FeatureCombination = std::unique_ptr<NCatBoostFbs::TFeatureCombinationT>(_e->UnPack(_resolver)); } } else if (_o->FeatureCombination) { _o->FeatureCombination.reset(); } }
  { auto _e = CtrType(); _o->CtrType = _e; }
  { auto _e = TargetBorderClassifierIdx(); _o->TargetBorderClassifierIdx = _e; }
}

inline ::flatbuffers::Offset<TModelCtrBase> TModelCtrBase::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrBaseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTModelCtrBase(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TModelCtrBase> CreateTModelCtrBase(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrBaseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TModelCtrBaseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _FeatureCombination = _o->FeatureCombination ? CreateTFeatureCombination(_fbb, _o->FeatureCombination.get(), _rehasher) : 0;
  auto _CtrType = _o->CtrType;
  auto _TargetBorderClassifierIdx = _o->TargetBorderClassifierIdx;
  return NCatBoostFbs::CreateTModelCtrBase(
      _fbb,
      _FeatureCombination,
      _CtrType,
      _TargetBorderClassifierIdx);
}

inline TModelCtrT::TModelCtrT(const TModelCtrT &o)
      : Base((o.Base) ? new NCatBoostFbs::TModelCtrBaseT(*o.Base) : nullptr),
        TargetBorderIdx(o.TargetBorderIdx),
        PriorNum(o.PriorNum),
        PriorDenom(o.PriorDenom),
        Shift(o.Shift),
        Scale(o.Scale) {
}

inline TModelCtrT &TModelCtrT::operator=(TModelCtrT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Base, o.Base);
  std::swap(TargetBorderIdx, o.TargetBorderIdx);
  std::swap(PriorNum, o.PriorNum);
  std::swap(PriorDenom, o.PriorDenom);
  std::swap(Shift, o.Shift);
  std::swap(Scale, o.Scale);
  return *this;
}

inline TModelCtrT *TModelCtr::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TModelCtrT>(new TModelCtrT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TModelCtr::UnPackTo(TModelCtrT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Base(); if (_e) { if(_o->Base) { _e->UnPackTo(_o->Base.get(), _resolver); } else { _o->Base = std::unique_ptr<NCatBoostFbs::TModelCtrBaseT>(_e->UnPack(_resolver)); } } else if (_o->Base) { _o->Base.reset(); } }
  { auto _e = TargetBorderIdx(); _o->TargetBorderIdx = _e; }
  { auto _e = PriorNum(); _o->PriorNum = _e; }
  { auto _e = PriorDenom(); _o->PriorDenom = _e; }
  { auto _e = Shift(); _o->Shift = _e; }
  { auto _e = Scale(); _o->Scale = _e; }
}

inline ::flatbuffers::Offset<TModelCtr> TModelCtr::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTModelCtr(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TModelCtr> CreateTModelCtr(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCtrT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TModelCtrT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Base = _o->Base ? CreateTModelCtrBase(_fbb, _o->Base.get(), _rehasher) : 0;
  auto _TargetBorderIdx = _o->TargetBorderIdx;
  auto _PriorNum = _o->PriorNum;
  auto _PriorDenom = _o->PriorDenom;
  auto _Shift = _o->Shift;
  auto _Scale = _o->Scale;
  return NCatBoostFbs::CreateTModelCtr(
      _fbb,
      _Base,
      _TargetBorderIdx,
      _PriorNum,
      _PriorDenom,
      _Shift,
      _Scale);
}

inline TCtrFeatureT::TCtrFeatureT(const TCtrFeatureT &o)
      : Ctr((o.Ctr) ? new NCatBoostFbs::TModelCtrT(*o.Ctr) : nullptr),
        Borders(o.Borders) {
}

inline TCtrFeatureT &TCtrFeatureT::operator=(TCtrFeatureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Ctr, o.Ctr);
  std::swap(Borders, o.Borders);
  return *this;
}

inline TCtrFeatureT *TCtrFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCtrFeatureT>(new TCtrFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCtrFeature::UnPackTo(TCtrFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Ctr(); if (_e) { if(_o->Ctr) { _e->UnPackTo(_o->Ctr.get(), _resolver); } else { _o->Ctr = std::unique_ptr<NCatBoostFbs::TModelCtrT>(_e->UnPack(_resolver)); } } else if (_o->Ctr) { _o->Ctr.reset(); } }
  { auto _e = Borders(); if (_e) { _o->Borders.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Borders[_i] = _e->Get(_i); } } else { _o->Borders.resize(0); } }
}

inline ::flatbuffers::Offset<TCtrFeature> TCtrFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCtrFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCtrFeature> CreateTCtrFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCtrFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Ctr = _o->Ctr ? CreateTModelCtr(_fbb, _o->Ctr.get(), _rehasher) : 0;
  auto _Borders = _o->Borders.size() ? _fbb.CreateVector(_o->Borders) : 0;
  return NCatBoostFbs::CreateTCtrFeature(
      _fbb,
      _Ctr,
      _Borders);
}

inline TCtrValueTableT::TCtrValueTableT(const TCtrValueTableT &o)
      : ModelCtrBase((o.ModelCtrBase) ? new NCatBoostFbs::TModelCtrBaseT(*o.ModelCtrBase) : nullptr),
        IndexHashRaw(o.IndexHashRaw),
        CTRBlob(o.CTRBlob),
        CounterDenominator(o.CounterDenominator),
        TargetClassesCount(o.TargetClassesCount) {
}

inline TCtrValueTableT &TCtrValueTableT::operator=(TCtrValueTableT o) FLATBUFFERS_NOEXCEPT {
  std::swap(ModelCtrBase, o.ModelCtrBase);
  std::swap(IndexHashRaw, o.IndexHashRaw);
  std::swap(CTRBlob, o.CTRBlob);
  std::swap(CounterDenominator, o.CounterDenominator);
  std::swap(TargetClassesCount, o.TargetClassesCount);
  return *this;
}

inline TCtrValueTableT *TCtrValueTable::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCtrValueTableT>(new TCtrValueTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCtrValueTable::UnPackTo(TCtrValueTableT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ModelCtrBase(); if (_e) { if(_o->ModelCtrBase) { _e->UnPackTo(_o->ModelCtrBase.get(), _resolver); } else { _o->ModelCtrBase = std::unique_ptr<NCatBoostFbs::TModelCtrBaseT>(_e->UnPack(_resolver)); } } else if (_o->ModelCtrBase) { _o->ModelCtrBase.reset(); } }
  { auto _e = IndexHashRaw(); if (_e) { _o->IndexHashRaw.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->IndexHashRaw.begin()); } }
  { auto _e = CTRBlob(); if (_e) { _o->CTRBlob.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->CTRBlob.begin()); } }
  { auto _e = CounterDenominator(); _o->CounterDenominator = _e; }
  { auto _e = TargetClassesCount(); _o->TargetClassesCount = _e; }
}

inline ::flatbuffers::Offset<TCtrValueTable> TCtrValueTable::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrValueTableT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCtrValueTable(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCtrValueTable> CreateTCtrValueTable(::flatbuffers::FlatBufferBuilder &_fbb, const TCtrValueTableT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCtrValueTableT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ModelCtrBase = _o->ModelCtrBase ? CreateTModelCtrBase(_fbb, _o->ModelCtrBase.get(), _rehasher) : 0;
  auto _IndexHashRaw = _o->IndexHashRaw.size() ? _fbb.CreateVector(_o->IndexHashRaw) : 0;
  auto _CTRBlob = _o->CTRBlob.size() ? _fbb.CreateVector(_o->CTRBlob) : 0;
  auto _CounterDenominator = _o->CounterDenominator;
  auto _TargetClassesCount = _o->TargetClassesCount;
  return NCatBoostFbs::CreateTCtrValueTable(
      _fbb,
      _ModelCtrBase,
      _IndexHashRaw,
      _CTRBlob,
      _CounterDenominator,
      _TargetClassesCount);
}

inline const NCatBoostFbs::TCtrValueTable *GetTCtrValueTable(const void *buf) {
  return ::flatbuffers::GetRoot<NCatBoostFbs::TCtrValueTable>(buf);
}

inline const NCatBoostFbs::TCtrValueTable *GetSizePrefixedTCtrValueTable(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::TCtrValueTable>(buf);
}

inline TCtrValueTable *GetMutableTCtrValueTable(void *buf) {
  return ::flatbuffers::GetMutableRoot<TCtrValueTable>(buf);
}

inline NCatBoostFbs::TCtrValueTable *GetMutableSizePrefixedTCtrValueTable(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NCatBoostFbs::TCtrValueTable>(buf);
}

inline bool VerifyTCtrValueTableBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::TCtrValueTable>(nullptr);
}

inline bool VerifySizePrefixedTCtrValueTableBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::TCtrValueTable>(nullptr);
}

inline const char *TCtrValueTableExtension() {
  return "bfbs";
}

inline void FinishTCtrValueTableBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TCtrValueTable> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTCtrValueTableBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TCtrValueTable> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NCatBoostFbs::TCtrValueTableT> UnPackTCtrValueTable(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TCtrValueTableT>(GetTCtrValueTable(buf)->UnPack(res));
}

inline std::unique_ptr<NCatBoostFbs::TCtrValueTableT> UnPackSizePrefixedTCtrValueTable(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TCtrValueTableT>(GetSizePrefixedTCtrValueTable(buf)->UnPack(res));
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_H_
