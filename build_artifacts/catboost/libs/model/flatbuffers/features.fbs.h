// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/helpers/flatbuffers/guid.fbs.h"

namespace NCatBoostFbs {

struct TFloatFeature;
struct TFloatFeatureBuilder;
struct TFloatFeatureT;

struct TCatFeature;
struct TCatFeatureBuilder;
struct TCatFeatureT;

struct TTextFeature;
struct TTextFeatureBuilder;
struct TTextFeatureT;

struct TEmbeddingFeature;
struct TEmbeddingFeatureBuilder;
struct TEmbeddingFeatureT;

struct TEstimatedFeature;
struct TEstimatedFeatureBuilder;
struct TEstimatedFeatureT;

struct TOneHotFeature;
struct TOneHotFeatureBuilder;
struct TOneHotFeatureT;

struct TFloatSplit;

struct TOneHotSplit;

struct TFeatureCombination;
struct TFeatureCombinationBuilder;
struct TFeatureCombinationT;

enum ENanValueTreatment : int8_t {
  ENanValueTreatment_AsIs = 0,
  ENanValueTreatment_AsFalse = 1,
  ENanValueTreatment_AsTrue = 2,
  ENanValueTreatment_MIN = ENanValueTreatment_AsIs,
  ENanValueTreatment_MAX = ENanValueTreatment_AsTrue
};

inline const ENanValueTreatment (&EnumValuesENanValueTreatment())[3] {
  static const ENanValueTreatment values[] = {
    ENanValueTreatment_AsIs,
    ENanValueTreatment_AsFalse,
    ENanValueTreatment_AsTrue
  };
  return values;
}

inline const char * const *EnumNamesENanValueTreatment() {
  static const char * const names[4] = {
    "AsIs",
    "AsFalse",
    "AsTrue",
    nullptr
  };
  return names;
}

inline const char *EnumNameENanValueTreatment(ENanValueTreatment e) {
  if (::flatbuffers::IsOutRange(e, ENanValueTreatment_AsIs, ENanValueTreatment_AsTrue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesENanValueTreatment()[index];
}

enum ESourceFeatureType : int8_t {
  ESourceFeatureType_Text = 0,
  ESourceFeatureType_Embedding = 1,
  ESourceFeatureType_MIN = ESourceFeatureType_Text,
  ESourceFeatureType_MAX = ESourceFeatureType_Embedding
};

inline const ESourceFeatureType (&EnumValuesESourceFeatureType())[2] {
  static const ESourceFeatureType values[] = {
    ESourceFeatureType_Text,
    ESourceFeatureType_Embedding
  };
  return values;
}

inline const char * const *EnumNamesESourceFeatureType() {
  static const char * const names[3] = {
    "Text",
    "Embedding",
    nullptr
  };
  return names;
}

inline const char *EnumNameESourceFeatureType(ESourceFeatureType e) {
  if (::flatbuffers::IsOutRange(e, ESourceFeatureType_Text, ESourceFeatureType_Embedding)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesESourceFeatureType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TFloatSplit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Index_;
  float Border_;

 public:
  TFloatSplit()
      : Index_(0),
        Border_(0) {
  }
  TFloatSplit(int32_t _Index, float _Border)
      : Index_(::flatbuffers::EndianScalar(_Index)),
        Border_(::flatbuffers::EndianScalar(_Border)) {
  }
  int32_t Index() const {
    return ::flatbuffers::EndianScalar(Index_);
  }
  void mutate_Index(int32_t _Index) {
    ::flatbuffers::WriteScalar(&Index_, _Index);
  }
  float Border() const {
    return ::flatbuffers::EndianScalar(Border_);
  }
  void mutate_Border(float _Border) {
    ::flatbuffers::WriteScalar(&Border_, _Border);
  }
};
FLATBUFFERS_STRUCT_END(TFloatSplit, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TOneHotSplit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Index_;
  int32_t Value_;

 public:
  TOneHotSplit()
      : Index_(0),
        Value_(0) {
  }
  TOneHotSplit(int32_t _Index, int32_t _Value)
      : Index_(::flatbuffers::EndianScalar(_Index)),
        Value_(::flatbuffers::EndianScalar(_Value)) {
  }
  int32_t Index() const {
    return ::flatbuffers::EndianScalar(Index_);
  }
  void mutate_Index(int32_t _Index) {
    ::flatbuffers::WriteScalar(&Index_, _Index);
  }
  int32_t Value() const {
    return ::flatbuffers::EndianScalar(Value_);
  }
  void mutate_Value(int32_t _Value) {
    ::flatbuffers::WriteScalar(&Value_, _Value);
  }
};
FLATBUFFERS_STRUCT_END(TOneHotSplit, 8);

struct TFloatFeatureT : public ::flatbuffers::NativeTable {
  typedef TFloatFeature TableType;
  bool HasNans = false;
  int32_t Index = -1;
  int32_t FlatIndex = -1;
  std::vector<float> Borders{};
  std::string FeatureId{};
  NCatBoostFbs::ENanValueTreatment NanValueTreatment = NCatBoostFbs::ENanValueTreatment_AsIs;
};

struct TFloatFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TFloatFeatureT NativeTableType;
  typedef TFloatFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASNANS = 4,
    VT_INDEX = 6,
    VT_FLATINDEX = 8,
    VT_BORDERS = 10,
    VT_FEATUREID = 12,
    VT_NANVALUETREATMENT = 14
  };
  bool HasNans() const {
    return GetField<uint8_t>(VT_HASNANS, 0) != 0;
  }
  bool mutate_HasNans(bool _HasNans = 0) {
    return SetField<uint8_t>(VT_HASNANS, static_cast<uint8_t>(_HasNans), 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index = -1) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  int32_t FlatIndex() const {
    return GetField<int32_t>(VT_FLATINDEX, -1);
  }
  bool mutate_FlatIndex(int32_t _FlatIndex = -1) {
    return SetField<int32_t>(VT_FLATINDEX, _FlatIndex, -1);
  }
  const ::flatbuffers::Vector<float> *Borders() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  ::flatbuffers::Vector<float> *mutable_Borders() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  const ::flatbuffers::String *FeatureId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FEATUREID);
  }
  ::flatbuffers::String *mutable_FeatureId() {
    return GetPointer<::flatbuffers::String *>(VT_FEATUREID);
  }
  NCatBoostFbs::ENanValueTreatment NanValueTreatment() const {
    return static_cast<NCatBoostFbs::ENanValueTreatment>(GetField<int8_t>(VT_NANVALUETREATMENT, 0));
  }
  bool mutate_NanValueTreatment(NCatBoostFbs::ENanValueTreatment _NanValueTreatment = static_cast<NCatBoostFbs::ENanValueTreatment>(0)) {
    return SetField<int8_t>(VT_NANVALUETREATMENT, static_cast<int8_t>(_NanValueTreatment), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HASNANS, 1) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           VerifyOffset(verifier, VT_BORDERS) &&
           verifier.VerifyVector(Borders()) &&
           VerifyOffset(verifier, VT_FEATUREID) &&
           verifier.VerifyString(FeatureId()) &&
           VerifyField<int8_t>(verifier, VT_NANVALUETREATMENT, 1) &&
           verifier.EndTable();
  }
  TFloatFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TFloatFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TFloatFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFloatFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TFloatFeatureBuilder {
  typedef TFloatFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_HasNans(bool HasNans) {
    fbb_.AddElement<uint8_t>(TFloatFeature::VT_HASNANS, static_cast<uint8_t>(HasNans), 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TFloatFeature::VT_INDEX, Index, -1);
  }
  void add_FlatIndex(int32_t FlatIndex) {
    fbb_.AddElement<int32_t>(TFloatFeature::VT_FLATINDEX, FlatIndex, -1);
  }
  void add_Borders(::flatbuffers::Offset<::flatbuffers::Vector<float>> Borders) {
    fbb_.AddOffset(TFloatFeature::VT_BORDERS, Borders);
  }
  void add_FeatureId(::flatbuffers::Offset<::flatbuffers::String> FeatureId) {
    fbb_.AddOffset(TFloatFeature::VT_FEATUREID, FeatureId);
  }
  void add_NanValueTreatment(NCatBoostFbs::ENanValueTreatment NanValueTreatment) {
    fbb_.AddElement<int8_t>(TFloatFeature::VT_NANVALUETREATMENT, static_cast<int8_t>(NanValueTreatment), 0);
  }
  explicit TFloatFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TFloatFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TFloatFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TFloatFeature> CreateTFloatFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool HasNans = false,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> Borders = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FeatureId = 0,
    NCatBoostFbs::ENanValueTreatment NanValueTreatment = NCatBoostFbs::ENanValueTreatment_AsIs) {
  TFloatFeatureBuilder builder_(_fbb);
  builder_.add_FeatureId(FeatureId);
  builder_.add_Borders(Borders);
  builder_.add_FlatIndex(FlatIndex);
  builder_.add_Index(Index);
  builder_.add_NanValueTreatment(NanValueTreatment);
  builder_.add_HasNans(HasNans);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TFloatFeature> CreateTFloatFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool HasNans = false,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    const std::vector<float> *Borders = nullptr,
    const char *FeatureId = nullptr,
    NCatBoostFbs::ENanValueTreatment NanValueTreatment = NCatBoostFbs::ENanValueTreatment_AsIs) {
  auto Borders__ = Borders ? _fbb.CreateVector<float>(*Borders) : 0;
  auto FeatureId__ = FeatureId ? _fbb.CreateString(FeatureId) : 0;
  return NCatBoostFbs::CreateTFloatFeature(
      _fbb,
      HasNans,
      Index,
      FlatIndex,
      Borders__,
      FeatureId__,
      NanValueTreatment);
}

::flatbuffers::Offset<TFloatFeature> CreateTFloatFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TFloatFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCatFeatureT : public ::flatbuffers::NativeTable {
  typedef TCatFeature TableType;
  int32_t Index = -1;
  int32_t FlatIndex = -1;
  std::string FeatureId{};
  bool UsedInModel = true;
};

struct TCatFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCatFeatureT NativeTableType;
  typedef TCatFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_USEDINMODEL = 10
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index = -1) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  int32_t FlatIndex() const {
    return GetField<int32_t>(VT_FLATINDEX, -1);
  }
  bool mutate_FlatIndex(int32_t _FlatIndex = -1) {
    return SetField<int32_t>(VT_FLATINDEX, _FlatIndex, -1);
  }
  const ::flatbuffers::String *FeatureId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FEATUREID);
  }
  ::flatbuffers::String *mutable_FeatureId() {
    return GetPointer<::flatbuffers::String *>(VT_FEATUREID);
  }
  bool UsedInModel() const {
    return GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool mutate_UsedInModel(bool _UsedInModel = 1) {
    return SetField<uint8_t>(VT_USEDINMODEL, static_cast<uint8_t>(_UsedInModel), 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           VerifyOffset(verifier, VT_FEATUREID) &&
           verifier.VerifyString(FeatureId()) &&
           VerifyField<uint8_t>(verifier, VT_USEDINMODEL, 1) &&
           verifier.EndTable();
  }
  TCatFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCatFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCatFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCatFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCatFeatureBuilder {
  typedef TCatFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TCatFeature::VT_INDEX, Index, -1);
  }
  void add_FlatIndex(int32_t FlatIndex) {
    fbb_.AddElement<int32_t>(TCatFeature::VT_FLATINDEX, FlatIndex, -1);
  }
  void add_FeatureId(::flatbuffers::Offset<::flatbuffers::String> FeatureId) {
    fbb_.AddOffset(TCatFeature::VT_FEATUREID, FeatureId);
  }
  void add_UsedInModel(bool UsedInModel) {
    fbb_.AddElement<uint8_t>(TCatFeature::VT_USEDINMODEL, static_cast<uint8_t>(UsedInModel), 1);
  }
  explicit TCatFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCatFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCatFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCatFeature> CreateTCatFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    ::flatbuffers::Offset<::flatbuffers::String> FeatureId = 0,
    bool UsedInModel = true) {
  TCatFeatureBuilder builder_(_fbb);
  builder_.add_FeatureId(FeatureId);
  builder_.add_FlatIndex(FlatIndex);
  builder_.add_Index(Index);
  builder_.add_UsedInModel(UsedInModel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TCatFeature> CreateTCatFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    const char *FeatureId = nullptr,
    bool UsedInModel = true) {
  auto FeatureId__ = FeatureId ? _fbb.CreateString(FeatureId) : 0;
  return NCatBoostFbs::CreateTCatFeature(
      _fbb,
      Index,
      FlatIndex,
      FeatureId__,
      UsedInModel);
}

::flatbuffers::Offset<TCatFeature> CreateTCatFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TCatFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TTextFeatureT : public ::flatbuffers::NativeTable {
  typedef TTextFeature TableType;
  int32_t Index = -1;
  int32_t FlatIndex = -1;
  std::string FeatureId{};
  bool UsedInModel = true;
};

struct TTextFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TTextFeatureT NativeTableType;
  typedef TTextFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_USEDINMODEL = 10
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index = -1) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  int32_t FlatIndex() const {
    return GetField<int32_t>(VT_FLATINDEX, -1);
  }
  bool mutate_FlatIndex(int32_t _FlatIndex = -1) {
    return SetField<int32_t>(VT_FLATINDEX, _FlatIndex, -1);
  }
  const ::flatbuffers::String *FeatureId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FEATUREID);
  }
  ::flatbuffers::String *mutable_FeatureId() {
    return GetPointer<::flatbuffers::String *>(VT_FEATUREID);
  }
  bool UsedInModel() const {
    return GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool mutate_UsedInModel(bool _UsedInModel = 1) {
    return SetField<uint8_t>(VT_USEDINMODEL, static_cast<uint8_t>(_UsedInModel), 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           VerifyOffset(verifier, VT_FEATUREID) &&
           verifier.VerifyString(FeatureId()) &&
           VerifyField<uint8_t>(verifier, VT_USEDINMODEL, 1) &&
           verifier.EndTable();
  }
  TTextFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TTextFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TTextFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTextFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TTextFeatureBuilder {
  typedef TTextFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TTextFeature::VT_INDEX, Index, -1);
  }
  void add_FlatIndex(int32_t FlatIndex) {
    fbb_.AddElement<int32_t>(TTextFeature::VT_FLATINDEX, FlatIndex, -1);
  }
  void add_FeatureId(::flatbuffers::Offset<::flatbuffers::String> FeatureId) {
    fbb_.AddOffset(TTextFeature::VT_FEATUREID, FeatureId);
  }
  void add_UsedInModel(bool UsedInModel) {
    fbb_.AddElement<uint8_t>(TTextFeature::VT_USEDINMODEL, static_cast<uint8_t>(UsedInModel), 1);
  }
  explicit TTextFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TTextFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TTextFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TTextFeature> CreateTTextFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    ::flatbuffers::Offset<::flatbuffers::String> FeatureId = 0,
    bool UsedInModel = true) {
  TTextFeatureBuilder builder_(_fbb);
  builder_.add_FeatureId(FeatureId);
  builder_.add_FlatIndex(FlatIndex);
  builder_.add_Index(Index);
  builder_.add_UsedInModel(UsedInModel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TTextFeature> CreateTTextFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    const char *FeatureId = nullptr,
    bool UsedInModel = true) {
  auto FeatureId__ = FeatureId ? _fbb.CreateString(FeatureId) : 0;
  return NCatBoostFbs::CreateTTextFeature(
      _fbb,
      Index,
      FlatIndex,
      FeatureId__,
      UsedInModel);
}

::flatbuffers::Offset<TTextFeature> CreateTTextFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TTextFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TEmbeddingFeatureT : public ::flatbuffers::NativeTable {
  typedef TEmbeddingFeature TableType;
  int32_t Index = -1;
  int32_t FlatIndex = -1;
  std::string FeatureId{};
  int32_t Dimension = 0;
  bool UsedInModel = true;
};

struct TEmbeddingFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TEmbeddingFeatureT NativeTableType;
  typedef TEmbeddingFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_DIMENSION = 10,
    VT_USEDINMODEL = 12
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index = -1) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  int32_t FlatIndex() const {
    return GetField<int32_t>(VT_FLATINDEX, -1);
  }
  bool mutate_FlatIndex(int32_t _FlatIndex = -1) {
    return SetField<int32_t>(VT_FLATINDEX, _FlatIndex, -1);
  }
  const ::flatbuffers::String *FeatureId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FEATUREID);
  }
  ::flatbuffers::String *mutable_FeatureId() {
    return GetPointer<::flatbuffers::String *>(VT_FEATUREID);
  }
  int32_t Dimension() const {
    return GetField<int32_t>(VT_DIMENSION, 0);
  }
  bool mutate_Dimension(int32_t _Dimension = 0) {
    return SetField<int32_t>(VT_DIMENSION, _Dimension, 0);
  }
  bool UsedInModel() const {
    return GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool mutate_UsedInModel(bool _UsedInModel = 1) {
    return SetField<uint8_t>(VT_USEDINMODEL, static_cast<uint8_t>(_UsedInModel), 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_FLATINDEX, 4) &&
           VerifyOffset(verifier, VT_FEATUREID) &&
           verifier.VerifyString(FeatureId()) &&
           VerifyField<int32_t>(verifier, VT_DIMENSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_USEDINMODEL, 1) &&
           verifier.EndTable();
  }
  TEmbeddingFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TEmbeddingFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TEmbeddingFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TEmbeddingFeatureBuilder {
  typedef TEmbeddingFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TEmbeddingFeature::VT_INDEX, Index, -1);
  }
  void add_FlatIndex(int32_t FlatIndex) {
    fbb_.AddElement<int32_t>(TEmbeddingFeature::VT_FLATINDEX, FlatIndex, -1);
  }
  void add_FeatureId(::flatbuffers::Offset<::flatbuffers::String> FeatureId) {
    fbb_.AddOffset(TEmbeddingFeature::VT_FEATUREID, FeatureId);
  }
  void add_Dimension(int32_t Dimension) {
    fbb_.AddElement<int32_t>(TEmbeddingFeature::VT_DIMENSION, Dimension, 0);
  }
  void add_UsedInModel(bool UsedInModel) {
    fbb_.AddElement<uint8_t>(TEmbeddingFeature::VT_USEDINMODEL, static_cast<uint8_t>(UsedInModel), 1);
  }
  explicit TEmbeddingFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TEmbeddingFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TEmbeddingFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TEmbeddingFeature> CreateTEmbeddingFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    ::flatbuffers::Offset<::flatbuffers::String> FeatureId = 0,
    int32_t Dimension = 0,
    bool UsedInModel = true) {
  TEmbeddingFeatureBuilder builder_(_fbb);
  builder_.add_Dimension(Dimension);
  builder_.add_FeatureId(FeatureId);
  builder_.add_FlatIndex(FlatIndex);
  builder_.add_Index(Index);
  builder_.add_UsedInModel(UsedInModel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TEmbeddingFeature> CreateTEmbeddingFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    const char *FeatureId = nullptr,
    int32_t Dimension = 0,
    bool UsedInModel = true) {
  auto FeatureId__ = FeatureId ? _fbb.CreateString(FeatureId) : 0;
  return NCatBoostFbs::CreateTEmbeddingFeature(
      _fbb,
      Index,
      FlatIndex,
      FeatureId__,
      Dimension,
      UsedInModel);
}

::flatbuffers::Offset<TEmbeddingFeature> CreateTEmbeddingFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TEstimatedFeatureT : public ::flatbuffers::NativeTable {
  typedef TEstimatedFeature TableType;
  int32_t SourceFeatureIndex = -1;
  std::unique_ptr<NCatBoostFbs::TGuid> CalcerId{};
  int32_t LocalIndex = -1;
  std::vector<float> Borders{};
  NCatBoostFbs::ESourceFeatureType SourceFeatureType = NCatBoostFbs::ESourceFeatureType_Text;
  TEstimatedFeatureT() = default;
  TEstimatedFeatureT(const TEstimatedFeatureT &o);
  TEstimatedFeatureT(TEstimatedFeatureT&&) FLATBUFFERS_NOEXCEPT = default;
  TEstimatedFeatureT &operator=(TEstimatedFeatureT o) FLATBUFFERS_NOEXCEPT;
};

struct TEstimatedFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TEstimatedFeatureT NativeTableType;
  typedef TEstimatedFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCEFEATUREINDEX = 4,
    VT_CALCERID = 6,
    VT_LOCALINDEX = 8,
    VT_BORDERS = 10,
    VT_SOURCEFEATURETYPE = 12
  };
  int32_t SourceFeatureIndex() const {
    return GetField<int32_t>(VT_SOURCEFEATUREINDEX, -1);
  }
  bool mutate_SourceFeatureIndex(int32_t _SourceFeatureIndex = -1) {
    return SetField<int32_t>(VT_SOURCEFEATUREINDEX, _SourceFeatureIndex, -1);
  }
  const NCatBoostFbs::TGuid *CalcerId() const {
    return GetStruct<const NCatBoostFbs::TGuid *>(VT_CALCERID);
  }
  NCatBoostFbs::TGuid *mutable_CalcerId() {
    return GetStruct<NCatBoostFbs::TGuid *>(VT_CALCERID);
  }
  int32_t LocalIndex() const {
    return GetField<int32_t>(VT_LOCALINDEX, -1);
  }
  bool mutate_LocalIndex(int32_t _LocalIndex = -1) {
    return SetField<int32_t>(VT_LOCALINDEX, _LocalIndex, -1);
  }
  const ::flatbuffers::Vector<float> *Borders() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  ::flatbuffers::Vector<float> *mutable_Borders() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  NCatBoostFbs::ESourceFeatureType SourceFeatureType() const {
    return static_cast<NCatBoostFbs::ESourceFeatureType>(GetField<int8_t>(VT_SOURCEFEATURETYPE, 0));
  }
  bool mutate_SourceFeatureType(NCatBoostFbs::ESourceFeatureType _SourceFeatureType = static_cast<NCatBoostFbs::ESourceFeatureType>(0)) {
    return SetField<int8_t>(VT_SOURCEFEATURETYPE, static_cast<int8_t>(_SourceFeatureType), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SOURCEFEATUREINDEX, 4) &&
           VerifyField<NCatBoostFbs::TGuid>(verifier, VT_CALCERID, 4) &&
           VerifyField<int32_t>(verifier, VT_LOCALINDEX, 4) &&
           VerifyOffset(verifier, VT_BORDERS) &&
           verifier.VerifyVector(Borders()) &&
           VerifyField<int8_t>(verifier, VT_SOURCEFEATURETYPE, 1) &&
           verifier.EndTable();
  }
  TEstimatedFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TEstimatedFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TEstimatedFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TEstimatedFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TEstimatedFeatureBuilder {
  typedef TEstimatedFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SourceFeatureIndex(int32_t SourceFeatureIndex) {
    fbb_.AddElement<int32_t>(TEstimatedFeature::VT_SOURCEFEATUREINDEX, SourceFeatureIndex, -1);
  }
  void add_CalcerId(const NCatBoostFbs::TGuid *CalcerId) {
    fbb_.AddStruct(TEstimatedFeature::VT_CALCERID, CalcerId);
  }
  void add_LocalIndex(int32_t LocalIndex) {
    fbb_.AddElement<int32_t>(TEstimatedFeature::VT_LOCALINDEX, LocalIndex, -1);
  }
  void add_Borders(::flatbuffers::Offset<::flatbuffers::Vector<float>> Borders) {
    fbb_.AddOffset(TEstimatedFeature::VT_BORDERS, Borders);
  }
  void add_SourceFeatureType(NCatBoostFbs::ESourceFeatureType SourceFeatureType) {
    fbb_.AddElement<int8_t>(TEstimatedFeature::VT_SOURCEFEATURETYPE, static_cast<int8_t>(SourceFeatureType), 0);
  }
  explicit TEstimatedFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TEstimatedFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TEstimatedFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TEstimatedFeature> CreateTEstimatedFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t SourceFeatureIndex = -1,
    const NCatBoostFbs::TGuid *CalcerId = nullptr,
    int32_t LocalIndex = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> Borders = 0,
    NCatBoostFbs::ESourceFeatureType SourceFeatureType = NCatBoostFbs::ESourceFeatureType_Text) {
  TEstimatedFeatureBuilder builder_(_fbb);
  builder_.add_Borders(Borders);
  builder_.add_LocalIndex(LocalIndex);
  builder_.add_CalcerId(CalcerId);
  builder_.add_SourceFeatureIndex(SourceFeatureIndex);
  builder_.add_SourceFeatureType(SourceFeatureType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TEstimatedFeature> CreateTEstimatedFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t SourceFeatureIndex = -1,
    const NCatBoostFbs::TGuid *CalcerId = nullptr,
    int32_t LocalIndex = -1,
    const std::vector<float> *Borders = nullptr,
    NCatBoostFbs::ESourceFeatureType SourceFeatureType = NCatBoostFbs::ESourceFeatureType_Text) {
  auto Borders__ = Borders ? _fbb.CreateVector<float>(*Borders) : 0;
  return NCatBoostFbs::CreateTEstimatedFeature(
      _fbb,
      SourceFeatureIndex,
      CalcerId,
      LocalIndex,
      Borders__,
      SourceFeatureType);
}

::flatbuffers::Offset<TEstimatedFeature> CreateTEstimatedFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TEstimatedFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOneHotFeatureT : public ::flatbuffers::NativeTable {
  typedef TOneHotFeature TableType;
  int32_t Index = -1;
  std::vector<int32_t> Values{};
  std::vector<std::string> StringValues{};
};

struct TOneHotFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TOneHotFeatureT NativeTableType;
  typedef TOneHotFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_VALUES = 6,
    VT_STRINGVALUES = 8
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index = -1) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  const ::flatbuffers::Vector<int32_t> *Values() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  ::flatbuffers::Vector<int32_t> *mutable_Values() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *StringValues() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGVALUES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_StringValues() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGVALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(Values()) &&
           VerifyOffset(verifier, VT_STRINGVALUES) &&
           verifier.VerifyVector(StringValues()) &&
           verifier.VerifyVectorOfStrings(StringValues()) &&
           verifier.EndTable();
  }
  TOneHotFeatureT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOneHotFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TOneHotFeature> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TOneHotFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOneHotFeatureBuilder {
  typedef TOneHotFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TOneHotFeature::VT_INDEX, Index, -1);
  }
  void add_Values(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> Values) {
    fbb_.AddOffset(TOneHotFeature::VT_VALUES, Values);
  }
  void add_StringValues(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> StringValues) {
    fbb_.AddOffset(TOneHotFeature::VT_STRINGVALUES, StringValues);
  }
  explicit TOneHotFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TOneHotFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TOneHotFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TOneHotFeature> CreateTOneHotFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> Values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> StringValues = 0) {
  TOneHotFeatureBuilder builder_(_fbb);
  builder_.add_StringValues(StringValues);
  builder_.add_Values(Values);
  builder_.add_Index(Index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TOneHotFeature> CreateTOneHotFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    const std::vector<int32_t> *Values = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *StringValues = nullptr) {
  auto Values__ = Values ? _fbb.CreateVector<int32_t>(*Values) : 0;
  auto StringValues__ = StringValues ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*StringValues) : 0;
  return NCatBoostFbs::CreateTOneHotFeature(
      _fbb,
      Index,
      Values__,
      StringValues__);
}

::flatbuffers::Offset<TOneHotFeature> CreateTOneHotFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TOneHotFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFeatureCombinationT : public ::flatbuffers::NativeTable {
  typedef TFeatureCombination TableType;
  std::vector<int32_t> CatFeatures{};
  std::vector<NCatBoostFbs::TFloatSplit> FloatSplits{};
  std::vector<NCatBoostFbs::TOneHotSplit> OneHotSplits{};
};

struct TFeatureCombination FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TFeatureCombinationT NativeTableType;
  typedef TFeatureCombinationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATFEATURES = 4,
    VT_FLOATSPLITS = 6,
    VT_ONEHOTSPLITS = 8
  };
  const ::flatbuffers::Vector<int32_t> *CatFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CATFEATURES);
  }
  ::flatbuffers::Vector<int32_t> *mutable_CatFeatures() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_CATFEATURES);
  }
  const ::flatbuffers::Vector<const NCatBoostFbs::TFloatSplit *> *FloatSplits() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TFloatSplit *> *>(VT_FLOATSPLITS);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TFloatSplit *> *mutable_FloatSplits() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TFloatSplit *> *>(VT_FLOATSPLITS);
  }
  const ::flatbuffers::Vector<const NCatBoostFbs::TOneHotSplit *> *OneHotSplits() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TOneHotSplit *> *>(VT_ONEHOTSPLITS);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TOneHotSplit *> *mutable_OneHotSplits() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TOneHotSplit *> *>(VT_ONEHOTSPLITS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CATFEATURES) &&
           verifier.VerifyVector(CatFeatures()) &&
           VerifyOffset(verifier, VT_FLOATSPLITS) &&
           verifier.VerifyVector(FloatSplits()) &&
           VerifyOffset(verifier, VT_ONEHOTSPLITS) &&
           verifier.VerifyVector(OneHotSplits()) &&
           verifier.EndTable();
  }
  TFeatureCombinationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TFeatureCombinationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TFeatureCombination> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCombinationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TFeatureCombinationBuilder {
  typedef TFeatureCombination Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CatFeatures(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> CatFeatures) {
    fbb_.AddOffset(TFeatureCombination::VT_CATFEATURES, CatFeatures);
  }
  void add_FloatSplits(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TFloatSplit *>> FloatSplits) {
    fbb_.AddOffset(TFeatureCombination::VT_FLOATSPLITS, FloatSplits);
  }
  void add_OneHotSplits(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TOneHotSplit *>> OneHotSplits) {
    fbb_.AddOffset(TFeatureCombination::VT_ONEHOTSPLITS, OneHotSplits);
  }
  explicit TFeatureCombinationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TFeatureCombination> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TFeatureCombination>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TFeatureCombination> CreateTFeatureCombination(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> CatFeatures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TFloatSplit *>> FloatSplits = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TOneHotSplit *>> OneHotSplits = 0) {
  TFeatureCombinationBuilder builder_(_fbb);
  builder_.add_OneHotSplits(OneHotSplits);
  builder_.add_FloatSplits(FloatSplits);
  builder_.add_CatFeatures(CatFeatures);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TFeatureCombination> CreateTFeatureCombinationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *CatFeatures = nullptr,
    const std::vector<NCatBoostFbs::TFloatSplit> *FloatSplits = nullptr,
    const std::vector<NCatBoostFbs::TOneHotSplit> *OneHotSplits = nullptr) {
  auto CatFeatures__ = CatFeatures ? _fbb.CreateVector<int32_t>(*CatFeatures) : 0;
  auto FloatSplits__ = FloatSplits ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TFloatSplit>(*FloatSplits) : 0;
  auto OneHotSplits__ = OneHotSplits ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TOneHotSplit>(*OneHotSplits) : 0;
  return NCatBoostFbs::CreateTFeatureCombination(
      _fbb,
      CatFeatures__,
      FloatSplits__,
      OneHotSplits__);
}

::flatbuffers::Offset<TFeatureCombination> CreateTFeatureCombination(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCombinationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TFloatFeatureT *TFloatFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TFloatFeatureT>(new TFloatFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TFloatFeature::UnPackTo(TFloatFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = HasNans(); _o->HasNans = _e; }
  { auto _e = Index(); _o->Index = _e; }
  { auto _e = FlatIndex(); _o->FlatIndex = _e; }
  { auto _e = Borders(); if (_e) { _o->Borders.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Borders[_i] = _e->Get(_i); } } else { _o->Borders.resize(0); } }
  { auto _e = FeatureId(); if (_e) _o->FeatureId = _e->str(); }
  { auto _e = NanValueTreatment(); _o->NanValueTreatment = _e; }
}

inline ::flatbuffers::Offset<TFloatFeature> TFloatFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFloatFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTFloatFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TFloatFeature> CreateTFloatFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TFloatFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TFloatFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _HasNans = _o->HasNans;
  auto _Index = _o->Index;
  auto _FlatIndex = _o->FlatIndex;
  auto _Borders = _o->Borders.size() ? _fbb.CreateVector(_o->Borders) : 0;
  auto _FeatureId = _o->FeatureId.empty() ? 0 : _fbb.CreateString(_o->FeatureId);
  auto _NanValueTreatment = _o->NanValueTreatment;
  return NCatBoostFbs::CreateTFloatFeature(
      _fbb,
      _HasNans,
      _Index,
      _FlatIndex,
      _Borders,
      _FeatureId,
      _NanValueTreatment);
}

inline TCatFeatureT *TCatFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCatFeatureT>(new TCatFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCatFeature::UnPackTo(TCatFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Index(); _o->Index = _e; }
  { auto _e = FlatIndex(); _o->FlatIndex = _e; }
  { auto _e = FeatureId(); if (_e) _o->FeatureId = _e->str(); }
  { auto _e = UsedInModel(); _o->UsedInModel = _e; }
}

inline ::flatbuffers::Offset<TCatFeature> TCatFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCatFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCatFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCatFeature> CreateTCatFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TCatFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCatFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Index = _o->Index;
  auto _FlatIndex = _o->FlatIndex;
  auto _FeatureId = _o->FeatureId.empty() ? 0 : _fbb.CreateString(_o->FeatureId);
  auto _UsedInModel = _o->UsedInModel;
  return NCatBoostFbs::CreateTCatFeature(
      _fbb,
      _Index,
      _FlatIndex,
      _FeatureId,
      _UsedInModel);
}

inline TTextFeatureT *TTextFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TTextFeatureT>(new TTextFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TTextFeature::UnPackTo(TTextFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Index(); _o->Index = _e; }
  { auto _e = FlatIndex(); _o->FlatIndex = _e; }
  { auto _e = FeatureId(); if (_e) _o->FeatureId = _e->str(); }
  { auto _e = UsedInModel(); _o->UsedInModel = _e; }
}

inline ::flatbuffers::Offset<TTextFeature> TTextFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TTextFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTTextFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TTextFeature> CreateTTextFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TTextFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TTextFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Index = _o->Index;
  auto _FlatIndex = _o->FlatIndex;
  auto _FeatureId = _o->FeatureId.empty() ? 0 : _fbb.CreateString(_o->FeatureId);
  auto _UsedInModel = _o->UsedInModel;
  return NCatBoostFbs::CreateTTextFeature(
      _fbb,
      _Index,
      _FlatIndex,
      _FeatureId,
      _UsedInModel);
}

inline TEmbeddingFeatureT *TEmbeddingFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TEmbeddingFeatureT>(new TEmbeddingFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TEmbeddingFeature::UnPackTo(TEmbeddingFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Index(); _o->Index = _e; }
  { auto _e = FlatIndex(); _o->FlatIndex = _e; }
  { auto _e = FeatureId(); if (_e) _o->FeatureId = _e->str(); }
  { auto _e = Dimension(); _o->Dimension = _e; }
  { auto _e = UsedInModel(); _o->UsedInModel = _e; }
}

inline ::flatbuffers::Offset<TEmbeddingFeature> TEmbeddingFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTEmbeddingFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TEmbeddingFeature> CreateTEmbeddingFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TEmbeddingFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Index = _o->Index;
  auto _FlatIndex = _o->FlatIndex;
  auto _FeatureId = _o->FeatureId.empty() ? 0 : _fbb.CreateString(_o->FeatureId);
  auto _Dimension = _o->Dimension;
  auto _UsedInModel = _o->UsedInModel;
  return NCatBoostFbs::CreateTEmbeddingFeature(
      _fbb,
      _Index,
      _FlatIndex,
      _FeatureId,
      _Dimension,
      _UsedInModel);
}

inline TEstimatedFeatureT::TEstimatedFeatureT(const TEstimatedFeatureT &o)
      : SourceFeatureIndex(o.SourceFeatureIndex),
        CalcerId((o.CalcerId) ? new NCatBoostFbs::TGuid(*o.CalcerId) : nullptr),
        LocalIndex(o.LocalIndex),
        Borders(o.Borders),
        SourceFeatureType(o.SourceFeatureType) {
}

inline TEstimatedFeatureT &TEstimatedFeatureT::operator=(TEstimatedFeatureT o) FLATBUFFERS_NOEXCEPT {
  std::swap(SourceFeatureIndex, o.SourceFeatureIndex);
  std::swap(CalcerId, o.CalcerId);
  std::swap(LocalIndex, o.LocalIndex);
  std::swap(Borders, o.Borders);
  std::swap(SourceFeatureType, o.SourceFeatureType);
  return *this;
}

inline TEstimatedFeatureT *TEstimatedFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TEstimatedFeatureT>(new TEstimatedFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TEstimatedFeature::UnPackTo(TEstimatedFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = SourceFeatureIndex(); _o->SourceFeatureIndex = _e; }
  { auto _e = CalcerId(); if (_e) _o->CalcerId = std::unique_ptr<NCatBoostFbs::TGuid>(new NCatBoostFbs::TGuid(*_e)); }
  { auto _e = LocalIndex(); _o->LocalIndex = _e; }
  { auto _e = Borders(); if (_e) { _o->Borders.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Borders[_i] = _e->Get(_i); } } else { _o->Borders.resize(0); } }
  { auto _e = SourceFeatureType(); _o->SourceFeatureType = _e; }
}

inline ::flatbuffers::Offset<TEstimatedFeature> TEstimatedFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TEstimatedFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTEstimatedFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TEstimatedFeature> CreateTEstimatedFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TEstimatedFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TEstimatedFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _SourceFeatureIndex = _o->SourceFeatureIndex;
  auto _CalcerId = _o->CalcerId ? _o->CalcerId.get() : nullptr;
  auto _LocalIndex = _o->LocalIndex;
  auto _Borders = _o->Borders.size() ? _fbb.CreateVector(_o->Borders) : 0;
  auto _SourceFeatureType = _o->SourceFeatureType;
  return NCatBoostFbs::CreateTEstimatedFeature(
      _fbb,
      _SourceFeatureIndex,
      _CalcerId,
      _LocalIndex,
      _Borders,
      _SourceFeatureType);
}

inline TOneHotFeatureT *TOneHotFeature::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TOneHotFeatureT>(new TOneHotFeatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TOneHotFeature::UnPackTo(TOneHotFeatureT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Index(); _o->Index = _e; }
  { auto _e = Values(); if (_e) { _o->Values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Values[_i] = _e->Get(_i); } } else { _o->Values.resize(0); } }
  { auto _e = StringValues(); if (_e) { _o->StringValues.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->StringValues[_i] = _e->Get(_i)->str(); } } else { _o->StringValues.resize(0); } }
}

inline ::flatbuffers::Offset<TOneHotFeature> TOneHotFeature::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TOneHotFeatureT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOneHotFeature(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TOneHotFeature> CreateTOneHotFeature(::flatbuffers::FlatBufferBuilder &_fbb, const TOneHotFeatureT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TOneHotFeatureT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Index = _o->Index;
  auto _Values = _o->Values.size() ? _fbb.CreateVector(_o->Values) : 0;
  auto _StringValues = _o->StringValues.size() ? _fbb.CreateVectorOfStrings(_o->StringValues) : 0;
  return NCatBoostFbs::CreateTOneHotFeature(
      _fbb,
      _Index,
      _Values,
      _StringValues);
}

inline TFeatureCombinationT *TFeatureCombination::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TFeatureCombinationT>(new TFeatureCombinationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TFeatureCombination::UnPackTo(TFeatureCombinationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = CatFeatures(); if (_e) { _o->CatFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->CatFeatures[_i] = _e->Get(_i); } } else { _o->CatFeatures.resize(0); } }
  { auto _e = FloatSplits(); if (_e) { _o->FloatSplits.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->FloatSplits[_i] = *_e->Get(_i); } } else { _o->FloatSplits.resize(0); } }
  { auto _e = OneHotSplits(); if (_e) { _o->OneHotSplits.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->OneHotSplits[_i] = *_e->Get(_i); } } else { _o->OneHotSplits.resize(0); } }
}

inline ::flatbuffers::Offset<TFeatureCombination> TFeatureCombination::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCombinationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTFeatureCombination(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TFeatureCombination> CreateTFeatureCombination(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCombinationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TFeatureCombinationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _CatFeatures = _o->CatFeatures.size() ? _fbb.CreateVector(_o->CatFeatures) : 0;
  auto _FloatSplits = _o->FloatSplits.size() ? _fbb.CreateVectorOfStructs(_o->FloatSplits) : 0;
  auto _OneHotSplits = _o->OneHotSplits.size() ? _fbb.CreateVectorOfStructs(_o->OneHotSplits) : 0;
  return NCatBoostFbs::CreateTFeatureCombination(
      _fbb,
      _CatFeatures,
      _FloatSplits,
      _OneHotSplits);
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_H_
