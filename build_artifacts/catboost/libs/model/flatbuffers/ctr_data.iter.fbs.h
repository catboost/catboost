// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_ITER_H_
#define FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_ITER_H_

#include "ctr_data.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

#include "catboost/libs/model/flatbuffers/features.iter.fbs.h"
#include "catboost/libs/helpers/flatbuffers/guid.iter.fbs.h"

namespace NCatBoostFbs {
namespace iter {

template <typename Iter>
struct TModelCtrBase;

template <typename Iter>
struct TModelCtr;

template <typename Iter>
struct TCtrFeature;

template <typename Iter>
struct TCtrValueTable;

template <typename Iter>
struct TModelCtrBase FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_FEATURECOMBINATION = 4,
    VT_CTRTYPE = 6,
    VT_TARGETBORDERCLASSIFIERIDX = 8
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<TFeatureCombination<Iter>> FeatureCombination() const {
    return this->template GetPointer<TFeatureCombination<Iter>>(VT_FEATURECOMBINATION);
  }
  ECtrType CtrType() const {
    return static_cast<ECtrType>(this->template GetField<int8_t>(VT_CTRTYPE, 0));
  }
  int32_t TargetBorderClassifierIdx() const {
    return this->template GetField<int32_t>(VT_TARGETBORDERCLASSIFIERIDX, 0);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATURECOMBINATION) &&
           verifier.VerifyTable(FeatureCombination()) &&
           this->template VerifyField<int8_t>(verifier, VT_CTRTYPE, 1) &&
           this->template VerifyField<int32_t>(verifier, VT_TARGETBORDERCLASSIFIERIDX, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TModelCtr FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_BASE = 4,
    VT_TARGETBORDERIDX = 6,
    VT_PRIORNUM = 8,
    VT_PRIORDENOM = 10,
    VT_SHIFT = 12,
    VT_SCALE = 14
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<TModelCtrBase<Iter>> Base() const {
    return this->template GetPointer<TModelCtrBase<Iter>>(VT_BASE);
  }
  int32_t TargetBorderIdx() const {
    return this->template GetField<int32_t>(VT_TARGETBORDERIDX, 0);
  }
  float PriorNum() const {
    return this->template GetField<float>(VT_PRIORNUM, 0.0f);
  }
  float PriorDenom() const {
    return this->template GetField<float>(VT_PRIORDENOM, 1.0f);
  }
  float Shift() const {
    return this->template GetField<float>(VT_SHIFT, 0.0f);
  }
  float Scale() const {
    return this->template GetField<float>(VT_SCALE, 1.0f);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_BASE) &&
           verifier.VerifyTable(Base()) &&
           this->template VerifyField<int32_t>(verifier, VT_TARGETBORDERIDX, 4) &&
           this->template VerifyField<float>(verifier, VT_PRIORNUM, 4) &&
           this->template VerifyField<float>(verifier, VT_PRIORDENOM, 4) &&
           this->template VerifyField<float>(verifier, VT_SHIFT, 4) &&
           this->template VerifyField<float>(verifier, VT_SCALE, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCtrFeature FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_CTR = 4,
    VT_BORDERS = 6
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<TModelCtr<Iter>> Ctr() const {
    return this->template GetPointer<TModelCtr<Iter>>(VT_CTR);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<float, Iter>> Borders() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<float, Iter>>(VT_BORDERS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CTR) &&
           verifier.VerifyTable(Ctr()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_BORDERS) &&
           verifier.Verify(Borders()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCtrValueTable FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_MODELCTRBASE = 4,
    VT_INDEXHASHRAW = 6,
    VT_CTRBLOB = 8,
    VT_COUNTERDENOMINATOR = 10,
    VT_TARGETCLASSESCOUNT = 12
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<TModelCtrBase<Iter>> ModelCtrBase() const {
    return this->template GetPointer<TModelCtrBase<Iter>>(VT_MODELCTRBASE);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint8_t, Iter>> IndexHashRaw() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint8_t, Iter>>(VT_INDEXHASHRAW);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint8_t, Iter>> CTRBlob() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint8_t, Iter>>(VT_CTRBLOB);
  }
  int32_t CounterDenominator() const {
    return this->template GetField<int32_t>(VT_COUNTERDENOMINATOR, 0);
  }
  int32_t TargetClassesCount() const {
    return this->template GetField<int32_t>(VT_TARGETCLASSESCOUNT, 0);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_MODELCTRBASE) &&
           verifier.VerifyTable(ModelCtrBase()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_INDEXHASHRAW) &&
           verifier.Verify(IndexHashRaw()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CTRBLOB) &&
           verifier.Verify(CTRBlob()) &&
           this->template VerifyField<int32_t>(verifier, VT_COUNTERDENOMINATOR, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_TARGETCLASSESCOUNT, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
inline std::optional<NCatBoostFbs::iter::TCtrValueTable<Iter>> GetTCtrValueTable(const Iter& buf) {
  return yandex::maps::flatbuffers_iter::GetRoot<NCatBoostFbs::iter::TCtrValueTable<Iter>, Iter>(buf);
}

inline const NCatBoostFbs::TCtrValueTable *GetTCtrValueTable(const char *buf) {
  return NCatBoostFbs::GetTCtrValueTable(buf);
}

template <typename Iter>
inline bool VerifyTCtrValueTableBuffer(
    yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) {
  return verifier.template VerifyBuffer<NCatBoostFbs::iter::TCtrValueTable<Iter>>(nullptr);
}

inline const char *TCtrValueTableExtension() {
  return "bfbs";
}

}  // namespace iter
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_ITER_H_
