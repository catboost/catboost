// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_MODEL_NCATBOOSTFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/model/flatbuffers/ctr_data.fbs.h"

namespace NCatBoostFbs {

struct TKeyValue;
struct TKeyValueBuilder;
struct TKeyValueT;

struct TNonSymmetricTreeStepNode;

struct TRepackedBin;

struct TModelTrees;
struct TModelTreesBuilder;
struct TModelTreesT;

struct TModelCore;
struct TModelCoreBuilder;
struct TModelCoreT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TNonSymmetricTreeStepNode FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t LeftSubtreeDiff_;
  uint16_t RightSubtreeDiff_;

 public:
  TNonSymmetricTreeStepNode()
      : LeftSubtreeDiff_(0),
        RightSubtreeDiff_(0) {
  }
  TNonSymmetricTreeStepNode(uint16_t _LeftSubtreeDiff, uint16_t _RightSubtreeDiff)
      : LeftSubtreeDiff_(::flatbuffers::EndianScalar(_LeftSubtreeDiff)),
        RightSubtreeDiff_(::flatbuffers::EndianScalar(_RightSubtreeDiff)) {
  }
  uint16_t LeftSubtreeDiff() const {
    return ::flatbuffers::EndianScalar(LeftSubtreeDiff_);
  }
  void mutate_LeftSubtreeDiff(uint16_t _LeftSubtreeDiff) {
    ::flatbuffers::WriteScalar(&LeftSubtreeDiff_, _LeftSubtreeDiff);
  }
  uint16_t RightSubtreeDiff() const {
    return ::flatbuffers::EndianScalar(RightSubtreeDiff_);
  }
  void mutate_RightSubtreeDiff(uint16_t _RightSubtreeDiff) {
    ::flatbuffers::WriteScalar(&RightSubtreeDiff_, _RightSubtreeDiff);
  }
};
FLATBUFFERS_STRUCT_END(TNonSymmetricTreeStepNode, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TRepackedBin FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t FeatureIndex_;
  uint8_t XorMask_;
  uint8_t SplitIdx_;

 public:
  TRepackedBin()
      : FeatureIndex_(0),
        XorMask_(0),
        SplitIdx_(0) {
  }
  TRepackedBin(uint16_t _FeatureIndex, uint8_t _XorMask, uint8_t _SplitIdx)
      : FeatureIndex_(::flatbuffers::EndianScalar(_FeatureIndex)),
        XorMask_(::flatbuffers::EndianScalar(_XorMask)),
        SplitIdx_(::flatbuffers::EndianScalar(_SplitIdx)) {
  }
  uint16_t FeatureIndex() const {
    return ::flatbuffers::EndianScalar(FeatureIndex_);
  }
  void mutate_FeatureIndex(uint16_t _FeatureIndex) {
    ::flatbuffers::WriteScalar(&FeatureIndex_, _FeatureIndex);
  }
  uint8_t XorMask() const {
    return ::flatbuffers::EndianScalar(XorMask_);
  }
  void mutate_XorMask(uint8_t _XorMask) {
    ::flatbuffers::WriteScalar(&XorMask_, _XorMask);
  }
  uint8_t SplitIdx() const {
    return ::flatbuffers::EndianScalar(SplitIdx_);
  }
  void mutate_SplitIdx(uint8_t _SplitIdx) {
    ::flatbuffers::WriteScalar(&SplitIdx_, _SplitIdx);
  }
};
FLATBUFFERS_STRUCT_END(TRepackedBin, 4);

struct TKeyValueT : public ::flatbuffers::NativeTable {
  typedef TKeyValue TableType;
  std::string Key{};
  std::string Value{};
};

struct TKeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TKeyValueT NativeTableType;
  typedef TKeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *Key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  ::flatbuffers::String *mutable_Key() {
    return GetPointer<::flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const TKeyValue * const o) const {
    return *Key() < *o->Key();
  }
  int KeyCompareWithValue(const char *_Key) const {
    return strcmp(Key()->c_str(), _Key);
  }
  template<typename StringType>
  int KeyCompareWithValue(const StringType& _Key) const {
    if (Key()->c_str() < _Key) return -1;
    if (_Key < Key()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::String *Value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  ::flatbuffers::String *mutable_Value() {
    return GetPointer<::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(Key()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(Value()) &&
           verifier.EndTable();
  }
  TKeyValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TKeyValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TKeyValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKeyValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TKeyValueBuilder {
  typedef TKeyValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Key(::flatbuffers::Offset<::flatbuffers::String> Key) {
    fbb_.AddOffset(TKeyValue::VT_KEY, Key);
  }
  void add_Value(::flatbuffers::Offset<::flatbuffers::String> Value) {
    fbb_.AddOffset(TKeyValue::VT_VALUE, Value);
  }
  explicit TKeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TKeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TKeyValue>(end);
    fbb_.Required(o, TKeyValue::VT_KEY);
    fbb_.Required(o, TKeyValue::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<TKeyValue> CreateTKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> Key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> Value = 0) {
  TKeyValueBuilder builder_(_fbb);
  builder_.add_Value(Value);
  builder_.add_Key(Key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TKeyValue> CreateTKeyValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *Key = nullptr,
    const char *Value = nullptr) {
  auto Key__ = Key ? _fbb.CreateString(Key) : 0;
  auto Value__ = Value ? _fbb.CreateString(Value) : 0;
  return NCatBoostFbs::CreateTKeyValue(
      _fbb,
      Key__,
      Value__);
}

::flatbuffers::Offset<TKeyValue> CreateTKeyValue(::flatbuffers::FlatBufferBuilder &_fbb, const TKeyValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TModelTreesT : public ::flatbuffers::NativeTable {
  typedef TModelTrees TableType;
  int32_t ApproxDimension = 0;
  std::vector<int32_t> TreeSplits{};
  std::vector<int32_t> TreeSizes{};
  std::vector<int32_t> TreeStartOffsets{};
  std::vector<std::unique_ptr<NCatBoostFbs::TCatFeatureT>> CatFeatures{};
  std::vector<std::unique_ptr<NCatBoostFbs::TFloatFeatureT>> FloatFeatures{};
  std::vector<std::unique_ptr<NCatBoostFbs::TOneHotFeatureT>> OneHotFeatures{};
  std::vector<std::unique_ptr<NCatBoostFbs::TCtrFeatureT>> CtrFeatures{};
  std::vector<double> LeafValues{};
  std::vector<double> LeafWeights{};
  std::vector<NCatBoostFbs::TNonSymmetricTreeStepNode> NonSymmetricStepNodes{};
  std::vector<uint32_t> NonSymmetricNodeIdToLeafId{};
  std::vector<std::unique_ptr<NCatBoostFbs::TTextFeatureT>> TextFeatures{};
  std::vector<std::unique_ptr<NCatBoostFbs::TEstimatedFeatureT>> EstimatedFeatures{};
  double Scale = 1.0;
  double Bias = 0.0;
  std::vector<double> MultiBias{};
  std::vector<NCatBoostFbs::TRepackedBin> RepackedBins{};
  std::vector<std::unique_ptr<NCatBoostFbs::TEmbeddingFeatureT>> EmbeddingFeatures{};
  TModelTreesT() = default;
  TModelTreesT(const TModelTreesT &o);
  TModelTreesT(TModelTreesT&&) FLATBUFFERS_NOEXCEPT = default;
  TModelTreesT &operator=(TModelTreesT o) FLATBUFFERS_NOEXCEPT;
};

struct TModelTrees FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TModelTreesT NativeTableType;
  typedef TModelTreesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROXDIMENSION = 4,
    VT_TREESPLITS = 6,
    VT_TREESIZES = 8,
    VT_TREESTARTOFFSETS = 10,
    VT_CATFEATURES = 12,
    VT_FLOATFEATURES = 14,
    VT_ONEHOTFEATURES = 16,
    VT_CTRFEATURES = 18,
    VT_LEAFVALUES = 20,
    VT_LEAFWEIGHTS = 22,
    VT_NONSYMMETRICSTEPNODES = 24,
    VT_NONSYMMETRICNODEIDTOLEAFID = 26,
    VT_TEXTFEATURES = 28,
    VT_ESTIMATEDFEATURES = 30,
    VT_SCALE = 32,
    VT_BIAS = 34,
    VT_MULTIBIAS = 36,
    VT_REPACKEDBINS = 38,
    VT_EMBEDDINGFEATURES = 40
  };
  int32_t ApproxDimension() const {
    return GetField<int32_t>(VT_APPROXDIMENSION, 0);
  }
  bool mutate_ApproxDimension(int32_t _ApproxDimension = 0) {
    return SetField<int32_t>(VT_APPROXDIMENSION, _ApproxDimension, 0);
  }
  const ::flatbuffers::Vector<int32_t> *TreeSplits() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TREESPLITS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_TreeSplits() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_TREESPLITS);
  }
  const ::flatbuffers::Vector<int32_t> *TreeSizes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TREESIZES);
  }
  ::flatbuffers::Vector<int32_t> *mutable_TreeSizes() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_TREESIZES);
  }
  const ::flatbuffers::Vector<int32_t> *TreeStartOffsets() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TREESTARTOFFSETS);
  }
  ::flatbuffers::Vector<int32_t> *mutable_TreeStartOffsets() {
    return GetPointer<::flatbuffers::Vector<int32_t> *>(VT_TREESTARTOFFSETS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>> *CatFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>> *>(VT_CATFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>> *mutable_CatFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>> *>(VT_CATFEATURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>> *FloatFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>> *>(VT_FLOATFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>> *mutable_FloatFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>> *>(VT_FLOATFEATURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>> *OneHotFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>> *>(VT_ONEHOTFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>> *mutable_OneHotFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>> *>(VT_ONEHOTFEATURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>> *CtrFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>> *>(VT_CTRFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>> *mutable_CtrFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>> *>(VT_CTRFEATURES);
  }
  const ::flatbuffers::Vector<double> *LeafValues() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_LEAFVALUES);
  }
  ::flatbuffers::Vector<double> *mutable_LeafValues() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_LEAFVALUES);
  }
  const ::flatbuffers::Vector<double> *LeafWeights() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_LEAFWEIGHTS);
  }
  ::flatbuffers::Vector<double> *mutable_LeafWeights() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_LEAFWEIGHTS);
  }
  const ::flatbuffers::Vector<const NCatBoostFbs::TNonSymmetricTreeStepNode *> *NonSymmetricStepNodes() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TNonSymmetricTreeStepNode *> *>(VT_NONSYMMETRICSTEPNODES);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TNonSymmetricTreeStepNode *> *mutable_NonSymmetricStepNodes() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TNonSymmetricTreeStepNode *> *>(VT_NONSYMMETRICSTEPNODES);
  }
  const ::flatbuffers::Vector<uint32_t> *NonSymmetricNodeIdToLeafId() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_NONSYMMETRICNODEIDTOLEAFID);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_NonSymmetricNodeIdToLeafId() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_NONSYMMETRICNODEIDTOLEAFID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>> *TextFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>> *>(VT_TEXTFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>> *mutable_TextFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>> *>(VT_TEXTFEATURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>> *EstimatedFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>> *>(VT_ESTIMATEDFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>> *mutable_EstimatedFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>> *>(VT_ESTIMATEDFEATURES);
  }
  double Scale() const {
    return GetField<double>(VT_SCALE, 1.0);
  }
  bool mutate_Scale(double _Scale = 1.0) {
    return SetField<double>(VT_SCALE, _Scale, 1.0);
  }
  double Bias() const {
    return GetField<double>(VT_BIAS, 0.0);
  }
  bool mutate_Bias(double _Bias = 0.0) {
    return SetField<double>(VT_BIAS, _Bias, 0.0);
  }
  const ::flatbuffers::Vector<double> *MultiBias() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_MULTIBIAS);
  }
  ::flatbuffers::Vector<double> *mutable_MultiBias() {
    return GetPointer<::flatbuffers::Vector<double> *>(VT_MULTIBIAS);
  }
  const ::flatbuffers::Vector<const NCatBoostFbs::TRepackedBin *> *RepackedBins() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TRepackedBin *> *>(VT_REPACKEDBINS);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TRepackedBin *> *mutable_RepackedBins() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TRepackedBin *> *>(VT_REPACKEDBINS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>> *EmbeddingFeatures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>> *>(VT_EMBEDDINGFEATURES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>> *mutable_EmbeddingFeatures() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>> *>(VT_EMBEDDINGFEATURES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_APPROXDIMENSION, 4) &&
           VerifyOffset(verifier, VT_TREESPLITS) &&
           verifier.VerifyVector(TreeSplits()) &&
           VerifyOffset(verifier, VT_TREESIZES) &&
           verifier.VerifyVector(TreeSizes()) &&
           VerifyOffset(verifier, VT_TREESTARTOFFSETS) &&
           verifier.VerifyVector(TreeStartOffsets()) &&
           VerifyOffset(verifier, VT_CATFEATURES) &&
           verifier.VerifyVector(CatFeatures()) &&
           verifier.VerifyVectorOfTables(CatFeatures()) &&
           VerifyOffset(verifier, VT_FLOATFEATURES) &&
           verifier.VerifyVector(FloatFeatures()) &&
           verifier.VerifyVectorOfTables(FloatFeatures()) &&
           VerifyOffset(verifier, VT_ONEHOTFEATURES) &&
           verifier.VerifyVector(OneHotFeatures()) &&
           verifier.VerifyVectorOfTables(OneHotFeatures()) &&
           VerifyOffset(verifier, VT_CTRFEATURES) &&
           verifier.VerifyVector(CtrFeatures()) &&
           verifier.VerifyVectorOfTables(CtrFeatures()) &&
           VerifyOffset(verifier, VT_LEAFVALUES) &&
           verifier.VerifyVector(LeafValues()) &&
           VerifyOffset(verifier, VT_LEAFWEIGHTS) &&
           verifier.VerifyVector(LeafWeights()) &&
           VerifyOffset(verifier, VT_NONSYMMETRICSTEPNODES) &&
           verifier.VerifyVector(NonSymmetricStepNodes()) &&
           VerifyOffset(verifier, VT_NONSYMMETRICNODEIDTOLEAFID) &&
           verifier.VerifyVector(NonSymmetricNodeIdToLeafId()) &&
           VerifyOffset(verifier, VT_TEXTFEATURES) &&
           verifier.VerifyVector(TextFeatures()) &&
           verifier.VerifyVectorOfTables(TextFeatures()) &&
           VerifyOffset(verifier, VT_ESTIMATEDFEATURES) &&
           verifier.VerifyVector(EstimatedFeatures()) &&
           verifier.VerifyVectorOfTables(EstimatedFeatures()) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<double>(verifier, VT_BIAS, 8) &&
           VerifyOffset(verifier, VT_MULTIBIAS) &&
           verifier.VerifyVector(MultiBias()) &&
           VerifyOffset(verifier, VT_REPACKEDBINS) &&
           verifier.VerifyVector(RepackedBins()) &&
           VerifyOffset(verifier, VT_EMBEDDINGFEATURES) &&
           verifier.VerifyVector(EmbeddingFeatures()) &&
           verifier.VerifyVectorOfTables(EmbeddingFeatures()) &&
           verifier.EndTable();
  }
  TModelTreesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TModelTreesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TModelTrees> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelTreesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TModelTreesBuilder {
  typedef TModelTrees Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ApproxDimension(int32_t ApproxDimension) {
    fbb_.AddElement<int32_t>(TModelTrees::VT_APPROXDIMENSION, ApproxDimension, 0);
  }
  void add_TreeSplits(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TreeSplits) {
    fbb_.AddOffset(TModelTrees::VT_TREESPLITS, TreeSplits);
  }
  void add_TreeSizes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TreeSizes) {
    fbb_.AddOffset(TModelTrees::VT_TREESIZES, TreeSizes);
  }
  void add_TreeStartOffsets(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TreeStartOffsets) {
    fbb_.AddOffset(TModelTrees::VT_TREESTARTOFFSETS, TreeStartOffsets);
  }
  void add_CatFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>>> CatFeatures) {
    fbb_.AddOffset(TModelTrees::VT_CATFEATURES, CatFeatures);
  }
  void add_FloatFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>>> FloatFeatures) {
    fbb_.AddOffset(TModelTrees::VT_FLOATFEATURES, FloatFeatures);
  }
  void add_OneHotFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>>> OneHotFeatures) {
    fbb_.AddOffset(TModelTrees::VT_ONEHOTFEATURES, OneHotFeatures);
  }
  void add_CtrFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>>> CtrFeatures) {
    fbb_.AddOffset(TModelTrees::VT_CTRFEATURES, CtrFeatures);
  }
  void add_LeafValues(::flatbuffers::Offset<::flatbuffers::Vector<double>> LeafValues) {
    fbb_.AddOffset(TModelTrees::VT_LEAFVALUES, LeafValues);
  }
  void add_LeafWeights(::flatbuffers::Offset<::flatbuffers::Vector<double>> LeafWeights) {
    fbb_.AddOffset(TModelTrees::VT_LEAFWEIGHTS, LeafWeights);
  }
  void add_NonSymmetricStepNodes(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TNonSymmetricTreeStepNode *>> NonSymmetricStepNodes) {
    fbb_.AddOffset(TModelTrees::VT_NONSYMMETRICSTEPNODES, NonSymmetricStepNodes);
  }
  void add_NonSymmetricNodeIdToLeafId(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> NonSymmetricNodeIdToLeafId) {
    fbb_.AddOffset(TModelTrees::VT_NONSYMMETRICNODEIDTOLEAFID, NonSymmetricNodeIdToLeafId);
  }
  void add_TextFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>>> TextFeatures) {
    fbb_.AddOffset(TModelTrees::VT_TEXTFEATURES, TextFeatures);
  }
  void add_EstimatedFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>>> EstimatedFeatures) {
    fbb_.AddOffset(TModelTrees::VT_ESTIMATEDFEATURES, EstimatedFeatures);
  }
  void add_Scale(double Scale) {
    fbb_.AddElement<double>(TModelTrees::VT_SCALE, Scale, 1.0);
  }
  void add_Bias(double Bias) {
    fbb_.AddElement<double>(TModelTrees::VT_BIAS, Bias, 0.0);
  }
  void add_MultiBias(::flatbuffers::Offset<::flatbuffers::Vector<double>> MultiBias) {
    fbb_.AddOffset(TModelTrees::VT_MULTIBIAS, MultiBias);
  }
  void add_RepackedBins(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TRepackedBin *>> RepackedBins) {
    fbb_.AddOffset(TModelTrees::VT_REPACKEDBINS, RepackedBins);
  }
  void add_EmbeddingFeatures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>>> EmbeddingFeatures) {
    fbb_.AddOffset(TModelTrees::VT_EMBEDDINGFEATURES, EmbeddingFeatures);
  }
  explicit TModelTreesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TModelTrees> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TModelTrees>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TModelTrees> CreateTModelTrees(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ApproxDimension = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TreeSplits = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TreeSizes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> TreeStartOffsets = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>>> CatFeatures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>>> FloatFeatures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>>> OneHotFeatures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>>> CtrFeatures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> LeafValues = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> LeafWeights = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TNonSymmetricTreeStepNode *>> NonSymmetricStepNodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> NonSymmetricNodeIdToLeafId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>>> TextFeatures = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>>> EstimatedFeatures = 0,
    double Scale = 1.0,
    double Bias = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> MultiBias = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TRepackedBin *>> RepackedBins = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>>> EmbeddingFeatures = 0) {
  TModelTreesBuilder builder_(_fbb);
  builder_.add_Bias(Bias);
  builder_.add_Scale(Scale);
  builder_.add_EmbeddingFeatures(EmbeddingFeatures);
  builder_.add_RepackedBins(RepackedBins);
  builder_.add_MultiBias(MultiBias);
  builder_.add_EstimatedFeatures(EstimatedFeatures);
  builder_.add_TextFeatures(TextFeatures);
  builder_.add_NonSymmetricNodeIdToLeafId(NonSymmetricNodeIdToLeafId);
  builder_.add_NonSymmetricStepNodes(NonSymmetricStepNodes);
  builder_.add_LeafWeights(LeafWeights);
  builder_.add_LeafValues(LeafValues);
  builder_.add_CtrFeatures(CtrFeatures);
  builder_.add_OneHotFeatures(OneHotFeatures);
  builder_.add_FloatFeatures(FloatFeatures);
  builder_.add_CatFeatures(CatFeatures);
  builder_.add_TreeStartOffsets(TreeStartOffsets);
  builder_.add_TreeSizes(TreeSizes);
  builder_.add_TreeSplits(TreeSplits);
  builder_.add_ApproxDimension(ApproxDimension);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TModelTrees> CreateTModelTreesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ApproxDimension = 0,
    const std::vector<int32_t> *TreeSplits = nullptr,
    const std::vector<int32_t> *TreeSizes = nullptr,
    const std::vector<int32_t> *TreeStartOffsets = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>> *CatFeatures = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>> *FloatFeatures = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>> *OneHotFeatures = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>> *CtrFeatures = nullptr,
    const std::vector<double> *LeafValues = nullptr,
    const std::vector<double> *LeafWeights = nullptr,
    const std::vector<NCatBoostFbs::TNonSymmetricTreeStepNode> *NonSymmetricStepNodes = nullptr,
    const std::vector<uint32_t> *NonSymmetricNodeIdToLeafId = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>> *TextFeatures = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>> *EstimatedFeatures = nullptr,
    double Scale = 1.0,
    double Bias = 0.0,
    const std::vector<double> *MultiBias = nullptr,
    const std::vector<NCatBoostFbs::TRepackedBin> *RepackedBins = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>> *EmbeddingFeatures = nullptr) {
  auto TreeSplits__ = TreeSplits ? _fbb.CreateVector<int32_t>(*TreeSplits) : 0;
  auto TreeSizes__ = TreeSizes ? _fbb.CreateVector<int32_t>(*TreeSizes) : 0;
  auto TreeStartOffsets__ = TreeStartOffsets ? _fbb.CreateVector<int32_t>(*TreeStartOffsets) : 0;
  auto CatFeatures__ = CatFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>>(*CatFeatures) : 0;
  auto FloatFeatures__ = FloatFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>>(*FloatFeatures) : 0;
  auto OneHotFeatures__ = OneHotFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>>(*OneHotFeatures) : 0;
  auto CtrFeatures__ = CtrFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>>(*CtrFeatures) : 0;
  auto LeafValues__ = LeafValues ? _fbb.CreateVector<double>(*LeafValues) : 0;
  auto LeafWeights__ = LeafWeights ? _fbb.CreateVector<double>(*LeafWeights) : 0;
  auto NonSymmetricStepNodes__ = NonSymmetricStepNodes ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TNonSymmetricTreeStepNode>(*NonSymmetricStepNodes) : 0;
  auto NonSymmetricNodeIdToLeafId__ = NonSymmetricNodeIdToLeafId ? _fbb.CreateVector<uint32_t>(*NonSymmetricNodeIdToLeafId) : 0;
  auto TextFeatures__ = TextFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>>(*TextFeatures) : 0;
  auto EstimatedFeatures__ = EstimatedFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>>(*EstimatedFeatures) : 0;
  auto MultiBias__ = MultiBias ? _fbb.CreateVector<double>(*MultiBias) : 0;
  auto RepackedBins__ = RepackedBins ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TRepackedBin>(*RepackedBins) : 0;
  auto EmbeddingFeatures__ = EmbeddingFeatures ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>>(*EmbeddingFeatures) : 0;
  return NCatBoostFbs::CreateTModelTrees(
      _fbb,
      ApproxDimension,
      TreeSplits__,
      TreeSizes__,
      TreeStartOffsets__,
      CatFeatures__,
      FloatFeatures__,
      OneHotFeatures__,
      CtrFeatures__,
      LeafValues__,
      LeafWeights__,
      NonSymmetricStepNodes__,
      NonSymmetricNodeIdToLeafId__,
      TextFeatures__,
      EstimatedFeatures__,
      Scale,
      Bias,
      MultiBias__,
      RepackedBins__,
      EmbeddingFeatures__);
}

::flatbuffers::Offset<TModelTrees> CreateTModelTrees(::flatbuffers::FlatBufferBuilder &_fbb, const TModelTreesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TModelCoreT : public ::flatbuffers::NativeTable {
  typedef TModelCore TableType;
  std::string FormatVersion{};
  std::unique_ptr<NCatBoostFbs::TModelTreesT> ModelTrees{};
  std::vector<std::unique_ptr<NCatBoostFbs::TKeyValueT>> InfoMap{};
  std::vector<std::string> ModelPartIds{};
  TModelCoreT() = default;
  TModelCoreT(const TModelCoreT &o);
  TModelCoreT(TModelCoreT&&) FLATBUFFERS_NOEXCEPT = default;
  TModelCoreT &operator=(TModelCoreT o) FLATBUFFERS_NOEXCEPT;
};

struct TModelCore FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TModelCoreT NativeTableType;
  typedef TModelCoreBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMATVERSION = 4,
    VT_MODELTREES = 6,
    VT_INFOMAP = 8,
    VT_MODELPARTIDS = 10
  };
  const ::flatbuffers::String *FormatVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMATVERSION);
  }
  ::flatbuffers::String *mutable_FormatVersion() {
    return GetPointer<::flatbuffers::String *>(VT_FORMATVERSION);
  }
  const NCatBoostFbs::TModelTrees *ModelTrees() const {
    return GetPointer<const NCatBoostFbs::TModelTrees *>(VT_MODELTREES);
  }
  NCatBoostFbs::TModelTrees *mutable_ModelTrees() {
    return GetPointer<NCatBoostFbs::TModelTrees *>(VT_MODELTREES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>> *InfoMap() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>> *>(VT_INFOMAP);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>> *mutable_InfoMap() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>> *>(VT_INFOMAP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ModelPartIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MODELPARTIDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mutable_ModelPartIds() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MODELPARTIDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FORMATVERSION) &&
           verifier.VerifyString(FormatVersion()) &&
           VerifyOffset(verifier, VT_MODELTREES) &&
           verifier.VerifyTable(ModelTrees()) &&
           VerifyOffset(verifier, VT_INFOMAP) &&
           verifier.VerifyVector(InfoMap()) &&
           verifier.VerifyVectorOfTables(InfoMap()) &&
           VerifyOffset(verifier, VT_MODELPARTIDS) &&
           verifier.VerifyVector(ModelPartIds()) &&
           verifier.VerifyVectorOfStrings(ModelPartIds()) &&
           verifier.EndTable();
  }
  TModelCoreT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TModelCoreT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TModelCore> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCoreT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TModelCoreBuilder {
  typedef TModelCore Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FormatVersion(::flatbuffers::Offset<::flatbuffers::String> FormatVersion) {
    fbb_.AddOffset(TModelCore::VT_FORMATVERSION, FormatVersion);
  }
  void add_ModelTrees(::flatbuffers::Offset<NCatBoostFbs::TModelTrees> ModelTrees) {
    fbb_.AddOffset(TModelCore::VT_MODELTREES, ModelTrees);
  }
  void add_InfoMap(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>>> InfoMap) {
    fbb_.AddOffset(TModelCore::VT_INFOMAP, InfoMap);
  }
  void add_ModelPartIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ModelPartIds) {
    fbb_.AddOffset(TModelCore::VT_MODELPARTIDS, ModelPartIds);
  }
  explicit TModelCoreBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TModelCore> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TModelCore>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TModelCore> CreateTModelCore(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> FormatVersion = 0,
    ::flatbuffers::Offset<NCatBoostFbs::TModelTrees> ModelTrees = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>>> InfoMap = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ModelPartIds = 0) {
  TModelCoreBuilder builder_(_fbb);
  builder_.add_ModelPartIds(ModelPartIds);
  builder_.add_InfoMap(InfoMap);
  builder_.add_ModelTrees(ModelTrees);
  builder_.add_FormatVersion(FormatVersion);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TModelCore> CreateTModelCoreDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *FormatVersion = nullptr,
    ::flatbuffers::Offset<NCatBoostFbs::TModelTrees> ModelTrees = 0,
    std::vector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>> *InfoMap = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ModelPartIds = nullptr) {
  auto FormatVersion__ = FormatVersion ? _fbb.CreateString(FormatVersion) : 0;
  auto InfoMap__ = InfoMap ? _fbb.CreateVectorOfSortedTables<NCatBoostFbs::TKeyValue>(InfoMap) : 0;
  auto ModelPartIds__ = ModelPartIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ModelPartIds) : 0;
  return NCatBoostFbs::CreateTModelCore(
      _fbb,
      FormatVersion__,
      ModelTrees,
      InfoMap__,
      ModelPartIds__);
}

::flatbuffers::Offset<TModelCore> CreateTModelCore(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCoreT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TKeyValueT *TKeyValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TKeyValueT>(new TKeyValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TKeyValue::UnPackTo(TKeyValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Key(); if (_e) _o->Key = _e->str(); }
  { auto _e = Value(); if (_e) _o->Value = _e->str(); }
}

inline ::flatbuffers::Offset<TKeyValue> TKeyValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKeyValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTKeyValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TKeyValue> CreateTKeyValue(::flatbuffers::FlatBufferBuilder &_fbb, const TKeyValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TKeyValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Key = _fbb.CreateString(_o->Key);
  auto _Value = _fbb.CreateString(_o->Value);
  return NCatBoostFbs::CreateTKeyValue(
      _fbb,
      _Key,
      _Value);
}

inline TModelTreesT::TModelTreesT(const TModelTreesT &o)
      : ApproxDimension(o.ApproxDimension),
        TreeSplits(o.TreeSplits),
        TreeSizes(o.TreeSizes),
        TreeStartOffsets(o.TreeStartOffsets),
        LeafValues(o.LeafValues),
        LeafWeights(o.LeafWeights),
        NonSymmetricStepNodes(o.NonSymmetricStepNodes),
        NonSymmetricNodeIdToLeafId(o.NonSymmetricNodeIdToLeafId),
        Scale(o.Scale),
        Bias(o.Bias),
        MultiBias(o.MultiBias),
        RepackedBins(o.RepackedBins) {
  CatFeatures.reserve(o.CatFeatures.size());
  for (const auto &CatFeatures_ : o.CatFeatures) { CatFeatures.emplace_back((CatFeatures_) ? new NCatBoostFbs::TCatFeatureT(*CatFeatures_) : nullptr); }
  FloatFeatures.reserve(o.FloatFeatures.size());
  for (const auto &FloatFeatures_ : o.FloatFeatures) { FloatFeatures.emplace_back((FloatFeatures_) ? new NCatBoostFbs::TFloatFeatureT(*FloatFeatures_) : nullptr); }
  OneHotFeatures.reserve(o.OneHotFeatures.size());
  for (const auto &OneHotFeatures_ : o.OneHotFeatures) { OneHotFeatures.emplace_back((OneHotFeatures_) ? new NCatBoostFbs::TOneHotFeatureT(*OneHotFeatures_) : nullptr); }
  CtrFeatures.reserve(o.CtrFeatures.size());
  for (const auto &CtrFeatures_ : o.CtrFeatures) { CtrFeatures.emplace_back((CtrFeatures_) ? new NCatBoostFbs::TCtrFeatureT(*CtrFeatures_) : nullptr); }
  TextFeatures.reserve(o.TextFeatures.size());
  for (const auto &TextFeatures_ : o.TextFeatures) { TextFeatures.emplace_back((TextFeatures_) ? new NCatBoostFbs::TTextFeatureT(*TextFeatures_) : nullptr); }
  EstimatedFeatures.reserve(o.EstimatedFeatures.size());
  for (const auto &EstimatedFeatures_ : o.EstimatedFeatures) { EstimatedFeatures.emplace_back((EstimatedFeatures_) ? new NCatBoostFbs::TEstimatedFeatureT(*EstimatedFeatures_) : nullptr); }
  EmbeddingFeatures.reserve(o.EmbeddingFeatures.size());
  for (const auto &EmbeddingFeatures_ : o.EmbeddingFeatures) { EmbeddingFeatures.emplace_back((EmbeddingFeatures_) ? new NCatBoostFbs::TEmbeddingFeatureT(*EmbeddingFeatures_) : nullptr); }
}

inline TModelTreesT &TModelTreesT::operator=(TModelTreesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(ApproxDimension, o.ApproxDimension);
  std::swap(TreeSplits, o.TreeSplits);
  std::swap(TreeSizes, o.TreeSizes);
  std::swap(TreeStartOffsets, o.TreeStartOffsets);
  std::swap(CatFeatures, o.CatFeatures);
  std::swap(FloatFeatures, o.FloatFeatures);
  std::swap(OneHotFeatures, o.OneHotFeatures);
  std::swap(CtrFeatures, o.CtrFeatures);
  std::swap(LeafValues, o.LeafValues);
  std::swap(LeafWeights, o.LeafWeights);
  std::swap(NonSymmetricStepNodes, o.NonSymmetricStepNodes);
  std::swap(NonSymmetricNodeIdToLeafId, o.NonSymmetricNodeIdToLeafId);
  std::swap(TextFeatures, o.TextFeatures);
  std::swap(EstimatedFeatures, o.EstimatedFeatures);
  std::swap(Scale, o.Scale);
  std::swap(Bias, o.Bias);
  std::swap(MultiBias, o.MultiBias);
  std::swap(RepackedBins, o.RepackedBins);
  std::swap(EmbeddingFeatures, o.EmbeddingFeatures);
  return *this;
}

inline TModelTreesT *TModelTrees::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TModelTreesT>(new TModelTreesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TModelTrees::UnPackTo(TModelTreesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ApproxDimension(); _o->ApproxDimension = _e; }
  { auto _e = TreeSplits(); if (_e) { _o->TreeSplits.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->TreeSplits[_i] = _e->Get(_i); } } else { _o->TreeSplits.resize(0); } }
  { auto _e = TreeSizes(); if (_e) { _o->TreeSizes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->TreeSizes[_i] = _e->Get(_i); } } else { _o->TreeSizes.resize(0); } }
  { auto _e = TreeStartOffsets(); if (_e) { _o->TreeStartOffsets.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->TreeStartOffsets[_i] = _e->Get(_i); } } else { _o->TreeStartOffsets.resize(0); } }
  { auto _e = CatFeatures(); if (_e) { _o->CatFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->CatFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->CatFeatures[_i].get(), _resolver); } else { _o->CatFeatures[_i] = std::unique_ptr<NCatBoostFbs::TCatFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->CatFeatures.resize(0); } }
  { auto _e = FloatFeatures(); if (_e) { _o->FloatFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->FloatFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->FloatFeatures[_i].get(), _resolver); } else { _o->FloatFeatures[_i] = std::unique_ptr<NCatBoostFbs::TFloatFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->FloatFeatures.resize(0); } }
  { auto _e = OneHotFeatures(); if (_e) { _o->OneHotFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->OneHotFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->OneHotFeatures[_i].get(), _resolver); } else { _o->OneHotFeatures[_i] = std::unique_ptr<NCatBoostFbs::TOneHotFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->OneHotFeatures.resize(0); } }
  { auto _e = CtrFeatures(); if (_e) { _o->CtrFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->CtrFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->CtrFeatures[_i].get(), _resolver); } else { _o->CtrFeatures[_i] = std::unique_ptr<NCatBoostFbs::TCtrFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->CtrFeatures.resize(0); } }
  { auto _e = LeafValues(); if (_e) { _o->LeafValues.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->LeafValues[_i] = _e->Get(_i); } } else { _o->LeafValues.resize(0); } }
  { auto _e = LeafWeights(); if (_e) { _o->LeafWeights.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->LeafWeights[_i] = _e->Get(_i); } } else { _o->LeafWeights.resize(0); } }
  { auto _e = NonSymmetricStepNodes(); if (_e) { _o->NonSymmetricStepNodes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->NonSymmetricStepNodes[_i] = *_e->Get(_i); } } else { _o->NonSymmetricStepNodes.resize(0); } }
  { auto _e = NonSymmetricNodeIdToLeafId(); if (_e) { _o->NonSymmetricNodeIdToLeafId.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->NonSymmetricNodeIdToLeafId[_i] = _e->Get(_i); } } else { _o->NonSymmetricNodeIdToLeafId.resize(0); } }
  { auto _e = TextFeatures(); if (_e) { _o->TextFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->TextFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->TextFeatures[_i].get(), _resolver); } else { _o->TextFeatures[_i] = std::unique_ptr<NCatBoostFbs::TTextFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->TextFeatures.resize(0); } }
  { auto _e = EstimatedFeatures(); if (_e) { _o->EstimatedFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->EstimatedFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->EstimatedFeatures[_i].get(), _resolver); } else { _o->EstimatedFeatures[_i] = std::unique_ptr<NCatBoostFbs::TEstimatedFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->EstimatedFeatures.resize(0); } }
  { auto _e = Scale(); _o->Scale = _e; }
  { auto _e = Bias(); _o->Bias = _e; }
  { auto _e = MultiBias(); if (_e) { _o->MultiBias.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->MultiBias[_i] = _e->Get(_i); } } else { _o->MultiBias.resize(0); } }
  { auto _e = RepackedBins(); if (_e) { _o->RepackedBins.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->RepackedBins[_i] = *_e->Get(_i); } } else { _o->RepackedBins.resize(0); } }
  { auto _e = EmbeddingFeatures(); if (_e) { _o->EmbeddingFeatures.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->EmbeddingFeatures[_i]) { _e->Get(_i)->UnPackTo(_o->EmbeddingFeatures[_i].get(), _resolver); } else { _o->EmbeddingFeatures[_i] = std::unique_ptr<NCatBoostFbs::TEmbeddingFeatureT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->EmbeddingFeatures.resize(0); } }
}

inline ::flatbuffers::Offset<TModelTrees> TModelTrees::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelTreesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTModelTrees(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TModelTrees> CreateTModelTrees(::flatbuffers::FlatBufferBuilder &_fbb, const TModelTreesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TModelTreesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ApproxDimension = _o->ApproxDimension;
  auto _TreeSplits = _o->TreeSplits.size() ? _fbb.CreateVector(_o->TreeSplits) : 0;
  auto _TreeSizes = _o->TreeSizes.size() ? _fbb.CreateVector(_o->TreeSizes) : 0;
  auto _TreeStartOffsets = _o->TreeStartOffsets.size() ? _fbb.CreateVector(_o->TreeStartOffsets) : 0;
  auto _CatFeatures = _o->CatFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TCatFeature>> (_o->CatFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTCatFeature(*__va->__fbb, __va->__o->CatFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _FloatFeatures = _o->FloatFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TFloatFeature>> (_o->FloatFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTFloatFeature(*__va->__fbb, __va->__o->FloatFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _OneHotFeatures = _o->OneHotFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TOneHotFeature>> (_o->OneHotFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTOneHotFeature(*__va->__fbb, __va->__o->OneHotFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _CtrFeatures = _o->CtrFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TCtrFeature>> (_o->CtrFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTCtrFeature(*__va->__fbb, __va->__o->CtrFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _LeafValues = _o->LeafValues.size() ? _fbb.CreateVector(_o->LeafValues) : 0;
  auto _LeafWeights = _o->LeafWeights.size() ? _fbb.CreateVector(_o->LeafWeights) : 0;
  auto _NonSymmetricStepNodes = _o->NonSymmetricStepNodes.size() ? _fbb.CreateVectorOfStructs(_o->NonSymmetricStepNodes) : 0;
  auto _NonSymmetricNodeIdToLeafId = _o->NonSymmetricNodeIdToLeafId.size() ? _fbb.CreateVector(_o->NonSymmetricNodeIdToLeafId) : 0;
  auto _TextFeatures = _o->TextFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TTextFeature>> (_o->TextFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTTextFeature(*__va->__fbb, __va->__o->TextFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _EstimatedFeatures = _o->EstimatedFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TEstimatedFeature>> (_o->EstimatedFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTEstimatedFeature(*__va->__fbb, __va->__o->EstimatedFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _Scale = _o->Scale;
  auto _Bias = _o->Bias;
  auto _MultiBias = _o->MultiBias.size() ? _fbb.CreateVector(_o->MultiBias) : 0;
  auto _RepackedBins = _o->RepackedBins.size() ? _fbb.CreateVectorOfStructs(_o->RepackedBins) : 0;
  auto _EmbeddingFeatures = _o->EmbeddingFeatures.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TEmbeddingFeature>> (_o->EmbeddingFeatures.size(), [](size_t i, _VectorArgs *__va) { return CreateTEmbeddingFeature(*__va->__fbb, __va->__o->EmbeddingFeatures[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NCatBoostFbs::CreateTModelTrees(
      _fbb,
      _ApproxDimension,
      _TreeSplits,
      _TreeSizes,
      _TreeStartOffsets,
      _CatFeatures,
      _FloatFeatures,
      _OneHotFeatures,
      _CtrFeatures,
      _LeafValues,
      _LeafWeights,
      _NonSymmetricStepNodes,
      _NonSymmetricNodeIdToLeafId,
      _TextFeatures,
      _EstimatedFeatures,
      _Scale,
      _Bias,
      _MultiBias,
      _RepackedBins,
      _EmbeddingFeatures);
}

inline TModelCoreT::TModelCoreT(const TModelCoreT &o)
      : FormatVersion(o.FormatVersion),
        ModelTrees((o.ModelTrees) ? new NCatBoostFbs::TModelTreesT(*o.ModelTrees) : nullptr),
        ModelPartIds(o.ModelPartIds) {
  InfoMap.reserve(o.InfoMap.size());
  for (const auto &InfoMap_ : o.InfoMap) { InfoMap.emplace_back((InfoMap_) ? new NCatBoostFbs::TKeyValueT(*InfoMap_) : nullptr); }
}

inline TModelCoreT &TModelCoreT::operator=(TModelCoreT o) FLATBUFFERS_NOEXCEPT {
  std::swap(FormatVersion, o.FormatVersion);
  std::swap(ModelTrees, o.ModelTrees);
  std::swap(InfoMap, o.InfoMap);
  std::swap(ModelPartIds, o.ModelPartIds);
  return *this;
}

inline TModelCoreT *TModelCore::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TModelCoreT>(new TModelCoreT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TModelCore::UnPackTo(TModelCoreT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = FormatVersion(); if (_e) _o->FormatVersion = _e->str(); }
  { auto _e = ModelTrees(); if (_e) { if(_o->ModelTrees) { _e->UnPackTo(_o->ModelTrees.get(), _resolver); } else { _o->ModelTrees = std::unique_ptr<NCatBoostFbs::TModelTreesT>(_e->UnPack(_resolver)); } } else if (_o->ModelTrees) { _o->ModelTrees.reset(); } }
  { auto _e = InfoMap(); if (_e) { _o->InfoMap.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->InfoMap[_i]) { _e->Get(_i)->UnPackTo(_o->InfoMap[_i].get(), _resolver); } else { _o->InfoMap[_i] = std::unique_ptr<NCatBoostFbs::TKeyValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->InfoMap.resize(0); } }
  { auto _e = ModelPartIds(); if (_e) { _o->ModelPartIds.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ModelPartIds[_i] = _e->Get(_i)->str(); } } else { _o->ModelPartIds.resize(0); } }
}

inline ::flatbuffers::Offset<TModelCore> TModelCore::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCoreT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTModelCore(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TModelCore> CreateTModelCore(::flatbuffers::FlatBufferBuilder &_fbb, const TModelCoreT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TModelCoreT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _FormatVersion = _o->FormatVersion.empty() ? 0 : _fbb.CreateString(_o->FormatVersion);
  auto _ModelTrees = _o->ModelTrees ? CreateTModelTrees(_fbb, _o->ModelTrees.get(), _rehasher) : 0;
  auto _InfoMap = _o->InfoMap.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::TKeyValue>> (_o->InfoMap.size(), [](size_t i, _VectorArgs *__va) { return CreateTKeyValue(*__va->__fbb, __va->__o->InfoMap[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _ModelPartIds = _o->ModelPartIds.size() ? _fbb.CreateVectorOfStrings(_o->ModelPartIds) : 0;
  return NCatBoostFbs::CreateTModelCore(
      _fbb,
      _FormatVersion,
      _ModelTrees,
      _InfoMap,
      _ModelPartIds);
}

inline const NCatBoostFbs::TModelCore *GetTModelCore(const void *buf) {
  return ::flatbuffers::GetRoot<NCatBoostFbs::TModelCore>(buf);
}

inline const NCatBoostFbs::TModelCore *GetSizePrefixedTModelCore(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::TModelCore>(buf);
}

inline TModelCore *GetMutableTModelCore(void *buf) {
  return ::flatbuffers::GetMutableRoot<TModelCore>(buf);
}

inline NCatBoostFbs::TModelCore *GetMutableSizePrefixedTModelCore(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NCatBoostFbs::TModelCore>(buf);
}

inline bool VerifyTModelCoreBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::TModelCore>(nullptr);
}

inline bool VerifySizePrefixedTModelCoreBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::TModelCore>(nullptr);
}

inline const char *TModelCoreExtension() {
  return "bfbs";
}

inline void FinishTModelCoreBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCore> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTModelCoreBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TModelCore> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NCatBoostFbs::TModelCoreT> UnPackTModelCore(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TModelCoreT>(GetTModelCore(buf)->UnPack(res));
}

inline std::unique_ptr<NCatBoostFbs::TModelCoreT> UnPackSizePrefixedTModelCore(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TModelCoreT>(GetSizePrefixedTModelCore(buf)->UnPack(res));
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_MODEL_NCATBOOSTFBS_H_
