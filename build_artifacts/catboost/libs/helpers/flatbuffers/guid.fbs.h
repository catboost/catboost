// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GUID_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_GUID_NCATBOOSTFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace NCatBoostFbs {

struct TGuid;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TGuid FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t dw0_;
  uint32_t dw1_;
  uint32_t dw2_;
  uint32_t dw3_;

 public:
  TGuid()
      : dw0_(0),
        dw1_(0),
        dw2_(0),
        dw3_(0) {
  }
  TGuid(uint32_t _dw0, uint32_t _dw1, uint32_t _dw2, uint32_t _dw3)
      : dw0_(::flatbuffers::EndianScalar(_dw0)),
        dw1_(::flatbuffers::EndianScalar(_dw1)),
        dw2_(::flatbuffers::EndianScalar(_dw2)),
        dw3_(::flatbuffers::EndianScalar(_dw3)) {
  }
  uint32_t dw0() const {
    return ::flatbuffers::EndianScalar(dw0_);
  }
  void mutate_dw0(uint32_t _dw0) {
    ::flatbuffers::WriteScalar(&dw0_, _dw0);
  }
  uint32_t dw1() const {
    return ::flatbuffers::EndianScalar(dw1_);
  }
  void mutate_dw1(uint32_t _dw1) {
    ::flatbuffers::WriteScalar(&dw1_, _dw1);
  }
  uint32_t dw2() const {
    return ::flatbuffers::EndianScalar(dw2_);
  }
  void mutate_dw2(uint32_t _dw2) {
    ::flatbuffers::WriteScalar(&dw2_, _dw2);
  }
  uint32_t dw3() const {
    return ::flatbuffers::EndianScalar(dw3_);
  }
  void mutate_dw3(uint32_t _dw3) {
    ::flatbuffers::WriteScalar(&dw3_, _dw3);
  }
};
FLATBUFFERS_STRUCT_END(TGuid, 16);

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_GUID_NCATBOOSTFBS_H_
