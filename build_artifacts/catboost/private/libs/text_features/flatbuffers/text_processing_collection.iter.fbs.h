// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTPROCESSINGCOLLECTION_NCATBOOSTFBS_ITER_H_
#define FLATBUFFERS_GENERATED_TEXTPROCESSINGCOLLECTION_NCATBOOSTFBS_ITER_H_

#include "text_processing_collection.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

#include "catboost/libs/helpers/flatbuffers/guid.iter.fbs.h"

namespace NCatBoostFbs {
namespace iter {

template <typename Iter>
struct AdjacencyList;

template <typename Iter>
struct TCollectionHeader;

template <typename Iter>
struct TCollectionPart;

template <typename Iter>
struct AdjacencyList FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_IDS = 4
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>> Ids() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>>(VT_IDS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_IDS) &&
           verifier.Verify(Ids()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCollectionHeader FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_TOKENIZERID = 4,
    VT_DICTIONARYID = 6,
    VT_CALCERID = 8,
    VT_PERFEATUREDIGITIZERS = 10,
    VT_PERTOKENIZEDFEATURECALCERS = 12
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<yandex::maps::flatbuffers_iter::Vector<TGuid, Iter>> TokenizerId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<TGuid, Iter>>(VT_TOKENIZERID);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<TGuid, Iter>> DictionaryId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<TGuid, Iter>>(VT_DICTIONARYID);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<TGuid, Iter>> CalcerId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<TGuid, Iter>>(VT_CALCERID);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<AdjacencyList<Iter>>, Iter>> PerFeatureDigitizers() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<AdjacencyList<Iter>>, Iter>>(VT_PERFEATUREDIGITIZERS);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<AdjacencyList<Iter>>, Iter>> PerTokenizedFeatureCalcers() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<AdjacencyList<Iter>>, Iter>>(VT_PERTOKENIZEDFEATURECALCERS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_TOKENIZERID) &&
           verifier.Verify(TokenizerId()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_DICTIONARYID) &&
           verifier.Verify(DictionaryId()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CALCERID) &&
           verifier.Verify(CalcerId()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_PERFEATUREDIGITIZERS) &&
           verifier.Verify(PerFeatureDigitizers()) &&
           verifier.VerifyVectorOfTables(PerFeatureDigitizers()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_PERTOKENIZEDFEATURECALCERS) &&
           verifier.Verify(PerTokenizedFeatureCalcers()) &&
           verifier.VerifyVectorOfTables(PerTokenizedFeatureCalcers()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCollectionPart FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_PARTTYPE = 4,
    VT_ID = 6
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  EPartType PartType() const {
    return static_cast<EPartType>(this->template GetField<uint8_t>(VT_PARTTYPE, 0));
  }
  std::optional<TGuid> Id() const {
    return this->template GetStruct<TGuid>(VT_ID);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<uint8_t>(verifier, VT_PARTTYPE, 1) &&
           this->template VerifyField<TGuid>(verifier, VT_ID, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
inline std::optional<NCatBoostFbs::iter::TCollectionPart<Iter>> GetTCollectionPart(const Iter& buf) {
  return yandex::maps::flatbuffers_iter::GetRoot<NCatBoostFbs::iter::TCollectionPart<Iter>, Iter>(buf);
}

inline const NCatBoostFbs::TCollectionPart *GetTCollectionPart(const char *buf) {
  return NCatBoostFbs::GetTCollectionPart(buf);
}

template <typename Iter>
inline bool VerifyTCollectionPartBuffer(
    yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) {
  return verifier.template VerifyBuffer<NCatBoostFbs::iter::TCollectionPart<Iter>>(nullptr);
}

inline const char *TCollectionPartExtension() {
  return "bfbs";
}

}  // namespace iter
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_TEXTPROCESSINGCOLLECTION_NCATBOOSTFBS_ITER_H_
