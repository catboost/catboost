// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FEATURECALCERS_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_FEATURECALCERS_NCATBOOSTFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/helpers/flatbuffers/guid.fbs.h"

namespace NCatBoostFbs {

struct TBM25;
struct TBM25Builder;
struct TBM25T;

struct TNaiveBayes;
struct TNaiveBayesBuilder;
struct TNaiveBayesT;

struct TBoW;
struct TBoWBuilder;
struct TBoWT;

struct TFeatureCalcer;
struct TFeatureCalcerBuilder;
struct TFeatureCalcerT;

enum TAnyFeatureCalcer : uint8_t {
  TAnyFeatureCalcer_NONE = 0,
  TAnyFeatureCalcer_TBM25 = 1,
  TAnyFeatureCalcer_TNaiveBayes = 2,
  TAnyFeatureCalcer_TBoW = 3,
  TAnyFeatureCalcer_MIN = TAnyFeatureCalcer_NONE,
  TAnyFeatureCalcer_MAX = TAnyFeatureCalcer_TBoW
};

inline const TAnyFeatureCalcer (&EnumValuesTAnyFeatureCalcer())[4] {
  static const TAnyFeatureCalcer values[] = {
    TAnyFeatureCalcer_NONE,
    TAnyFeatureCalcer_TBM25,
    TAnyFeatureCalcer_TNaiveBayes,
    TAnyFeatureCalcer_TBoW
  };
  return values;
}

inline const char * const *EnumNamesTAnyFeatureCalcer() {
  static const char * const names[5] = {
    "NONE",
    "TBM25",
    "TNaiveBayes",
    "TBoW",
    nullptr
  };
  return names;
}

inline const char *EnumNameTAnyFeatureCalcer(TAnyFeatureCalcer e) {
  if (::flatbuffers::IsOutRange(e, TAnyFeatureCalcer_NONE, TAnyFeatureCalcer_TBoW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTAnyFeatureCalcer()[index];
}

template<typename T> struct TAnyFeatureCalcerTraits {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_NONE;
};

template<> struct TAnyFeatureCalcerTraits<NCatBoostFbs::TBM25> {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_TBM25;
};

template<> struct TAnyFeatureCalcerTraits<NCatBoostFbs::TNaiveBayes> {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_TNaiveBayes;
};

template<> struct TAnyFeatureCalcerTraits<NCatBoostFbs::TBoW> {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_TBoW;
};

template<typename T> struct TAnyFeatureCalcerUnionTraits {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_NONE;
};

template<> struct TAnyFeatureCalcerUnionTraits<NCatBoostFbs::TBM25T> {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_TBM25;
};

template<> struct TAnyFeatureCalcerUnionTraits<NCatBoostFbs::TNaiveBayesT> {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_TNaiveBayes;
};

template<> struct TAnyFeatureCalcerUnionTraits<NCatBoostFbs::TBoWT> {
  static const TAnyFeatureCalcer enum_value = TAnyFeatureCalcer_TBoW;
};

struct TAnyFeatureCalcerUnion {
  TAnyFeatureCalcer type;
  void *value;

  TAnyFeatureCalcerUnion() : type(TAnyFeatureCalcer_NONE), value(nullptr) {}
  TAnyFeatureCalcerUnion(TAnyFeatureCalcerUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(TAnyFeatureCalcer_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  TAnyFeatureCalcerUnion(const TAnyFeatureCalcerUnion &);
  TAnyFeatureCalcerUnion &operator=(const TAnyFeatureCalcerUnion &u)
    { TAnyFeatureCalcerUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  TAnyFeatureCalcerUnion &operator=(TAnyFeatureCalcerUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~TAnyFeatureCalcerUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = TAnyFeatureCalcerUnionTraits<RT>::enum_value;
    if (type != TAnyFeatureCalcer_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, TAnyFeatureCalcer type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  NCatBoostFbs::TBM25T *AsTBM25() {
    return type == TAnyFeatureCalcer_TBM25 ?
      reinterpret_cast<NCatBoostFbs::TBM25T *>(value) : nullptr;
  }
  const NCatBoostFbs::TBM25T *AsTBM25() const {
    return type == TAnyFeatureCalcer_TBM25 ?
      reinterpret_cast<const NCatBoostFbs::TBM25T *>(value) : nullptr;
  }
  NCatBoostFbs::TNaiveBayesT *AsTNaiveBayes() {
    return type == TAnyFeatureCalcer_TNaiveBayes ?
      reinterpret_cast<NCatBoostFbs::TNaiveBayesT *>(value) : nullptr;
  }
  const NCatBoostFbs::TNaiveBayesT *AsTNaiveBayes() const {
    return type == TAnyFeatureCalcer_TNaiveBayes ?
      reinterpret_cast<const NCatBoostFbs::TNaiveBayesT *>(value) : nullptr;
  }
  NCatBoostFbs::TBoWT *AsTBoW() {
    return type == TAnyFeatureCalcer_TBoW ?
      reinterpret_cast<NCatBoostFbs::TBoWT *>(value) : nullptr;
  }
  const NCatBoostFbs::TBoWT *AsTBoW() const {
    return type == TAnyFeatureCalcer_TBoW ?
      reinterpret_cast<const NCatBoostFbs::TBoWT *>(value) : nullptr;
  }
};

bool VerifyTAnyFeatureCalcer(::flatbuffers::Verifier &verifier, const void *obj, TAnyFeatureCalcer type);
bool VerifyTAnyFeatureCalcerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct TBM25T : public ::flatbuffers::NativeTable {
  typedef TBM25 TableType;
  uint32_t NumClasses = 0;
  float ParamK = 0.0f;
  float ParamB = 0.0f;
  float TruncateBorder = 0.0f;
  uint64_t TotalTokens = 0;
  std::vector<uint64_t> ClassTotalTokens{};
};

struct TBM25 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TBM25T NativeTableType;
  typedef TBM25Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMCLASSES = 4,
    VT_PARAMK = 6,
    VT_PARAMB = 8,
    VT_TRUNCATEBORDER = 10,
    VT_TOTALTOKENS = 12,
    VT_CLASSTOTALTOKENS = 14
  };
  uint32_t NumClasses() const {
    return GetField<uint32_t>(VT_NUMCLASSES, 0);
  }
  bool mutate_NumClasses(uint32_t _NumClasses = 0) {
    return SetField<uint32_t>(VT_NUMCLASSES, _NumClasses, 0);
  }
  float ParamK() const {
    return GetField<float>(VT_PARAMK, 0.0f);
  }
  bool mutate_ParamK(float _ParamK = 0.0f) {
    return SetField<float>(VT_PARAMK, _ParamK, 0.0f);
  }
  float ParamB() const {
    return GetField<float>(VT_PARAMB, 0.0f);
  }
  bool mutate_ParamB(float _ParamB = 0.0f) {
    return SetField<float>(VT_PARAMB, _ParamB, 0.0f);
  }
  float TruncateBorder() const {
    return GetField<float>(VT_TRUNCATEBORDER, 0.0f);
  }
  bool mutate_TruncateBorder(float _TruncateBorder = 0.0f) {
    return SetField<float>(VT_TRUNCATEBORDER, _TruncateBorder, 0.0f);
  }
  uint64_t TotalTokens() const {
    return GetField<uint64_t>(VT_TOTALTOKENS, 0);
  }
  bool mutate_TotalTokens(uint64_t _TotalTokens = 0) {
    return SetField<uint64_t>(VT_TOTALTOKENS, _TotalTokens, 0);
  }
  const ::flatbuffers::Vector<uint64_t> *ClassTotalTokens() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_CLASSTOTALTOKENS);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_ClassTotalTokens() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_CLASSTOTALTOKENS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMCLASSES, 4) &&
           VerifyField<float>(verifier, VT_PARAMK, 4) &&
           VerifyField<float>(verifier, VT_PARAMB, 4) &&
           VerifyField<float>(verifier, VT_TRUNCATEBORDER, 4) &&
           VerifyField<uint64_t>(verifier, VT_TOTALTOKENS, 8) &&
           VerifyOffset(verifier, VT_CLASSTOTALTOKENS) &&
           verifier.VerifyVector(ClassTotalTokens()) &&
           verifier.EndTable();
  }
  TBM25T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TBM25T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TBM25> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TBM25T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TBM25Builder {
  typedef TBM25 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NumClasses(uint32_t NumClasses) {
    fbb_.AddElement<uint32_t>(TBM25::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_ParamK(float ParamK) {
    fbb_.AddElement<float>(TBM25::VT_PARAMK, ParamK, 0.0f);
  }
  void add_ParamB(float ParamB) {
    fbb_.AddElement<float>(TBM25::VT_PARAMB, ParamB, 0.0f);
  }
  void add_TruncateBorder(float TruncateBorder) {
    fbb_.AddElement<float>(TBM25::VT_TRUNCATEBORDER, TruncateBorder, 0.0f);
  }
  void add_TotalTokens(uint64_t TotalTokens) {
    fbb_.AddElement<uint64_t>(TBM25::VT_TOTALTOKENS, TotalTokens, 0);
  }
  void add_ClassTotalTokens(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> ClassTotalTokens) {
    fbb_.AddOffset(TBM25::VT_CLASSTOTALTOKENS, ClassTotalTokens);
  }
  explicit TBM25Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TBM25> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TBM25>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TBM25> CreateTBM25(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NumClasses = 0,
    float ParamK = 0.0f,
    float ParamB = 0.0f,
    float TruncateBorder = 0.0f,
    uint64_t TotalTokens = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> ClassTotalTokens = 0) {
  TBM25Builder builder_(_fbb);
  builder_.add_TotalTokens(TotalTokens);
  builder_.add_ClassTotalTokens(ClassTotalTokens);
  builder_.add_TruncateBorder(TruncateBorder);
  builder_.add_ParamB(ParamB);
  builder_.add_ParamK(ParamK);
  builder_.add_NumClasses(NumClasses);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TBM25> CreateTBM25Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NumClasses = 0,
    float ParamK = 0.0f,
    float ParamB = 0.0f,
    float TruncateBorder = 0.0f,
    uint64_t TotalTokens = 0,
    const std::vector<uint64_t> *ClassTotalTokens = nullptr) {
  auto ClassTotalTokens__ = ClassTotalTokens ? _fbb.CreateVector<uint64_t>(*ClassTotalTokens) : 0;
  return NCatBoostFbs::CreateTBM25(
      _fbb,
      NumClasses,
      ParamK,
      ParamB,
      TruncateBorder,
      TotalTokens,
      ClassTotalTokens__);
}

::flatbuffers::Offset<TBM25> CreateTBM25(::flatbuffers::FlatBufferBuilder &_fbb, const TBM25T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TNaiveBayesT : public ::flatbuffers::NativeTable {
  typedef TNaiveBayes TableType;
  uint32_t NumClasses = 0;
  float ClassPrior = 0.0f;
  float TokenPrior = 0.0f;
  uint64_t NumSeenTokens = 0;
  std::vector<uint32_t> ClassDocs{};
  std::vector<uint64_t> ClassTotalTokens{};
};

struct TNaiveBayes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TNaiveBayesT NativeTableType;
  typedef TNaiveBayesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMCLASSES = 4,
    VT_CLASSPRIOR = 6,
    VT_TOKENPRIOR = 8,
    VT_NUMSEENTOKENS = 10,
    VT_CLASSDOCS = 12,
    VT_CLASSTOTALTOKENS = 14
  };
  uint32_t NumClasses() const {
    return GetField<uint32_t>(VT_NUMCLASSES, 0);
  }
  bool mutate_NumClasses(uint32_t _NumClasses = 0) {
    return SetField<uint32_t>(VT_NUMCLASSES, _NumClasses, 0);
  }
  float ClassPrior() const {
    return GetField<float>(VT_CLASSPRIOR, 0.0f);
  }
  bool mutate_ClassPrior(float _ClassPrior = 0.0f) {
    return SetField<float>(VT_CLASSPRIOR, _ClassPrior, 0.0f);
  }
  float TokenPrior() const {
    return GetField<float>(VT_TOKENPRIOR, 0.0f);
  }
  bool mutate_TokenPrior(float _TokenPrior = 0.0f) {
    return SetField<float>(VT_TOKENPRIOR, _TokenPrior, 0.0f);
  }
  uint64_t NumSeenTokens() const {
    return GetField<uint64_t>(VT_NUMSEENTOKENS, 0);
  }
  bool mutate_NumSeenTokens(uint64_t _NumSeenTokens = 0) {
    return SetField<uint64_t>(VT_NUMSEENTOKENS, _NumSeenTokens, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *ClassDocs() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_CLASSDOCS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_ClassDocs() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_CLASSDOCS);
  }
  const ::flatbuffers::Vector<uint64_t> *ClassTotalTokens() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_CLASSTOTALTOKENS);
  }
  ::flatbuffers::Vector<uint64_t> *mutable_ClassTotalTokens() {
    return GetPointer<::flatbuffers::Vector<uint64_t> *>(VT_CLASSTOTALTOKENS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMCLASSES, 4) &&
           VerifyField<float>(verifier, VT_CLASSPRIOR, 4) &&
           VerifyField<float>(verifier, VT_TOKENPRIOR, 4) &&
           VerifyField<uint64_t>(verifier, VT_NUMSEENTOKENS, 8) &&
           VerifyOffset(verifier, VT_CLASSDOCS) &&
           verifier.VerifyVector(ClassDocs()) &&
           VerifyOffset(verifier, VT_CLASSTOTALTOKENS) &&
           verifier.VerifyVector(ClassTotalTokens()) &&
           verifier.EndTable();
  }
  TNaiveBayesT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TNaiveBayesT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TNaiveBayes> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNaiveBayesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TNaiveBayesBuilder {
  typedef TNaiveBayes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NumClasses(uint32_t NumClasses) {
    fbb_.AddElement<uint32_t>(TNaiveBayes::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_ClassPrior(float ClassPrior) {
    fbb_.AddElement<float>(TNaiveBayes::VT_CLASSPRIOR, ClassPrior, 0.0f);
  }
  void add_TokenPrior(float TokenPrior) {
    fbb_.AddElement<float>(TNaiveBayes::VT_TOKENPRIOR, TokenPrior, 0.0f);
  }
  void add_NumSeenTokens(uint64_t NumSeenTokens) {
    fbb_.AddElement<uint64_t>(TNaiveBayes::VT_NUMSEENTOKENS, NumSeenTokens, 0);
  }
  void add_ClassDocs(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ClassDocs) {
    fbb_.AddOffset(TNaiveBayes::VT_CLASSDOCS, ClassDocs);
  }
  void add_ClassTotalTokens(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> ClassTotalTokens) {
    fbb_.AddOffset(TNaiveBayes::VT_CLASSTOTALTOKENS, ClassTotalTokens);
  }
  explicit TNaiveBayesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TNaiveBayes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TNaiveBayes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TNaiveBayes> CreateTNaiveBayes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NumClasses = 0,
    float ClassPrior = 0.0f,
    float TokenPrior = 0.0f,
    uint64_t NumSeenTokens = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ClassDocs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> ClassTotalTokens = 0) {
  TNaiveBayesBuilder builder_(_fbb);
  builder_.add_NumSeenTokens(NumSeenTokens);
  builder_.add_ClassTotalTokens(ClassTotalTokens);
  builder_.add_ClassDocs(ClassDocs);
  builder_.add_TokenPrior(TokenPrior);
  builder_.add_ClassPrior(ClassPrior);
  builder_.add_NumClasses(NumClasses);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TNaiveBayes> CreateTNaiveBayesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NumClasses = 0,
    float ClassPrior = 0.0f,
    float TokenPrior = 0.0f,
    uint64_t NumSeenTokens = 0,
    const std::vector<uint32_t> *ClassDocs = nullptr,
    const std::vector<uint64_t> *ClassTotalTokens = nullptr) {
  auto ClassDocs__ = ClassDocs ? _fbb.CreateVector<uint32_t>(*ClassDocs) : 0;
  auto ClassTotalTokens__ = ClassTotalTokens ? _fbb.CreateVector<uint64_t>(*ClassTotalTokens) : 0;
  return NCatBoostFbs::CreateTNaiveBayes(
      _fbb,
      NumClasses,
      ClassPrior,
      TokenPrior,
      NumSeenTokens,
      ClassDocs__,
      ClassTotalTokens__);
}

::flatbuffers::Offset<TNaiveBayes> CreateTNaiveBayes(::flatbuffers::FlatBufferBuilder &_fbb, const TNaiveBayesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TBoWT : public ::flatbuffers::NativeTable {
  typedef TBoW TableType;
  uint32_t NumTokens = 0;
};

struct TBoW FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TBoWT NativeTableType;
  typedef TBoWBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMTOKENS = 4
  };
  uint32_t NumTokens() const {
    return GetField<uint32_t>(VT_NUMTOKENS, 0);
  }
  bool mutate_NumTokens(uint32_t _NumTokens = 0) {
    return SetField<uint32_t>(VT_NUMTOKENS, _NumTokens, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NUMTOKENS, 4) &&
           verifier.EndTable();
  }
  TBoWT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TBoWT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TBoW> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TBoWT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TBoWBuilder {
  typedef TBoW Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NumTokens(uint32_t NumTokens) {
    fbb_.AddElement<uint32_t>(TBoW::VT_NUMTOKENS, NumTokens, 0);
  }
  explicit TBoWBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TBoW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TBoW>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TBoW> CreateTBoW(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NumTokens = 0) {
  TBoWBuilder builder_(_fbb);
  builder_.add_NumTokens(NumTokens);
  return builder_.Finish();
}

::flatbuffers::Offset<TBoW> CreateTBoW(::flatbuffers::FlatBufferBuilder &_fbb, const TBoWT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TFeatureCalcerT : public ::flatbuffers::NativeTable {
  typedef TFeatureCalcer TableType;
  std::unique_ptr<NCatBoostFbs::TGuid> Id{};
  std::vector<uint32_t> ActiveFeatureIndices{};
  NCatBoostFbs::TAnyFeatureCalcerUnion FeatureCalcerImpl{};
  TFeatureCalcerT() = default;
  TFeatureCalcerT(const TFeatureCalcerT &o);
  TFeatureCalcerT(TFeatureCalcerT&&) FLATBUFFERS_NOEXCEPT = default;
  TFeatureCalcerT &operator=(TFeatureCalcerT o) FLATBUFFERS_NOEXCEPT;
};

struct TFeatureCalcer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TFeatureCalcerT NativeTableType;
  typedef TFeatureCalcerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ACTIVEFEATUREINDICES = 6,
    VT_FEATURECALCERIMPL_TYPE = 8,
    VT_FEATURECALCERIMPL = 10
  };
  const NCatBoostFbs::TGuid *Id() const {
    return GetStruct<const NCatBoostFbs::TGuid *>(VT_ID);
  }
  NCatBoostFbs::TGuid *mutable_Id() {
    return GetStruct<NCatBoostFbs::TGuid *>(VT_ID);
  }
  const ::flatbuffers::Vector<uint32_t> *ActiveFeatureIndices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ACTIVEFEATUREINDICES);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_ActiveFeatureIndices() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_ACTIVEFEATUREINDICES);
  }
  NCatBoostFbs::TAnyFeatureCalcer FeatureCalcerImpl_type() const {
    return static_cast<NCatBoostFbs::TAnyFeatureCalcer>(GetField<uint8_t>(VT_FEATURECALCERIMPL_TYPE, 0));
  }
  const void *FeatureCalcerImpl() const {
    return GetPointer<const void *>(VT_FEATURECALCERIMPL);
  }
  template<typename T> const T *FeatureCalcerImpl_as() const;
  const NCatBoostFbs::TBM25 *FeatureCalcerImpl_as_TBM25() const {
    return FeatureCalcerImpl_type() == NCatBoostFbs::TAnyFeatureCalcer_TBM25 ? static_cast<const NCatBoostFbs::TBM25 *>(FeatureCalcerImpl()) : nullptr;
  }
  const NCatBoostFbs::TNaiveBayes *FeatureCalcerImpl_as_TNaiveBayes() const {
    return FeatureCalcerImpl_type() == NCatBoostFbs::TAnyFeatureCalcer_TNaiveBayes ? static_cast<const NCatBoostFbs::TNaiveBayes *>(FeatureCalcerImpl()) : nullptr;
  }
  const NCatBoostFbs::TBoW *FeatureCalcerImpl_as_TBoW() const {
    return FeatureCalcerImpl_type() == NCatBoostFbs::TAnyFeatureCalcer_TBoW ? static_cast<const NCatBoostFbs::TBoW *>(FeatureCalcerImpl()) : nullptr;
  }
  void *mutable_FeatureCalcerImpl() {
    return GetPointer<void *>(VT_FEATURECALCERIMPL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<NCatBoostFbs::TGuid>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_ACTIVEFEATUREINDICES) &&
           verifier.VerifyVector(ActiveFeatureIndices()) &&
           VerifyField<uint8_t>(verifier, VT_FEATURECALCERIMPL_TYPE, 1) &&
           VerifyOffset(verifier, VT_FEATURECALCERIMPL) &&
           VerifyTAnyFeatureCalcer(verifier, FeatureCalcerImpl(), FeatureCalcerImpl_type()) &&
           verifier.EndTable();
  }
  TFeatureCalcerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TFeatureCalcerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TFeatureCalcer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCalcerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const NCatBoostFbs::TBM25 *TFeatureCalcer::FeatureCalcerImpl_as<NCatBoostFbs::TBM25>() const {
  return FeatureCalcerImpl_as_TBM25();
}

template<> inline const NCatBoostFbs::TNaiveBayes *TFeatureCalcer::FeatureCalcerImpl_as<NCatBoostFbs::TNaiveBayes>() const {
  return FeatureCalcerImpl_as_TNaiveBayes();
}

template<> inline const NCatBoostFbs::TBoW *TFeatureCalcer::FeatureCalcerImpl_as<NCatBoostFbs::TBoW>() const {
  return FeatureCalcerImpl_as_TBoW();
}

struct TFeatureCalcerBuilder {
  typedef TFeatureCalcer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(const NCatBoostFbs::TGuid *Id) {
    fbb_.AddStruct(TFeatureCalcer::VT_ID, Id);
  }
  void add_ActiveFeatureIndices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ActiveFeatureIndices) {
    fbb_.AddOffset(TFeatureCalcer::VT_ACTIVEFEATUREINDICES, ActiveFeatureIndices);
  }
  void add_FeatureCalcerImpl_type(NCatBoostFbs::TAnyFeatureCalcer FeatureCalcerImpl_type) {
    fbb_.AddElement<uint8_t>(TFeatureCalcer::VT_FEATURECALCERIMPL_TYPE, static_cast<uint8_t>(FeatureCalcerImpl_type), 0);
  }
  void add_FeatureCalcerImpl(::flatbuffers::Offset<void> FeatureCalcerImpl) {
    fbb_.AddOffset(TFeatureCalcer::VT_FEATURECALCERIMPL, FeatureCalcerImpl);
  }
  explicit TFeatureCalcerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TFeatureCalcer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TFeatureCalcer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TFeatureCalcer> CreateTFeatureCalcer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NCatBoostFbs::TGuid *Id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ActiveFeatureIndices = 0,
    NCatBoostFbs::TAnyFeatureCalcer FeatureCalcerImpl_type = NCatBoostFbs::TAnyFeatureCalcer_NONE,
    ::flatbuffers::Offset<void> FeatureCalcerImpl = 0) {
  TFeatureCalcerBuilder builder_(_fbb);
  builder_.add_FeatureCalcerImpl(FeatureCalcerImpl);
  builder_.add_ActiveFeatureIndices(ActiveFeatureIndices);
  builder_.add_Id(Id);
  builder_.add_FeatureCalcerImpl_type(FeatureCalcerImpl_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TFeatureCalcer> CreateTFeatureCalcerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NCatBoostFbs::TGuid *Id = nullptr,
    const std::vector<uint32_t> *ActiveFeatureIndices = nullptr,
    NCatBoostFbs::TAnyFeatureCalcer FeatureCalcerImpl_type = NCatBoostFbs::TAnyFeatureCalcer_NONE,
    ::flatbuffers::Offset<void> FeatureCalcerImpl = 0) {
  auto ActiveFeatureIndices__ = ActiveFeatureIndices ? _fbb.CreateVector<uint32_t>(*ActiveFeatureIndices) : 0;
  return NCatBoostFbs::CreateTFeatureCalcer(
      _fbb,
      Id,
      ActiveFeatureIndices__,
      FeatureCalcerImpl_type,
      FeatureCalcerImpl);
}

::flatbuffers::Offset<TFeatureCalcer> CreateTFeatureCalcer(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCalcerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TBM25T *TBM25::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TBM25T>(new TBM25T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TBM25::UnPackTo(TBM25T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = NumClasses(); _o->NumClasses = _e; }
  { auto _e = ParamK(); _o->ParamK = _e; }
  { auto _e = ParamB(); _o->ParamB = _e; }
  { auto _e = TruncateBorder(); _o->TruncateBorder = _e; }
  { auto _e = TotalTokens(); _o->TotalTokens = _e; }
  { auto _e = ClassTotalTokens(); if (_e) { _o->ClassTotalTokens.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ClassTotalTokens[_i] = _e->Get(_i); } } else { _o->ClassTotalTokens.resize(0); } }
}

inline ::flatbuffers::Offset<TBM25> TBM25::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TBM25T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTBM25(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TBM25> CreateTBM25(::flatbuffers::FlatBufferBuilder &_fbb, const TBM25T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TBM25T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _NumClasses = _o->NumClasses;
  auto _ParamK = _o->ParamK;
  auto _ParamB = _o->ParamB;
  auto _TruncateBorder = _o->TruncateBorder;
  auto _TotalTokens = _o->TotalTokens;
  auto _ClassTotalTokens = _o->ClassTotalTokens.size() ? _fbb.CreateVector(_o->ClassTotalTokens) : 0;
  return NCatBoostFbs::CreateTBM25(
      _fbb,
      _NumClasses,
      _ParamK,
      _ParamB,
      _TruncateBorder,
      _TotalTokens,
      _ClassTotalTokens);
}

inline TNaiveBayesT *TNaiveBayes::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TNaiveBayesT>(new TNaiveBayesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TNaiveBayes::UnPackTo(TNaiveBayesT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = NumClasses(); _o->NumClasses = _e; }
  { auto _e = ClassPrior(); _o->ClassPrior = _e; }
  { auto _e = TokenPrior(); _o->TokenPrior = _e; }
  { auto _e = NumSeenTokens(); _o->NumSeenTokens = _e; }
  { auto _e = ClassDocs(); if (_e) { _o->ClassDocs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ClassDocs[_i] = _e->Get(_i); } } else { _o->ClassDocs.resize(0); } }
  { auto _e = ClassTotalTokens(); if (_e) { _o->ClassTotalTokens.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ClassTotalTokens[_i] = _e->Get(_i); } } else { _o->ClassTotalTokens.resize(0); } }
}

inline ::flatbuffers::Offset<TNaiveBayes> TNaiveBayes::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TNaiveBayesT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTNaiveBayes(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TNaiveBayes> CreateTNaiveBayes(::flatbuffers::FlatBufferBuilder &_fbb, const TNaiveBayesT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TNaiveBayesT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _NumClasses = _o->NumClasses;
  auto _ClassPrior = _o->ClassPrior;
  auto _TokenPrior = _o->TokenPrior;
  auto _NumSeenTokens = _o->NumSeenTokens;
  auto _ClassDocs = _o->ClassDocs.size() ? _fbb.CreateVector(_o->ClassDocs) : 0;
  auto _ClassTotalTokens = _o->ClassTotalTokens.size() ? _fbb.CreateVector(_o->ClassTotalTokens) : 0;
  return NCatBoostFbs::CreateTNaiveBayes(
      _fbb,
      _NumClasses,
      _ClassPrior,
      _TokenPrior,
      _NumSeenTokens,
      _ClassDocs,
      _ClassTotalTokens);
}

inline TBoWT *TBoW::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TBoWT>(new TBoWT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TBoW::UnPackTo(TBoWT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = NumTokens(); _o->NumTokens = _e; }
}

inline ::flatbuffers::Offset<TBoW> TBoW::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TBoWT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTBoW(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TBoW> CreateTBoW(::flatbuffers::FlatBufferBuilder &_fbb, const TBoWT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TBoWT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _NumTokens = _o->NumTokens;
  return NCatBoostFbs::CreateTBoW(
      _fbb,
      _NumTokens);
}

inline TFeatureCalcerT::TFeatureCalcerT(const TFeatureCalcerT &o)
      : Id((o.Id) ? new NCatBoostFbs::TGuid(*o.Id) : nullptr),
        ActiveFeatureIndices(o.ActiveFeatureIndices),
        FeatureCalcerImpl(o.FeatureCalcerImpl) {
}

inline TFeatureCalcerT &TFeatureCalcerT::operator=(TFeatureCalcerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(ActiveFeatureIndices, o.ActiveFeatureIndices);
  std::swap(FeatureCalcerImpl, o.FeatureCalcerImpl);
  return *this;
}

inline TFeatureCalcerT *TFeatureCalcer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TFeatureCalcerT>(new TFeatureCalcerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TFeatureCalcer::UnPackTo(TFeatureCalcerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); if (_e) _o->Id = std::unique_ptr<NCatBoostFbs::TGuid>(new NCatBoostFbs::TGuid(*_e)); }
  { auto _e = ActiveFeatureIndices(); if (_e) { _o->ActiveFeatureIndices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ActiveFeatureIndices[_i] = _e->Get(_i); } } else { _o->ActiveFeatureIndices.resize(0); } }
  { auto _e = FeatureCalcerImpl_type(); _o->FeatureCalcerImpl.type = _e; }
  { auto _e = FeatureCalcerImpl(); if (_e) _o->FeatureCalcerImpl.value = NCatBoostFbs::TAnyFeatureCalcerUnion::UnPack(_e, FeatureCalcerImpl_type(), _resolver); }
}

inline ::flatbuffers::Offset<TFeatureCalcer> TFeatureCalcer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCalcerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTFeatureCalcer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TFeatureCalcer> CreateTFeatureCalcer(::flatbuffers::FlatBufferBuilder &_fbb, const TFeatureCalcerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TFeatureCalcerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id ? _o->Id.get() : nullptr;
  auto _ActiveFeatureIndices = _o->ActiveFeatureIndices.size() ? _fbb.CreateVector(_o->ActiveFeatureIndices) : 0;
  auto _FeatureCalcerImpl_type = _o->FeatureCalcerImpl.type;
  auto _FeatureCalcerImpl = _o->FeatureCalcerImpl.Pack(_fbb);
  return NCatBoostFbs::CreateTFeatureCalcer(
      _fbb,
      _Id,
      _ActiveFeatureIndices,
      _FeatureCalcerImpl_type,
      _FeatureCalcerImpl);
}

inline bool VerifyTAnyFeatureCalcer(::flatbuffers::Verifier &verifier, const void *obj, TAnyFeatureCalcer type) {
  switch (type) {
    case TAnyFeatureCalcer_NONE: {
      return true;
    }
    case TAnyFeatureCalcer_TBM25: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TBM25 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TAnyFeatureCalcer_TNaiveBayes: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TNaiveBayes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TAnyFeatureCalcer_TBoW: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TBoW *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTAnyFeatureCalcerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTAnyFeatureCalcer(
        verifier,  values->Get(i), types->GetEnum<TAnyFeatureCalcer>(i))) {
      return false;
    }
  }
  return true;
}

inline void *TAnyFeatureCalcerUnion::UnPack(const void *obj, TAnyFeatureCalcer type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case TAnyFeatureCalcer_TBM25: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TBM25 *>(obj);
      return ptr->UnPack(resolver);
    }
    case TAnyFeatureCalcer_TNaiveBayes: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TNaiveBayes *>(obj);
      return ptr->UnPack(resolver);
    }
    case TAnyFeatureCalcer_TBoW: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TBoW *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> TAnyFeatureCalcerUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case TAnyFeatureCalcer_TBM25: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TBM25T *>(value);
      return CreateTBM25(_fbb, ptr, _rehasher).Union();
    }
    case TAnyFeatureCalcer_TNaiveBayes: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TNaiveBayesT *>(value);
      return CreateTNaiveBayes(_fbb, ptr, _rehasher).Union();
    }
    case TAnyFeatureCalcer_TBoW: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::TBoWT *>(value);
      return CreateTBoW(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline TAnyFeatureCalcerUnion::TAnyFeatureCalcerUnion(const TAnyFeatureCalcerUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case TAnyFeatureCalcer_TBM25: {
      value = new NCatBoostFbs::TBM25T(*reinterpret_cast<NCatBoostFbs::TBM25T *>(u.value));
      break;
    }
    case TAnyFeatureCalcer_TNaiveBayes: {
      value = new NCatBoostFbs::TNaiveBayesT(*reinterpret_cast<NCatBoostFbs::TNaiveBayesT *>(u.value));
      break;
    }
    case TAnyFeatureCalcer_TBoW: {
      value = new NCatBoostFbs::TBoWT(*reinterpret_cast<NCatBoostFbs::TBoWT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void TAnyFeatureCalcerUnion::Reset() {
  switch (type) {
    case TAnyFeatureCalcer_TBM25: {
      auto ptr = reinterpret_cast<NCatBoostFbs::TBM25T *>(value);
      delete ptr;
      break;
    }
    case TAnyFeatureCalcer_TNaiveBayes: {
      auto ptr = reinterpret_cast<NCatBoostFbs::TNaiveBayesT *>(value);
      delete ptr;
      break;
    }
    case TAnyFeatureCalcer_TBoW: {
      auto ptr = reinterpret_cast<NCatBoostFbs::TBoWT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = TAnyFeatureCalcer_NONE;
}

inline const NCatBoostFbs::TFeatureCalcer *GetTFeatureCalcer(const void *buf) {
  return ::flatbuffers::GetRoot<NCatBoostFbs::TFeatureCalcer>(buf);
}

inline const NCatBoostFbs::TFeatureCalcer *GetSizePrefixedTFeatureCalcer(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::TFeatureCalcer>(buf);
}

inline TFeatureCalcer *GetMutableTFeatureCalcer(void *buf) {
  return ::flatbuffers::GetMutableRoot<TFeatureCalcer>(buf);
}

inline NCatBoostFbs::TFeatureCalcer *GetMutableSizePrefixedTFeatureCalcer(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NCatBoostFbs::TFeatureCalcer>(buf);
}

inline bool VerifyTFeatureCalcerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::TFeatureCalcer>(nullptr);
}

inline bool VerifySizePrefixedTFeatureCalcerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::TFeatureCalcer>(nullptr);
}

inline const char *TFeatureCalcerExtension() {
  return "bfbs";
}

inline void FinishTFeatureCalcerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TFeatureCalcer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTFeatureCalcerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TFeatureCalcer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NCatBoostFbs::TFeatureCalcerT> UnPackTFeatureCalcer(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TFeatureCalcerT>(GetTFeatureCalcer(buf)->UnPack(res));
}

inline std::unique_ptr<NCatBoostFbs::TFeatureCalcerT> UnPackSizePrefixedTFeatureCalcer(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TFeatureCalcerT>(GetSizePrefixedTFeatureCalcer(buf)->UnPack(res));
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_FEATURECALCERS_NCATBOOSTFBS_H_
