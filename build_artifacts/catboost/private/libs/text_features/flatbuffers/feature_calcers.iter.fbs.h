// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FEATURECALCERS_NCATBOOSTFBS_ITER_H_
#define FLATBUFFERS_GENERATED_FEATURECALCERS_NCATBOOSTFBS_ITER_H_

#include "feature_calcers.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

#include "catboost/libs/helpers/flatbuffers/guid.iter.fbs.h"

namespace NCatBoostFbs {
namespace iter {

template <typename Iter>
struct TBM25;

template <typename Iter>
struct TNaiveBayes;

template <typename Iter>
struct TBoW;

template <typename Iter>
struct TFeatureCalcer;

template <typename Iter>
struct TBM25 FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_NUMCLASSES = 4,
    VT_PARAMK = 6,
    VT_PARAMB = 8,
    VT_TRUNCATEBORDER = 10,
    VT_TOTALTOKENS = 12,
    VT_CLASSTOTALTOKENS = 14
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  uint32_t NumClasses() const {
    return this->template GetField<uint32_t>(VT_NUMCLASSES, 0);
  }
  float ParamK() const {
    return this->template GetField<float>(VT_PARAMK, 0.0f);
  }
  float ParamB() const {
    return this->template GetField<float>(VT_PARAMB, 0.0f);
  }
  float TruncateBorder() const {
    return this->template GetField<float>(VT_TRUNCATEBORDER, 0.0f);
  }
  uint64_t TotalTokens() const {
    return this->template GetField<uint64_t>(VT_TOTALTOKENS, 0);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint64_t, Iter>> ClassTotalTokens() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint64_t, Iter>>(VT_CLASSTOTALTOKENS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<uint32_t>(verifier, VT_NUMCLASSES, 4) &&
           this->template VerifyField<float>(verifier, VT_PARAMK, 4) &&
           this->template VerifyField<float>(verifier, VT_PARAMB, 4) &&
           this->template VerifyField<float>(verifier, VT_TRUNCATEBORDER, 4) &&
           this->template VerifyField<uint64_t>(verifier, VT_TOTALTOKENS, 8) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CLASSTOTALTOKENS) &&
           verifier.Verify(ClassTotalTokens()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TNaiveBayes FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_NUMCLASSES = 4,
    VT_CLASSPRIOR = 6,
    VT_TOKENPRIOR = 8,
    VT_NUMSEENTOKENS = 10,
    VT_CLASSDOCS = 12,
    VT_CLASSTOTALTOKENS = 14
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  uint32_t NumClasses() const {
    return this->template GetField<uint32_t>(VT_NUMCLASSES, 0);
  }
  float ClassPrior() const {
    return this->template GetField<float>(VT_CLASSPRIOR, 0.0f);
  }
  float TokenPrior() const {
    return this->template GetField<float>(VT_TOKENPRIOR, 0.0f);
  }
  uint64_t NumSeenTokens() const {
    return this->template GetField<uint64_t>(VT_NUMSEENTOKENS, 0);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>> ClassDocs() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>>(VT_CLASSDOCS);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint64_t, Iter>> ClassTotalTokens() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint64_t, Iter>>(VT_CLASSTOTALTOKENS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<uint32_t>(verifier, VT_NUMCLASSES, 4) &&
           this->template VerifyField<float>(verifier, VT_CLASSPRIOR, 4) &&
           this->template VerifyField<float>(verifier, VT_TOKENPRIOR, 4) &&
           this->template VerifyField<uint64_t>(verifier, VT_NUMSEENTOKENS, 8) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CLASSDOCS) &&
           verifier.Verify(ClassDocs()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CLASSTOTALTOKENS) &&
           verifier.Verify(ClassTotalTokens()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TBoW FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_NUMTOKENS = 4
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  uint32_t NumTokens() const {
    return this->template GetField<uint32_t>(VT_NUMTOKENS, 0);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<uint32_t>(verifier, VT_NUMTOKENS, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TFeatureCalcer FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_ID = 4,
    VT_ACTIVEFEATUREINDICES = 6,
    VT_FEATURECALCERIMPL_TYPE = 8,
    VT_FEATURECALCERIMPL = 10
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<TGuid> Id() const {
    return this->template GetStruct<TGuid>(VT_ID);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>> ActiveFeatureIndices() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>>(VT_ACTIVEFEATUREINDICES);
  }
  TAnyFeatureCalcer FeatureCalcerImpl_type() const {
    return static_cast<TAnyFeatureCalcer>(this->template GetField<uint8_t>(VT_FEATURECALCERIMPL_TYPE, 0));
  }
  std::optional<void> FeatureCalcerImpl() const {
    return this->template GetPointer<void>(VT_FEATURECALCERIMPL);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<TGuid>(verifier, VT_ID, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_ACTIVEFEATUREINDICES) &&
           verifier.Verify(ActiveFeatureIndices()) &&
           this->template VerifyField<uint8_t>(verifier, VT_FEATURECALCERIMPL_TYPE, 1) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATURECALCERIMPL) &&
           VerifyTAnyFeatureCalcer(verifier, FeatureCalcerImpl(), FeatureCalcerImpl_type()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
inline std::optional<NCatBoostFbs::iter::TFeatureCalcer<Iter>> GetTFeatureCalcer(const Iter& buf) {
  return yandex::maps::flatbuffers_iter::GetRoot<NCatBoostFbs::iter::TFeatureCalcer<Iter>, Iter>(buf);
}

inline const NCatBoostFbs::TFeatureCalcer *GetTFeatureCalcer(const char *buf) {
  return NCatBoostFbs::GetTFeatureCalcer(buf);
}

template <typename Iter>
inline bool VerifyTFeatureCalcerBuffer(
    yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) {
  return verifier.template VerifyBuffer<NCatBoostFbs::iter::TFeatureCalcer<Iter>>(nullptr);
}

inline const char *TFeatureCalcerExtension() {
  return "bfbs";
}

}  // namespace iter
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_FEATURECALCERS_NCATBOOSTFBS_ITER_H_
