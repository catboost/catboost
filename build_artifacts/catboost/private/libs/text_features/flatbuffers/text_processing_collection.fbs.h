// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTPROCESSINGCOLLECTION_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_TEXTPROCESSINGCOLLECTION_NCATBOOSTFBS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/helpers/flatbuffers/guid.fbs.h"

namespace NCatBoostFbs {

struct AdjacencyList;
struct AdjacencyListBuilder;
struct AdjacencyListT;

struct TCollectionHeader;
struct TCollectionHeaderBuilder;
struct TCollectionHeaderT;

struct TCollectionPart;
struct TCollectionPartBuilder;
struct TCollectionPartT;

enum EPartType : uint8_t {
  EPartType_Tokenizer = 0,
  EPartType_Dictionary = 1,
  EPartType_FeatureCalcer = 2,
  EPartType_Terminate = 3,
  EPartType_MIN = EPartType_Tokenizer,
  EPartType_MAX = EPartType_Terminate
};

inline const EPartType (&EnumValuesEPartType())[4] {
  static const EPartType values[] = {
    EPartType_Tokenizer,
    EPartType_Dictionary,
    EPartType_FeatureCalcer,
    EPartType_Terminate
  };
  return values;
}

inline const char * const *EnumNamesEPartType() {
  static const char * const names[5] = {
    "Tokenizer",
    "Dictionary",
    "FeatureCalcer",
    "Terminate",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartType(EPartType e) {
  if (::flatbuffers::IsOutRange(e, EPartType_Tokenizer, EPartType_Terminate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartType()[index];
}

struct AdjacencyListT : public ::flatbuffers::NativeTable {
  typedef AdjacencyList TableType;
  std::vector<uint32_t> Ids{};
};

struct AdjacencyList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AdjacencyListT NativeTableType;
  typedef AdjacencyListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDS = 4
  };
  const ::flatbuffers::Vector<uint32_t> *Ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_IDS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_Ids() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDS) &&
           verifier.VerifyVector(Ids()) &&
           verifier.EndTable();
  }
  AdjacencyListT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdjacencyListT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AdjacencyList> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdjacencyListBuilder {
  typedef AdjacencyList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Ids(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> Ids) {
    fbb_.AddOffset(AdjacencyList::VT_IDS, Ids);
  }
  explicit AdjacencyListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AdjacencyList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AdjacencyList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AdjacencyList> CreateAdjacencyList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> Ids = 0) {
  AdjacencyListBuilder builder_(_fbb);
  builder_.add_Ids(Ids);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AdjacencyList> CreateAdjacencyListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *Ids = nullptr) {
  auto Ids__ = Ids ? _fbb.CreateVector<uint32_t>(*Ids) : 0;
  return NCatBoostFbs::CreateAdjacencyList(
      _fbb,
      Ids__);
}

::flatbuffers::Offset<AdjacencyList> CreateAdjacencyList(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCollectionHeaderT : public ::flatbuffers::NativeTable {
  typedef TCollectionHeader TableType;
  std::vector<NCatBoostFbs::TGuid> TokenizerId{};
  std::vector<NCatBoostFbs::TGuid> DictionaryId{};
  std::vector<NCatBoostFbs::TGuid> CalcerId{};
  std::vector<std::unique_ptr<NCatBoostFbs::AdjacencyListT>> PerFeatureDigitizers{};
  std::vector<std::unique_ptr<NCatBoostFbs::AdjacencyListT>> PerTokenizedFeatureCalcers{};
  TCollectionHeaderT() = default;
  TCollectionHeaderT(const TCollectionHeaderT &o);
  TCollectionHeaderT(TCollectionHeaderT&&) FLATBUFFERS_NOEXCEPT = default;
  TCollectionHeaderT &operator=(TCollectionHeaderT o) FLATBUFFERS_NOEXCEPT;
};

struct TCollectionHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCollectionHeaderT NativeTableType;
  typedef TCollectionHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENIZERID = 4,
    VT_DICTIONARYID = 6,
    VT_CALCERID = 8,
    VT_PERFEATUREDIGITIZERS = 10,
    VT_PERTOKENIZEDFEATURECALCERS = 12
  };
  const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *TokenizerId() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_TOKENIZERID);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *mutable_TokenizerId() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_TOKENIZERID);
  }
  const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *DictionaryId() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_DICTIONARYID);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *mutable_DictionaryId() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_DICTIONARYID);
  }
  const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *CalcerId() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_CALCERID);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *mutable_CalcerId() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_CALCERID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *PerFeatureDigitizers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *>(VT_PERFEATUREDIGITIZERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *mutable_PerFeatureDigitizers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *>(VT_PERFEATUREDIGITIZERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *PerTokenizedFeatureCalcers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *>(VT_PERTOKENIZEDFEATURECALCERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *mutable_PerTokenizedFeatureCalcers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *>(VT_PERTOKENIZEDFEATURECALCERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKENIZERID) &&
           verifier.VerifyVector(TokenizerId()) &&
           VerifyOffset(verifier, VT_DICTIONARYID) &&
           verifier.VerifyVector(DictionaryId()) &&
           VerifyOffset(verifier, VT_CALCERID) &&
           verifier.VerifyVector(CalcerId()) &&
           VerifyOffset(verifier, VT_PERFEATUREDIGITIZERS) &&
           verifier.VerifyVector(PerFeatureDigitizers()) &&
           verifier.VerifyVectorOfTables(PerFeatureDigitizers()) &&
           VerifyOffset(verifier, VT_PERTOKENIZEDFEATURECALCERS) &&
           verifier.VerifyVector(PerTokenizedFeatureCalcers()) &&
           verifier.VerifyVectorOfTables(PerTokenizedFeatureCalcers()) &&
           verifier.EndTable();
  }
  TCollectionHeaderT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCollectionHeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCollectionHeader> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCollectionHeaderBuilder {
  typedef TCollectionHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TokenizerId(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> TokenizerId) {
    fbb_.AddOffset(TCollectionHeader::VT_TOKENIZERID, TokenizerId);
  }
  void add_DictionaryId(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> DictionaryId) {
    fbb_.AddOffset(TCollectionHeader::VT_DICTIONARYID, DictionaryId);
  }
  void add_CalcerId(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> CalcerId) {
    fbb_.AddOffset(TCollectionHeader::VT_CALCERID, CalcerId);
  }
  void add_PerFeatureDigitizers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>>> PerFeatureDigitizers) {
    fbb_.AddOffset(TCollectionHeader::VT_PERFEATUREDIGITIZERS, PerFeatureDigitizers);
  }
  void add_PerTokenizedFeatureCalcers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>>> PerTokenizedFeatureCalcers) {
    fbb_.AddOffset(TCollectionHeader::VT_PERTOKENIZEDFEATURECALCERS, PerTokenizedFeatureCalcers);
  }
  explicit TCollectionHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCollectionHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCollectionHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> TokenizerId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> DictionaryId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> CalcerId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>>> PerFeatureDigitizers = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>>> PerTokenizedFeatureCalcers = 0) {
  TCollectionHeaderBuilder builder_(_fbb);
  builder_.add_PerTokenizedFeatureCalcers(PerTokenizedFeatureCalcers);
  builder_.add_PerFeatureDigitizers(PerFeatureDigitizers);
  builder_.add_CalcerId(CalcerId);
  builder_.add_DictionaryId(DictionaryId);
  builder_.add_TokenizerId(TokenizerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<NCatBoostFbs::TGuid> *TokenizerId = nullptr,
    const std::vector<NCatBoostFbs::TGuid> *DictionaryId = nullptr,
    const std::vector<NCatBoostFbs::TGuid> *CalcerId = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *PerFeatureDigitizers = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> *PerTokenizedFeatureCalcers = nullptr) {
  auto TokenizerId__ = TokenizerId ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TGuid>(*TokenizerId) : 0;
  auto DictionaryId__ = DictionaryId ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TGuid>(*DictionaryId) : 0;
  auto CalcerId__ = CalcerId ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TGuid>(*CalcerId) : 0;
  auto PerFeatureDigitizers__ = PerFeatureDigitizers ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>>(*PerFeatureDigitizers) : 0;
  auto PerTokenizedFeatureCalcers__ = PerTokenizedFeatureCalcers ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>>(*PerTokenizedFeatureCalcers) : 0;
  return NCatBoostFbs::CreateTCollectionHeader(
      _fbb,
      TokenizerId__,
      DictionaryId__,
      CalcerId__,
      PerFeatureDigitizers__,
      PerTokenizedFeatureCalcers__);
}

::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeader(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCollectionPartT : public ::flatbuffers::NativeTable {
  typedef TCollectionPart TableType;
  NCatBoostFbs::EPartType PartType = NCatBoostFbs::EPartType_Tokenizer;
  std::unique_ptr<NCatBoostFbs::TGuid> Id{};
  TCollectionPartT() = default;
  TCollectionPartT(const TCollectionPartT &o);
  TCollectionPartT(TCollectionPartT&&) FLATBUFFERS_NOEXCEPT = default;
  TCollectionPartT &operator=(TCollectionPartT o) FLATBUFFERS_NOEXCEPT;
};

struct TCollectionPart FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCollectionPartT NativeTableType;
  typedef TCollectionPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTTYPE = 4,
    VT_ID = 6
  };
  NCatBoostFbs::EPartType PartType() const {
    return static_cast<NCatBoostFbs::EPartType>(GetField<uint8_t>(VT_PARTTYPE, 0));
  }
  bool mutate_PartType(NCatBoostFbs::EPartType _PartType = static_cast<NCatBoostFbs::EPartType>(0)) {
    return SetField<uint8_t>(VT_PARTTYPE, static_cast<uint8_t>(_PartType), 0);
  }
  const NCatBoostFbs::TGuid *Id() const {
    return GetStruct<const NCatBoostFbs::TGuid *>(VT_ID);
  }
  NCatBoostFbs::TGuid *mutable_Id() {
    return GetStruct<NCatBoostFbs::TGuid *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARTTYPE, 1) &&
           VerifyField<NCatBoostFbs::TGuid>(verifier, VT_ID, 4) &&
           verifier.EndTable();
  }
  TCollectionPartT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCollectionPartT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCollectionPart> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCollectionPartBuilder {
  typedef TCollectionPart Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PartType(NCatBoostFbs::EPartType PartType) {
    fbb_.AddElement<uint8_t>(TCollectionPart::VT_PARTTYPE, static_cast<uint8_t>(PartType), 0);
  }
  void add_Id(const NCatBoostFbs::TGuid *Id) {
    fbb_.AddStruct(TCollectionPart::VT_ID, Id);
  }
  explicit TCollectionPartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCollectionPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCollectionPart>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCollectionPart> CreateTCollectionPart(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NCatBoostFbs::EPartType PartType = NCatBoostFbs::EPartType_Tokenizer,
    const NCatBoostFbs::TGuid *Id = nullptr) {
  TCollectionPartBuilder builder_(_fbb);
  builder_.add_Id(Id);
  builder_.add_PartType(PartType);
  return builder_.Finish();
}

::flatbuffers::Offset<TCollectionPart> CreateTCollectionPart(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AdjacencyListT *AdjacencyList::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdjacencyListT>(new AdjacencyListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AdjacencyList::UnPackTo(AdjacencyListT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Ids(); if (_e) { _o->Ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Ids[_i] = _e->Get(_i); } } else { _o->Ids.resize(0); } }
}

inline ::flatbuffers::Offset<AdjacencyList> AdjacencyList::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdjacencyList(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AdjacencyList> CreateAdjacencyList(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AdjacencyListT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Ids = _o->Ids.size() ? _fbb.CreateVector(_o->Ids) : 0;
  return NCatBoostFbs::CreateAdjacencyList(
      _fbb,
      _Ids);
}

inline TCollectionHeaderT::TCollectionHeaderT(const TCollectionHeaderT &o)
      : TokenizerId(o.TokenizerId),
        DictionaryId(o.DictionaryId),
        CalcerId(o.CalcerId) {
  PerFeatureDigitizers.reserve(o.PerFeatureDigitizers.size());
  for (const auto &PerFeatureDigitizers_ : o.PerFeatureDigitizers) { PerFeatureDigitizers.emplace_back((PerFeatureDigitizers_) ? new NCatBoostFbs::AdjacencyListT(*PerFeatureDigitizers_) : nullptr); }
  PerTokenizedFeatureCalcers.reserve(o.PerTokenizedFeatureCalcers.size());
  for (const auto &PerTokenizedFeatureCalcers_ : o.PerTokenizedFeatureCalcers) { PerTokenizedFeatureCalcers.emplace_back((PerTokenizedFeatureCalcers_) ? new NCatBoostFbs::AdjacencyListT(*PerTokenizedFeatureCalcers_) : nullptr); }
}

inline TCollectionHeaderT &TCollectionHeaderT::operator=(TCollectionHeaderT o) FLATBUFFERS_NOEXCEPT {
  std::swap(TokenizerId, o.TokenizerId);
  std::swap(DictionaryId, o.DictionaryId);
  std::swap(CalcerId, o.CalcerId);
  std::swap(PerFeatureDigitizers, o.PerFeatureDigitizers);
  std::swap(PerTokenizedFeatureCalcers, o.PerTokenizedFeatureCalcers);
  return *this;
}

inline TCollectionHeaderT *TCollectionHeader::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCollectionHeaderT>(new TCollectionHeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCollectionHeader::UnPackTo(TCollectionHeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = TokenizerId(); if (_e) { _o->TokenizerId.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->TokenizerId[_i] = *_e->Get(_i); } } else { _o->TokenizerId.resize(0); } }
  { auto _e = DictionaryId(); if (_e) { _o->DictionaryId.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->DictionaryId[_i] = *_e->Get(_i); } } else { _o->DictionaryId.resize(0); } }
  { auto _e = CalcerId(); if (_e) { _o->CalcerId.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->CalcerId[_i] = *_e->Get(_i); } } else { _o->CalcerId.resize(0); } }
  { auto _e = PerFeatureDigitizers(); if (_e) { _o->PerFeatureDigitizers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->PerFeatureDigitizers[_i]) { _e->Get(_i)->UnPackTo(_o->PerFeatureDigitizers[_i].get(), _resolver); } else { _o->PerFeatureDigitizers[_i] = std::unique_ptr<NCatBoostFbs::AdjacencyListT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->PerFeatureDigitizers.resize(0); } }
  { auto _e = PerTokenizedFeatureCalcers(); if (_e) { _o->PerTokenizedFeatureCalcers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->PerTokenizedFeatureCalcers[_i]) { _e->Get(_i)->UnPackTo(_o->PerTokenizedFeatureCalcers[_i].get(), _resolver); } else { _o->PerTokenizedFeatureCalcers[_i] = std::unique_ptr<NCatBoostFbs::AdjacencyListT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->PerTokenizedFeatureCalcers.resize(0); } }
}

inline ::flatbuffers::Offset<TCollectionHeader> TCollectionHeader::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCollectionHeader(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeader(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCollectionHeaderT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _TokenizerId = _o->TokenizerId.size() ? _fbb.CreateVectorOfStructs(_o->TokenizerId) : 0;
  auto _DictionaryId = _o->DictionaryId.size() ? _fbb.CreateVectorOfStructs(_o->DictionaryId) : 0;
  auto _CalcerId = _o->CalcerId.size() ? _fbb.CreateVectorOfStructs(_o->CalcerId) : 0;
  auto _PerFeatureDigitizers = _o->PerFeatureDigitizers.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> (_o->PerFeatureDigitizers.size(), [](size_t i, _VectorArgs *__va) { return CreateAdjacencyList(*__va->__fbb, __va->__o->PerFeatureDigitizers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _PerTokenizedFeatureCalcers = _o->PerTokenizedFeatureCalcers.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::AdjacencyList>> (_o->PerTokenizedFeatureCalcers.size(), [](size_t i, _VectorArgs *__va) { return CreateAdjacencyList(*__va->__fbb, __va->__o->PerTokenizedFeatureCalcers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NCatBoostFbs::CreateTCollectionHeader(
      _fbb,
      _TokenizerId,
      _DictionaryId,
      _CalcerId,
      _PerFeatureDigitizers,
      _PerTokenizedFeatureCalcers);
}

inline TCollectionPartT::TCollectionPartT(const TCollectionPartT &o)
      : PartType(o.PartType),
        Id((o.Id) ? new NCatBoostFbs::TGuid(*o.Id) : nullptr) {
}

inline TCollectionPartT &TCollectionPartT::operator=(TCollectionPartT o) FLATBUFFERS_NOEXCEPT {
  std::swap(PartType, o.PartType);
  std::swap(Id, o.Id);
  return *this;
}

inline TCollectionPartT *TCollectionPart::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCollectionPartT>(new TCollectionPartT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCollectionPart::UnPackTo(TCollectionPartT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = PartType(); _o->PartType = _e; }
  { auto _e = Id(); if (_e) _o->Id = std::unique_ptr<NCatBoostFbs::TGuid>(new NCatBoostFbs::TGuid(*_e)); }
}

inline ::flatbuffers::Offset<TCollectionPart> TCollectionPart::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCollectionPart(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCollectionPart> CreateTCollectionPart(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCollectionPartT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _PartType = _o->PartType;
  auto _Id = _o->Id ? _o->Id.get() : nullptr;
  return NCatBoostFbs::CreateTCollectionPart(
      _fbb,
      _PartType,
      _Id);
}

inline const NCatBoostFbs::TCollectionPart *GetTCollectionPart(const void *buf) {
  return ::flatbuffers::GetRoot<NCatBoostFbs::TCollectionPart>(buf);
}

inline const NCatBoostFbs::TCollectionPart *GetSizePrefixedTCollectionPart(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::TCollectionPart>(buf);
}

inline TCollectionPart *GetMutableTCollectionPart(void *buf) {
  return ::flatbuffers::GetMutableRoot<TCollectionPart>(buf);
}

inline NCatBoostFbs::TCollectionPart *GetMutableSizePrefixedTCollectionPart(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NCatBoostFbs::TCollectionPart>(buf);
}

inline bool VerifyTCollectionPartBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::TCollectionPart>(nullptr);
}

inline bool VerifySizePrefixedTCollectionPartBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::TCollectionPart>(nullptr);
}

inline const char *TCollectionPartExtension() {
  return "bfbs";
}

inline void FinishTCollectionPartBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TCollectionPart> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTCollectionPartBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::TCollectionPart> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NCatBoostFbs::TCollectionPartT> UnPackTCollectionPart(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TCollectionPartT>(GetTCollectionPart(buf)->UnPack(res));
}

inline std::unique_ptr<NCatBoostFbs::TCollectionPartT> UnPackSizePrefixedTCollectionPart(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::TCollectionPartT>(GetSizePrefixedTCollectionPart(buf)->UnPack(res));
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_TEXTPROCESSINGCOLLECTION_NCATBOOSTFBS_H_
