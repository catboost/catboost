// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMBEDDINGFEATURECALCERS_NCATBOOSTFBS_NEMBEDDINGS_ITER_H_
#define FLATBUFFERS_GENERATED_EMBEDDINGFEATURECALCERS_NCATBOOSTFBS_NEMBEDDINGS_ITER_H_

#include "embedding_feature_calcers.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

#include "catboost/libs/helpers/flatbuffers/guid.iter.fbs.h"

namespace NCatBoostFbs {
namespace NEmbeddings {
namespace iter {

template <typename Iter>
struct TLDA;

template <typename Iter>
struct TKNN;

template <typename Iter>
struct TEmbeddingCalcer;

template <typename Iter>
struct TLDA FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_TOTALDIMENSION = 4,
    VT_NUMCLASSES = 6,
    VT_PROJECTIONDIMENSION = 8,
    VT_COMPUTEPROBABILITIES = 10,
    VT_PROJECTIONMATRIX = 12,
    VT_ISCLASSIFICATION = 14
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t TotalDimension() const {
    return this->template GetField<int32_t>(VT_TOTALDIMENSION, 0);
  }
  int32_t NumClasses() const {
    return this->template GetField<int32_t>(VT_NUMCLASSES, 0);
  }
  int32_t ProjectionDimension() const {
    return this->template GetField<int32_t>(VT_PROJECTIONDIMENSION, 0);
  }
  bool ComputeProbabilities() const {
    return this->template GetField<uint8_t>(VT_COMPUTEPROBABILITIES, 0) != 0;
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<float, Iter>> ProjectionMatrix() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<float, Iter>>(VT_PROJECTIONMATRIX);
  }
  bool IsClassification() const {
    return this->template GetField<uint8_t>(VT_ISCLASSIFICATION, 1) != 0;
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_TOTALDIMENSION, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_NUMCLASSES, 4) &&
           this->template VerifyField<int32_t>(verifier, VT_PROJECTIONDIMENSION, 4) &&
           this->template VerifyField<uint8_t>(verifier, VT_COMPUTEPROBABILITIES, 1) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_PROJECTIONMATRIX) &&
           verifier.Verify(ProjectionMatrix()) &&
           this->template VerifyField<uint8_t>(verifier, VT_ISCLASSIFICATION, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TKNN FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_TOTALDIMENSION = 4,
    VT_NUMCLASSES = 6,
    VT_KNUM = 8,
    VT_SIZE = 10,
    VT_ISCLASSIFICATION = 12
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  int32_t TotalDimension() const {
    return this->template GetField<int32_t>(VT_TOTALDIMENSION, 0);
  }
  uint32_t NumClasses() const {
    return this->template GetField<uint32_t>(VT_NUMCLASSES, 0);
  }
  uint32_t KNum() const {
    return this->template GetField<uint32_t>(VT_KNUM, 0);
  }
  uint32_t Size() const {
    return this->template GetField<uint32_t>(VT_SIZE, 0);
  }
  bool IsClassification() const {
    return this->template GetField<uint8_t>(VT_ISCLASSIFICATION, 1) != 0;
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<int32_t>(verifier, VT_TOTALDIMENSION, 4) &&
           this->template VerifyField<uint32_t>(verifier, VT_NUMCLASSES, 4) &&
           this->template VerifyField<uint32_t>(verifier, VT_KNUM, 4) &&
           this->template VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           this->template VerifyField<uint8_t>(verifier, VT_ISCLASSIFICATION, 1) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TEmbeddingCalcer FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_ID = 4,
    VT_ACTIVEFEATUREINDICES = 6,
    VT_FEATURECALCERIMPL_TYPE = 8,
    VT_FEATURECALCERIMPL = 10
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<NCatBoostFbs::TGuid> Id() const {
    return this->template GetStruct<NCatBoostFbs::TGuid>(VT_ID);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>> ActiveFeatureIndices() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>>(VT_ACTIVEFEATUREINDICES);
  }
  TAnyEmbeddingCalcer FeatureCalcerImpl_type() const {
    return static_cast<TAnyEmbeddingCalcer>(this->template GetField<uint8_t>(VT_FEATURECALCERIMPL_TYPE, 0));
  }
  std::optional<void> FeatureCalcerImpl() const {
    return this->template GetPointer<void>(VT_FEATURECALCERIMPL);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<NCatBoostFbs::TGuid>(verifier, VT_ID, 4) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_ACTIVEFEATUREINDICES) &&
           verifier.Verify(ActiveFeatureIndices()) &&
           this->template VerifyField<uint8_t>(verifier, VT_FEATURECALCERIMPL_TYPE, 1) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_FEATURECALCERIMPL) &&
           VerifyTAnyEmbeddingCalcer(verifier, FeatureCalcerImpl(), FeatureCalcerImpl_type()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
inline std::optional<NCatBoostFbs::NEmbeddings::iter::TEmbeddingCalcer<Iter>> GetTEmbeddingCalcer(const Iter& buf) {
  return yandex::maps::flatbuffers_iter::GetRoot<NCatBoostFbs::NEmbeddings::iter::TEmbeddingCalcer<Iter>, Iter>(buf);
}

inline const NCatBoostFbs::NEmbeddings::TEmbeddingCalcer *GetTEmbeddingCalcer(const char *buf) {
  return NCatBoostFbs::NEmbeddings::GetTEmbeddingCalcer(buf);
}

template <typename Iter>
inline bool VerifyTEmbeddingCalcerBuffer(
    yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) {
  return verifier.template VerifyBuffer<NCatBoostFbs::NEmbeddings::iter::TEmbeddingCalcer<Iter>>(nullptr);
}

inline const char *TEmbeddingCalcerExtension() {
  return "bfbs";
}

}  // namespace iter
}  // namespace NEmbeddings
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_EMBEDDINGFEATURECALCERS_NCATBOOSTFBS_NEMBEDDINGS_ITER_H_
