// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMBEDDINGPROCESSINGCOLLECTION_NCATBOOSTFBS_NEMBEDDINGS_ITER_H_
#define FLATBUFFERS_GENERATED_EMBEDDINGPROCESSINGCOLLECTION_NCATBOOSTFBS_NEMBEDDINGS_ITER_H_

#include "embedding_processing_collection.fbs.h"
#include "contrib/libs/flatbuffers/include/flatbuffers/flatbuffers_iter.h"

#include "catboost/libs/helpers/flatbuffers/guid.iter.fbs.h"

namespace NCatBoostFbs {
namespace NEmbeddings {
namespace iter {

template <typename Iter>
struct AdjacencyList;

template <typename Iter>
struct TCollectionHeader;

template <typename Iter>
struct TCollectionPart;

template <typename Iter>
struct AdjacencyList FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_IDS = 4
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>> Ids() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<uint32_t, Iter>>(VT_IDS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_IDS) &&
           verifier.Verify(Ids()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCollectionHeader FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_CALCERID = 4,
    VT_PEREMBEDDINGFEATURECALCERS = 6
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  std::optional<yandex::maps::flatbuffers_iter::Vector<NCatBoostFbs::TGuid, Iter>> CalcerId() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<NCatBoostFbs::TGuid, Iter>>(VT_CALCERID);
  }
  std::optional<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<AdjacencyList<Iter>>, Iter>> PerEmbeddingFeatureCalcers() const {
    return this->template GetPointer<yandex::maps::flatbuffers_iter::Vector<yandex::maps::flatbuffers_iter::Offset<AdjacencyList<Iter>>, Iter>>(VT_PEREMBEDDINGFEATURECALCERS);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_CALCERID) &&
           verifier.Verify(CalcerId()) &&
           this->template VerifyOffset<yandex::maps::flatbuffers_iter::uoffset_t>(verifier, VT_PEREMBEDDINGFEATURECALCERS) &&
           verifier.Verify(PerEmbeddingFeatureCalcers()) &&
           verifier.VerifyVectorOfTables(PerEmbeddingFeatureCalcers()) &&
           verifier.EndTable();
  }
};

template <typename Iter>
struct TCollectionPart FLATBUFFERS_FINAL_CLASS : private yandex::maps::flatbuffers_iter::Table<Iter> {
  enum {
    VT_PARTTYPE = 4,
    VT_ID = 6
  };

  using yandex::maps::flatbuffers_iter::Table<Iter>::Table;
  EPartType PartType() const {
    return static_cast<EPartType>(this->template GetField<uint8_t>(VT_PARTTYPE, 0));
  }
  std::optional<NCatBoostFbs::TGuid> Id() const {
    return this->template GetStruct<NCatBoostFbs::TGuid>(VT_ID);
  }
  bool Verify(yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) const {
    return this->VerifyTableStart(verifier) &&
           this->template VerifyField<uint8_t>(verifier, VT_PARTTYPE, 1) &&
           this->template VerifyField<NCatBoostFbs::TGuid>(verifier, VT_ID, 4) &&
           verifier.EndTable();
  }
};

template <typename Iter>
inline std::optional<NCatBoostFbs::NEmbeddings::iter::TCollectionHeader<Iter>> GetTCollectionHeader(const Iter& buf) {
  return yandex::maps::flatbuffers_iter::GetRoot<NCatBoostFbs::NEmbeddings::iter::TCollectionHeader<Iter>, Iter>(buf);
}

inline const NCatBoostFbs::NEmbeddings::TCollectionHeader *GetTCollectionHeader(const char *buf) {
  return NCatBoostFbs::NEmbeddings::GetTCollectionHeader(buf);
}

template <typename Iter>
inline bool VerifyTCollectionHeaderBuffer(
    yandex::maps::flatbuffers_iter::Verifier<Iter> &verifier) {
  return verifier.template VerifyBuffer<NCatBoostFbs::NEmbeddings::iter::TCollectionHeader<Iter>>(nullptr);
}

inline const char *TCollectionHeaderExtension() {
  return "bfbs";
}

}  // namespace iter
}  // namespace NEmbeddings
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_EMBEDDINGPROCESSINGCOLLECTION_NCATBOOSTFBS_NEMBEDDINGS_ITER_H_
