// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMBEDDINGPROCESSINGCOLLECTION_NCATBOOSTFBS_NEMBEDDINGS_H_
#define FLATBUFFERS_GENERATED_EMBEDDINGPROCESSINGCOLLECTION_NCATBOOSTFBS_NEMBEDDINGS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/helpers/flatbuffers/guid.fbs.h"

namespace NCatBoostFbs {
namespace NEmbeddings {

struct AdjacencyList;
struct AdjacencyListBuilder;
struct AdjacencyListT;

struct TCollectionHeader;
struct TCollectionHeaderBuilder;
struct TCollectionHeaderT;

struct TCollectionPart;
struct TCollectionPartBuilder;
struct TCollectionPartT;

enum EPartType : uint8_t {
  EPartType_EmbeddingCalcer = 0,
  EPartType_MIN = EPartType_EmbeddingCalcer,
  EPartType_MAX = EPartType_EmbeddingCalcer
};

inline const EPartType (&EnumValuesEPartType())[1] {
  static const EPartType values[] = {
    EPartType_EmbeddingCalcer
  };
  return values;
}

inline const char * const *EnumNamesEPartType() {
  static const char * const names[2] = {
    "EmbeddingCalcer",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartType(EPartType e) {
  if (::flatbuffers::IsOutRange(e, EPartType_EmbeddingCalcer, EPartType_EmbeddingCalcer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartType()[index];
}

struct AdjacencyListT : public ::flatbuffers::NativeTable {
  typedef AdjacencyList TableType;
  std::vector<uint32_t> Ids{};
};

struct AdjacencyList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AdjacencyListT NativeTableType;
  typedef AdjacencyListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDS = 4
  };
  const ::flatbuffers::Vector<uint32_t> *Ids() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_IDS);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_Ids() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDS) &&
           verifier.VerifyVector(Ids()) &&
           verifier.EndTable();
  }
  AdjacencyListT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AdjacencyListT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AdjacencyList> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AdjacencyListBuilder {
  typedef AdjacencyList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Ids(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> Ids) {
    fbb_.AddOffset(AdjacencyList::VT_IDS, Ids);
  }
  explicit AdjacencyListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AdjacencyList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AdjacencyList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AdjacencyList> CreateAdjacencyList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> Ids = 0) {
  AdjacencyListBuilder builder_(_fbb);
  builder_.add_Ids(Ids);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AdjacencyList> CreateAdjacencyListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *Ids = nullptr) {
  auto Ids__ = Ids ? _fbb.CreateVector<uint32_t>(*Ids) : 0;
  return NCatBoostFbs::NEmbeddings::CreateAdjacencyList(
      _fbb,
      Ids__);
}

::flatbuffers::Offset<AdjacencyList> CreateAdjacencyList(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCollectionHeaderT : public ::flatbuffers::NativeTable {
  typedef TCollectionHeader TableType;
  std::vector<NCatBoostFbs::TGuid> CalcerId{};
  std::vector<std::unique_ptr<NCatBoostFbs::NEmbeddings::AdjacencyListT>> PerEmbeddingFeatureCalcers{};
  TCollectionHeaderT() = default;
  TCollectionHeaderT(const TCollectionHeaderT &o);
  TCollectionHeaderT(TCollectionHeaderT&&) FLATBUFFERS_NOEXCEPT = default;
  TCollectionHeaderT &operator=(TCollectionHeaderT o) FLATBUFFERS_NOEXCEPT;
};

struct TCollectionHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCollectionHeaderT NativeTableType;
  typedef TCollectionHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALCERID = 4,
    VT_PEREMBEDDINGFEATURECALCERS = 6
  };
  const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *CalcerId() const {
    return GetPointer<const ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_CALCERID);
  }
  ::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *mutable_CalcerId() {
    return GetPointer<::flatbuffers::Vector<const NCatBoostFbs::TGuid *> *>(VT_CALCERID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>> *PerEmbeddingFeatureCalcers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>> *>(VT_PEREMBEDDINGFEATURECALCERS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>> *mutable_PerEmbeddingFeatureCalcers() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>> *>(VT_PEREMBEDDINGFEATURECALCERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALCERID) &&
           verifier.VerifyVector(CalcerId()) &&
           VerifyOffset(verifier, VT_PEREMBEDDINGFEATURECALCERS) &&
           verifier.VerifyVector(PerEmbeddingFeatureCalcers()) &&
           verifier.VerifyVectorOfTables(PerEmbeddingFeatureCalcers()) &&
           verifier.EndTable();
  }
  TCollectionHeaderT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCollectionHeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCollectionHeader> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCollectionHeaderBuilder {
  typedef TCollectionHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CalcerId(::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> CalcerId) {
    fbb_.AddOffset(TCollectionHeader::VT_CALCERID, CalcerId);
  }
  void add_PerEmbeddingFeatureCalcers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>>> PerEmbeddingFeatureCalcers) {
    fbb_.AddOffset(TCollectionHeader::VT_PEREMBEDDINGFEATURECALCERS, PerEmbeddingFeatureCalcers);
  }
  explicit TCollectionHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCollectionHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCollectionHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const NCatBoostFbs::TGuid *>> CalcerId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>>> PerEmbeddingFeatureCalcers = 0) {
  TCollectionHeaderBuilder builder_(_fbb);
  builder_.add_PerEmbeddingFeatureCalcers(PerEmbeddingFeatureCalcers);
  builder_.add_CalcerId(CalcerId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<NCatBoostFbs::TGuid> *CalcerId = nullptr,
    const std::vector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>> *PerEmbeddingFeatureCalcers = nullptr) {
  auto CalcerId__ = CalcerId ? _fbb.CreateVectorOfStructs<NCatBoostFbs::TGuid>(*CalcerId) : 0;
  auto PerEmbeddingFeatureCalcers__ = PerEmbeddingFeatureCalcers ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>>(*PerEmbeddingFeatureCalcers) : 0;
  return NCatBoostFbs::NEmbeddings::CreateTCollectionHeader(
      _fbb,
      CalcerId__,
      PerEmbeddingFeatureCalcers__);
}

::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeader(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TCollectionPartT : public ::flatbuffers::NativeTable {
  typedef TCollectionPart TableType;
  NCatBoostFbs::NEmbeddings::EPartType PartType = NCatBoostFbs::NEmbeddings::EPartType_EmbeddingCalcer;
  std::unique_ptr<NCatBoostFbs::TGuid> Id{};
  TCollectionPartT() = default;
  TCollectionPartT(const TCollectionPartT &o);
  TCollectionPartT(TCollectionPartT&&) FLATBUFFERS_NOEXCEPT = default;
  TCollectionPartT &operator=(TCollectionPartT o) FLATBUFFERS_NOEXCEPT;
};

struct TCollectionPart FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TCollectionPartT NativeTableType;
  typedef TCollectionPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTTYPE = 4,
    VT_ID = 6
  };
  NCatBoostFbs::NEmbeddings::EPartType PartType() const {
    return static_cast<NCatBoostFbs::NEmbeddings::EPartType>(GetField<uint8_t>(VT_PARTTYPE, 0));
  }
  bool mutate_PartType(NCatBoostFbs::NEmbeddings::EPartType _PartType = static_cast<NCatBoostFbs::NEmbeddings::EPartType>(0)) {
    return SetField<uint8_t>(VT_PARTTYPE, static_cast<uint8_t>(_PartType), 0);
  }
  const NCatBoostFbs::TGuid *Id() const {
    return GetStruct<const NCatBoostFbs::TGuid *>(VT_ID);
  }
  NCatBoostFbs::TGuid *mutable_Id() {
    return GetStruct<NCatBoostFbs::TGuid *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARTTYPE, 1) &&
           VerifyField<NCatBoostFbs::TGuid>(verifier, VT_ID, 4) &&
           verifier.EndTable();
  }
  TCollectionPartT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TCollectionPartT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TCollectionPart> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TCollectionPartBuilder {
  typedef TCollectionPart Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PartType(NCatBoostFbs::NEmbeddings::EPartType PartType) {
    fbb_.AddElement<uint8_t>(TCollectionPart::VT_PARTTYPE, static_cast<uint8_t>(PartType), 0);
  }
  void add_Id(const NCatBoostFbs::TGuid *Id) {
    fbb_.AddStruct(TCollectionPart::VT_ID, Id);
  }
  explicit TCollectionPartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TCollectionPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TCollectionPart>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TCollectionPart> CreateTCollectionPart(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NCatBoostFbs::NEmbeddings::EPartType PartType = NCatBoostFbs::NEmbeddings::EPartType_EmbeddingCalcer,
    const NCatBoostFbs::TGuid *Id = nullptr) {
  TCollectionPartBuilder builder_(_fbb);
  builder_.add_Id(Id);
  builder_.add_PartType(PartType);
  return builder_.Finish();
}

::flatbuffers::Offset<TCollectionPart> CreateTCollectionPart(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AdjacencyListT *AdjacencyList::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AdjacencyListT>(new AdjacencyListT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AdjacencyList::UnPackTo(AdjacencyListT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Ids(); if (_e) { _o->Ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Ids[_i] = _e->Get(_i); } } else { _o->Ids.resize(0); } }
}

inline ::flatbuffers::Offset<AdjacencyList> AdjacencyList::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAdjacencyList(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AdjacencyList> CreateAdjacencyList(::flatbuffers::FlatBufferBuilder &_fbb, const AdjacencyListT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AdjacencyListT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Ids = _o->Ids.size() ? _fbb.CreateVector(_o->Ids) : 0;
  return NCatBoostFbs::NEmbeddings::CreateAdjacencyList(
      _fbb,
      _Ids);
}

inline TCollectionHeaderT::TCollectionHeaderT(const TCollectionHeaderT &o)
      : CalcerId(o.CalcerId) {
  PerEmbeddingFeatureCalcers.reserve(o.PerEmbeddingFeatureCalcers.size());
  for (const auto &PerEmbeddingFeatureCalcers_ : o.PerEmbeddingFeatureCalcers) { PerEmbeddingFeatureCalcers.emplace_back((PerEmbeddingFeatureCalcers_) ? new NCatBoostFbs::NEmbeddings::AdjacencyListT(*PerEmbeddingFeatureCalcers_) : nullptr); }
}

inline TCollectionHeaderT &TCollectionHeaderT::operator=(TCollectionHeaderT o) FLATBUFFERS_NOEXCEPT {
  std::swap(CalcerId, o.CalcerId);
  std::swap(PerEmbeddingFeatureCalcers, o.PerEmbeddingFeatureCalcers);
  return *this;
}

inline TCollectionHeaderT *TCollectionHeader::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCollectionHeaderT>(new TCollectionHeaderT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCollectionHeader::UnPackTo(TCollectionHeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = CalcerId(); if (_e) { _o->CalcerId.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->CalcerId[_i] = *_e->Get(_i); } } else { _o->CalcerId.resize(0); } }
  { auto _e = PerEmbeddingFeatureCalcers(); if (_e) { _o->PerEmbeddingFeatureCalcers.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->PerEmbeddingFeatureCalcers[_i]) { _e->Get(_i)->UnPackTo(_o->PerEmbeddingFeatureCalcers[_i].get(), _resolver); } else { _o->PerEmbeddingFeatureCalcers[_i] = std::unique_ptr<NCatBoostFbs::NEmbeddings::AdjacencyListT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->PerEmbeddingFeatureCalcers.resize(0); } }
}

inline ::flatbuffers::Offset<TCollectionHeader> TCollectionHeader::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCollectionHeader(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCollectionHeader> CreateTCollectionHeader(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionHeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCollectionHeaderT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _CalcerId = _o->CalcerId.size() ? _fbb.CreateVectorOfStructs(_o->CalcerId) : 0;
  auto _PerEmbeddingFeatureCalcers = _o->PerEmbeddingFeatureCalcers.size() ? _fbb.CreateVector<::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::AdjacencyList>> (_o->PerEmbeddingFeatureCalcers.size(), [](size_t i, _VectorArgs *__va) { return CreateAdjacencyList(*__va->__fbb, __va->__o->PerEmbeddingFeatureCalcers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return NCatBoostFbs::NEmbeddings::CreateTCollectionHeader(
      _fbb,
      _CalcerId,
      _PerEmbeddingFeatureCalcers);
}

inline TCollectionPartT::TCollectionPartT(const TCollectionPartT &o)
      : PartType(o.PartType),
        Id((o.Id) ? new NCatBoostFbs::TGuid(*o.Id) : nullptr) {
}

inline TCollectionPartT &TCollectionPartT::operator=(TCollectionPartT o) FLATBUFFERS_NOEXCEPT {
  std::swap(PartType, o.PartType);
  std::swap(Id, o.Id);
  return *this;
}

inline TCollectionPartT *TCollectionPart::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TCollectionPartT>(new TCollectionPartT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TCollectionPart::UnPackTo(TCollectionPartT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = PartType(); _o->PartType = _e; }
  { auto _e = Id(); if (_e) _o->Id = std::unique_ptr<NCatBoostFbs::TGuid>(new NCatBoostFbs::TGuid(*_e)); }
}

inline ::flatbuffers::Offset<TCollectionPart> TCollectionPart::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTCollectionPart(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TCollectionPart> CreateTCollectionPart(::flatbuffers::FlatBufferBuilder &_fbb, const TCollectionPartT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TCollectionPartT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _PartType = _o->PartType;
  auto _Id = _o->Id ? _o->Id.get() : nullptr;
  return NCatBoostFbs::NEmbeddings::CreateTCollectionPart(
      _fbb,
      _PartType,
      _Id);
}

inline const NCatBoostFbs::NEmbeddings::TCollectionHeader *GetTCollectionHeader(const void *buf) {
  return ::flatbuffers::GetRoot<NCatBoostFbs::NEmbeddings::TCollectionHeader>(buf);
}

inline const NCatBoostFbs::NEmbeddings::TCollectionHeader *GetSizePrefixedTCollectionHeader(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::NEmbeddings::TCollectionHeader>(buf);
}

inline TCollectionHeader *GetMutableTCollectionHeader(void *buf) {
  return ::flatbuffers::GetMutableRoot<TCollectionHeader>(buf);
}

inline NCatBoostFbs::NEmbeddings::TCollectionHeader *GetMutableSizePrefixedTCollectionHeader(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NCatBoostFbs::NEmbeddings::TCollectionHeader>(buf);
}

inline bool VerifyTCollectionHeaderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::NEmbeddings::TCollectionHeader>(nullptr);
}

inline bool VerifySizePrefixedTCollectionHeaderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::NEmbeddings::TCollectionHeader>(nullptr);
}

inline const char *TCollectionHeaderExtension() {
  return "bfbs";
}

inline void FinishTCollectionHeaderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::TCollectionHeader> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTCollectionHeaderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::TCollectionHeader> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NCatBoostFbs::NEmbeddings::TCollectionHeaderT> UnPackTCollectionHeader(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::NEmbeddings::TCollectionHeaderT>(GetTCollectionHeader(buf)->UnPack(res));
}

inline std::unique_ptr<NCatBoostFbs::NEmbeddings::TCollectionHeaderT> UnPackSizePrefixedTCollectionHeader(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::NEmbeddings::TCollectionHeaderT>(GetSizePrefixedTCollectionHeader(buf)->UnPack(res));
}

}  // namespace NEmbeddings
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_EMBEDDINGPROCESSINGCOLLECTION_NCATBOOSTFBS_NEMBEDDINGS_H_
