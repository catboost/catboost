// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMBEDDINGFEATURECALCERS_NCATBOOSTFBS_NEMBEDDINGS_H_
#define FLATBUFFERS_GENERATED_EMBEDDINGFEATURECALCERS_NCATBOOSTFBS_NEMBEDDINGS_H_

#include <contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h>

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "catboost/libs/helpers/flatbuffers/guid.fbs.h"

namespace NCatBoostFbs {
namespace NEmbeddings {

struct TLDA;
struct TLDABuilder;
struct TLDAT;

struct TKNN;
struct TKNNBuilder;
struct TKNNT;

struct TEmbeddingCalcer;
struct TEmbeddingCalcerBuilder;
struct TEmbeddingCalcerT;

enum TAnyEmbeddingCalcer : uint8_t {
  TAnyEmbeddingCalcer_NONE = 0,
  TAnyEmbeddingCalcer_TLDA = 1,
  TAnyEmbeddingCalcer_TKNN = 2,
  TAnyEmbeddingCalcer_MIN = TAnyEmbeddingCalcer_NONE,
  TAnyEmbeddingCalcer_MAX = TAnyEmbeddingCalcer_TKNN
};

inline const TAnyEmbeddingCalcer (&EnumValuesTAnyEmbeddingCalcer())[3] {
  static const TAnyEmbeddingCalcer values[] = {
    TAnyEmbeddingCalcer_NONE,
    TAnyEmbeddingCalcer_TLDA,
    TAnyEmbeddingCalcer_TKNN
  };
  return values;
}

inline const char * const *EnumNamesTAnyEmbeddingCalcer() {
  static const char * const names[4] = {
    "NONE",
    "TLDA",
    "TKNN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTAnyEmbeddingCalcer(TAnyEmbeddingCalcer e) {
  if (::flatbuffers::IsOutRange(e, TAnyEmbeddingCalcer_NONE, TAnyEmbeddingCalcer_TKNN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTAnyEmbeddingCalcer()[index];
}

template<typename T> struct TAnyEmbeddingCalcerTraits {
  static const TAnyEmbeddingCalcer enum_value = TAnyEmbeddingCalcer_NONE;
};

template<> struct TAnyEmbeddingCalcerTraits<NCatBoostFbs::NEmbeddings::TLDA> {
  static const TAnyEmbeddingCalcer enum_value = TAnyEmbeddingCalcer_TLDA;
};

template<> struct TAnyEmbeddingCalcerTraits<NCatBoostFbs::NEmbeddings::TKNN> {
  static const TAnyEmbeddingCalcer enum_value = TAnyEmbeddingCalcer_TKNN;
};

template<typename T> struct TAnyEmbeddingCalcerUnionTraits {
  static const TAnyEmbeddingCalcer enum_value = TAnyEmbeddingCalcer_NONE;
};

template<> struct TAnyEmbeddingCalcerUnionTraits<NCatBoostFbs::NEmbeddings::TLDAT> {
  static const TAnyEmbeddingCalcer enum_value = TAnyEmbeddingCalcer_TLDA;
};

template<> struct TAnyEmbeddingCalcerUnionTraits<NCatBoostFbs::NEmbeddings::TKNNT> {
  static const TAnyEmbeddingCalcer enum_value = TAnyEmbeddingCalcer_TKNN;
};

struct TAnyEmbeddingCalcerUnion {
  TAnyEmbeddingCalcer type;
  void *value;

  TAnyEmbeddingCalcerUnion() : type(TAnyEmbeddingCalcer_NONE), value(nullptr) {}
  TAnyEmbeddingCalcerUnion(TAnyEmbeddingCalcerUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(TAnyEmbeddingCalcer_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  TAnyEmbeddingCalcerUnion(const TAnyEmbeddingCalcerUnion &);
  TAnyEmbeddingCalcerUnion &operator=(const TAnyEmbeddingCalcerUnion &u)
    { TAnyEmbeddingCalcerUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  TAnyEmbeddingCalcerUnion &operator=(TAnyEmbeddingCalcerUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~TAnyEmbeddingCalcerUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = TAnyEmbeddingCalcerUnionTraits<RT>::enum_value;
    if (type != TAnyEmbeddingCalcer_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, TAnyEmbeddingCalcer type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  NCatBoostFbs::NEmbeddings::TLDAT *AsTLDA() {
    return type == TAnyEmbeddingCalcer_TLDA ?
      reinterpret_cast<NCatBoostFbs::NEmbeddings::TLDAT *>(value) : nullptr;
  }
  const NCatBoostFbs::NEmbeddings::TLDAT *AsTLDA() const {
    return type == TAnyEmbeddingCalcer_TLDA ?
      reinterpret_cast<const NCatBoostFbs::NEmbeddings::TLDAT *>(value) : nullptr;
  }
  NCatBoostFbs::NEmbeddings::TKNNT *AsTKNN() {
    return type == TAnyEmbeddingCalcer_TKNN ?
      reinterpret_cast<NCatBoostFbs::NEmbeddings::TKNNT *>(value) : nullptr;
  }
  const NCatBoostFbs::NEmbeddings::TKNNT *AsTKNN() const {
    return type == TAnyEmbeddingCalcer_TKNN ?
      reinterpret_cast<const NCatBoostFbs::NEmbeddings::TKNNT *>(value) : nullptr;
  }
};

bool VerifyTAnyEmbeddingCalcer(::flatbuffers::Verifier &verifier, const void *obj, TAnyEmbeddingCalcer type);
bool VerifyTAnyEmbeddingCalcerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct TLDAT : public ::flatbuffers::NativeTable {
  typedef TLDA TableType;
  int32_t TotalDimension = 0;
  int32_t NumClasses = 0;
  int32_t ProjectionDimension = 0;
  bool ComputeProbabilities = false;
  std::vector<float> ProjectionMatrix{};
  bool IsClassification = true;
};

struct TLDA FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TLDAT NativeTableType;
  typedef TLDABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTALDIMENSION = 4,
    VT_NUMCLASSES = 6,
    VT_PROJECTIONDIMENSION = 8,
    VT_COMPUTEPROBABILITIES = 10,
    VT_PROJECTIONMATRIX = 12,
    VT_ISCLASSIFICATION = 14
  };
  int32_t TotalDimension() const {
    return GetField<int32_t>(VT_TOTALDIMENSION, 0);
  }
  bool mutate_TotalDimension(int32_t _TotalDimension = 0) {
    return SetField<int32_t>(VT_TOTALDIMENSION, _TotalDimension, 0);
  }
  int32_t NumClasses() const {
    return GetField<int32_t>(VT_NUMCLASSES, 0);
  }
  bool mutate_NumClasses(int32_t _NumClasses = 0) {
    return SetField<int32_t>(VT_NUMCLASSES, _NumClasses, 0);
  }
  int32_t ProjectionDimension() const {
    return GetField<int32_t>(VT_PROJECTIONDIMENSION, 0);
  }
  bool mutate_ProjectionDimension(int32_t _ProjectionDimension = 0) {
    return SetField<int32_t>(VT_PROJECTIONDIMENSION, _ProjectionDimension, 0);
  }
  bool ComputeProbabilities() const {
    return GetField<uint8_t>(VT_COMPUTEPROBABILITIES, 0) != 0;
  }
  bool mutate_ComputeProbabilities(bool _ComputeProbabilities = 0) {
    return SetField<uint8_t>(VT_COMPUTEPROBABILITIES, static_cast<uint8_t>(_ComputeProbabilities), 0);
  }
  const ::flatbuffers::Vector<float> *ProjectionMatrix() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_PROJECTIONMATRIX);
  }
  ::flatbuffers::Vector<float> *mutable_ProjectionMatrix() {
    return GetPointer<::flatbuffers::Vector<float> *>(VT_PROJECTIONMATRIX);
  }
  bool IsClassification() const {
    return GetField<uint8_t>(VT_ISCLASSIFICATION, 1) != 0;
  }
  bool mutate_IsClassification(bool _IsClassification = 1) {
    return SetField<uint8_t>(VT_ISCLASSIFICATION, static_cast<uint8_t>(_IsClassification), 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TOTALDIMENSION, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMCLASSES, 4) &&
           VerifyField<int32_t>(verifier, VT_PROJECTIONDIMENSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_COMPUTEPROBABILITIES, 1) &&
           VerifyOffset(verifier, VT_PROJECTIONMATRIX) &&
           verifier.VerifyVector(ProjectionMatrix()) &&
           VerifyField<uint8_t>(verifier, VT_ISCLASSIFICATION, 1) &&
           verifier.EndTable();
  }
  TLDAT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TLDAT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TLDA> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TLDAT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TLDABuilder {
  typedef TLDA Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TotalDimension(int32_t TotalDimension) {
    fbb_.AddElement<int32_t>(TLDA::VT_TOTALDIMENSION, TotalDimension, 0);
  }
  void add_NumClasses(int32_t NumClasses) {
    fbb_.AddElement<int32_t>(TLDA::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_ProjectionDimension(int32_t ProjectionDimension) {
    fbb_.AddElement<int32_t>(TLDA::VT_PROJECTIONDIMENSION, ProjectionDimension, 0);
  }
  void add_ComputeProbabilities(bool ComputeProbabilities) {
    fbb_.AddElement<uint8_t>(TLDA::VT_COMPUTEPROBABILITIES, static_cast<uint8_t>(ComputeProbabilities), 0);
  }
  void add_ProjectionMatrix(::flatbuffers::Offset<::flatbuffers::Vector<float>> ProjectionMatrix) {
    fbb_.AddOffset(TLDA::VT_PROJECTIONMATRIX, ProjectionMatrix);
  }
  void add_IsClassification(bool IsClassification) {
    fbb_.AddElement<uint8_t>(TLDA::VT_ISCLASSIFICATION, static_cast<uint8_t>(IsClassification), 1);
  }
  explicit TLDABuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TLDA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TLDA>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TLDA> CreateTLDA(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t TotalDimension = 0,
    int32_t NumClasses = 0,
    int32_t ProjectionDimension = 0,
    bool ComputeProbabilities = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> ProjectionMatrix = 0,
    bool IsClassification = true) {
  TLDABuilder builder_(_fbb);
  builder_.add_ProjectionMatrix(ProjectionMatrix);
  builder_.add_ProjectionDimension(ProjectionDimension);
  builder_.add_NumClasses(NumClasses);
  builder_.add_TotalDimension(TotalDimension);
  builder_.add_IsClassification(IsClassification);
  builder_.add_ComputeProbabilities(ComputeProbabilities);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TLDA> CreateTLDADirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t TotalDimension = 0,
    int32_t NumClasses = 0,
    int32_t ProjectionDimension = 0,
    bool ComputeProbabilities = false,
    const std::vector<float> *ProjectionMatrix = nullptr,
    bool IsClassification = true) {
  auto ProjectionMatrix__ = ProjectionMatrix ? _fbb.CreateVector<float>(*ProjectionMatrix) : 0;
  return NCatBoostFbs::NEmbeddings::CreateTLDA(
      _fbb,
      TotalDimension,
      NumClasses,
      ProjectionDimension,
      ComputeProbabilities,
      ProjectionMatrix__,
      IsClassification);
}

::flatbuffers::Offset<TLDA> CreateTLDA(::flatbuffers::FlatBufferBuilder &_fbb, const TLDAT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TKNNT : public ::flatbuffers::NativeTable {
  typedef TKNN TableType;
  int32_t TotalDimension = 0;
  uint32_t NumClasses = 0;
  uint32_t KNum = 0;
  uint32_t Size = 0;
  bool IsClassification = true;
};

struct TKNN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TKNNT NativeTableType;
  typedef TKNNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTALDIMENSION = 4,
    VT_NUMCLASSES = 6,
    VT_KNUM = 8,
    VT_SIZE = 10,
    VT_ISCLASSIFICATION = 12
  };
  int32_t TotalDimension() const {
    return GetField<int32_t>(VT_TOTALDIMENSION, 0);
  }
  bool mutate_TotalDimension(int32_t _TotalDimension = 0) {
    return SetField<int32_t>(VT_TOTALDIMENSION, _TotalDimension, 0);
  }
  uint32_t NumClasses() const {
    return GetField<uint32_t>(VT_NUMCLASSES, 0);
  }
  bool mutate_NumClasses(uint32_t _NumClasses = 0) {
    return SetField<uint32_t>(VT_NUMCLASSES, _NumClasses, 0);
  }
  uint32_t KNum() const {
    return GetField<uint32_t>(VT_KNUM, 0);
  }
  bool mutate_KNum(uint32_t _KNum = 0) {
    return SetField<uint32_t>(VT_KNUM, _KNum, 0);
  }
  uint32_t Size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_Size(uint32_t _Size = 0) {
    return SetField<uint32_t>(VT_SIZE, _Size, 0);
  }
  bool IsClassification() const {
    return GetField<uint8_t>(VT_ISCLASSIFICATION, 1) != 0;
  }
  bool mutate_IsClassification(bool _IsClassification = 1) {
    return SetField<uint8_t>(VT_ISCLASSIFICATION, static_cast<uint8_t>(_IsClassification), 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TOTALDIMENSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_NUMCLASSES, 4) &&
           VerifyField<uint32_t>(verifier, VT_KNUM, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISCLASSIFICATION, 1) &&
           verifier.EndTable();
  }
  TKNNT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TKNNT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TKNN> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKNNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TKNNBuilder {
  typedef TKNN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TotalDimension(int32_t TotalDimension) {
    fbb_.AddElement<int32_t>(TKNN::VT_TOTALDIMENSION, TotalDimension, 0);
  }
  void add_NumClasses(uint32_t NumClasses) {
    fbb_.AddElement<uint32_t>(TKNN::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_KNum(uint32_t KNum) {
    fbb_.AddElement<uint32_t>(TKNN::VT_KNUM, KNum, 0);
  }
  void add_Size(uint32_t Size) {
    fbb_.AddElement<uint32_t>(TKNN::VT_SIZE, Size, 0);
  }
  void add_IsClassification(bool IsClassification) {
    fbb_.AddElement<uint8_t>(TKNN::VT_ISCLASSIFICATION, static_cast<uint8_t>(IsClassification), 1);
  }
  explicit TKNNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TKNN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TKNN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TKNN> CreateTKNN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t TotalDimension = 0,
    uint32_t NumClasses = 0,
    uint32_t KNum = 0,
    uint32_t Size = 0,
    bool IsClassification = true) {
  TKNNBuilder builder_(_fbb);
  builder_.add_Size(Size);
  builder_.add_KNum(KNum);
  builder_.add_NumClasses(NumClasses);
  builder_.add_TotalDimension(TotalDimension);
  builder_.add_IsClassification(IsClassification);
  return builder_.Finish();
}

::flatbuffers::Offset<TKNN> CreateTKNN(::flatbuffers::FlatBufferBuilder &_fbb, const TKNNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TEmbeddingCalcerT : public ::flatbuffers::NativeTable {
  typedef TEmbeddingCalcer TableType;
  std::unique_ptr<NCatBoostFbs::TGuid> Id{};
  std::vector<uint32_t> ActiveFeatureIndices{};
  NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcerUnion FeatureCalcerImpl{};
  TEmbeddingCalcerT() = default;
  TEmbeddingCalcerT(const TEmbeddingCalcerT &o);
  TEmbeddingCalcerT(TEmbeddingCalcerT&&) FLATBUFFERS_NOEXCEPT = default;
  TEmbeddingCalcerT &operator=(TEmbeddingCalcerT o) FLATBUFFERS_NOEXCEPT;
};

struct TEmbeddingCalcer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TEmbeddingCalcerT NativeTableType;
  typedef TEmbeddingCalcerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ACTIVEFEATUREINDICES = 6,
    VT_FEATURECALCERIMPL_TYPE = 8,
    VT_FEATURECALCERIMPL = 10
  };
  const NCatBoostFbs::TGuid *Id() const {
    return GetStruct<const NCatBoostFbs::TGuid *>(VT_ID);
  }
  NCatBoostFbs::TGuid *mutable_Id() {
    return GetStruct<NCatBoostFbs::TGuid *>(VT_ID);
  }
  const ::flatbuffers::Vector<uint32_t> *ActiveFeatureIndices() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ACTIVEFEATUREINDICES);
  }
  ::flatbuffers::Vector<uint32_t> *mutable_ActiveFeatureIndices() {
    return GetPointer<::flatbuffers::Vector<uint32_t> *>(VT_ACTIVEFEATUREINDICES);
  }
  NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer FeatureCalcerImpl_type() const {
    return static_cast<NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer>(GetField<uint8_t>(VT_FEATURECALCERIMPL_TYPE, 0));
  }
  const void *FeatureCalcerImpl() const {
    return GetPointer<const void *>(VT_FEATURECALCERIMPL);
  }
  template<typename T> const T *FeatureCalcerImpl_as() const;
  const NCatBoostFbs::NEmbeddings::TLDA *FeatureCalcerImpl_as_TLDA() const {
    return FeatureCalcerImpl_type() == NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer_TLDA ? static_cast<const NCatBoostFbs::NEmbeddings::TLDA *>(FeatureCalcerImpl()) : nullptr;
  }
  const NCatBoostFbs::NEmbeddings::TKNN *FeatureCalcerImpl_as_TKNN() const {
    return FeatureCalcerImpl_type() == NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer_TKNN ? static_cast<const NCatBoostFbs::NEmbeddings::TKNN *>(FeatureCalcerImpl()) : nullptr;
  }
  void *mutable_FeatureCalcerImpl() {
    return GetPointer<void *>(VT_FEATURECALCERIMPL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<NCatBoostFbs::TGuid>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_ACTIVEFEATUREINDICES) &&
           verifier.VerifyVector(ActiveFeatureIndices()) &&
           VerifyField<uint8_t>(verifier, VT_FEATURECALCERIMPL_TYPE, 1) &&
           VerifyOffset(verifier, VT_FEATURECALCERIMPL) &&
           VerifyTAnyEmbeddingCalcer(verifier, FeatureCalcerImpl(), FeatureCalcerImpl_type()) &&
           verifier.EndTable();
  }
  TEmbeddingCalcerT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TEmbeddingCalcerT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TEmbeddingCalcer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingCalcerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const NCatBoostFbs::NEmbeddings::TLDA *TEmbeddingCalcer::FeatureCalcerImpl_as<NCatBoostFbs::NEmbeddings::TLDA>() const {
  return FeatureCalcerImpl_as_TLDA();
}

template<> inline const NCatBoostFbs::NEmbeddings::TKNN *TEmbeddingCalcer::FeatureCalcerImpl_as<NCatBoostFbs::NEmbeddings::TKNN>() const {
  return FeatureCalcerImpl_as_TKNN();
}

struct TEmbeddingCalcerBuilder {
  typedef TEmbeddingCalcer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Id(const NCatBoostFbs::TGuid *Id) {
    fbb_.AddStruct(TEmbeddingCalcer::VT_ID, Id);
  }
  void add_ActiveFeatureIndices(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ActiveFeatureIndices) {
    fbb_.AddOffset(TEmbeddingCalcer::VT_ACTIVEFEATUREINDICES, ActiveFeatureIndices);
  }
  void add_FeatureCalcerImpl_type(NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer FeatureCalcerImpl_type) {
    fbb_.AddElement<uint8_t>(TEmbeddingCalcer::VT_FEATURECALCERIMPL_TYPE, static_cast<uint8_t>(FeatureCalcerImpl_type), 0);
  }
  void add_FeatureCalcerImpl(::flatbuffers::Offset<void> FeatureCalcerImpl) {
    fbb_.AddOffset(TEmbeddingCalcer::VT_FEATURECALCERIMPL, FeatureCalcerImpl);
  }
  explicit TEmbeddingCalcerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TEmbeddingCalcer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TEmbeddingCalcer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TEmbeddingCalcer> CreateTEmbeddingCalcer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NCatBoostFbs::TGuid *Id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> ActiveFeatureIndices = 0,
    NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer FeatureCalcerImpl_type = NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer_NONE,
    ::flatbuffers::Offset<void> FeatureCalcerImpl = 0) {
  TEmbeddingCalcerBuilder builder_(_fbb);
  builder_.add_FeatureCalcerImpl(FeatureCalcerImpl);
  builder_.add_ActiveFeatureIndices(ActiveFeatureIndices);
  builder_.add_Id(Id);
  builder_.add_FeatureCalcerImpl_type(FeatureCalcerImpl_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TEmbeddingCalcer> CreateTEmbeddingCalcerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const NCatBoostFbs::TGuid *Id = nullptr,
    const std::vector<uint32_t> *ActiveFeatureIndices = nullptr,
    NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer FeatureCalcerImpl_type = NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcer_NONE,
    ::flatbuffers::Offset<void> FeatureCalcerImpl = 0) {
  auto ActiveFeatureIndices__ = ActiveFeatureIndices ? _fbb.CreateVector<uint32_t>(*ActiveFeatureIndices) : 0;
  return NCatBoostFbs::NEmbeddings::CreateTEmbeddingCalcer(
      _fbb,
      Id,
      ActiveFeatureIndices__,
      FeatureCalcerImpl_type,
      FeatureCalcerImpl);
}

::flatbuffers::Offset<TEmbeddingCalcer> CreateTEmbeddingCalcer(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingCalcerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TLDAT *TLDA::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TLDAT>(new TLDAT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TLDA::UnPackTo(TLDAT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = TotalDimension(); _o->TotalDimension = _e; }
  { auto _e = NumClasses(); _o->NumClasses = _e; }
  { auto _e = ProjectionDimension(); _o->ProjectionDimension = _e; }
  { auto _e = ComputeProbabilities(); _o->ComputeProbabilities = _e; }
  { auto _e = ProjectionMatrix(); if (_e) { _o->ProjectionMatrix.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ProjectionMatrix[_i] = _e->Get(_i); } } else { _o->ProjectionMatrix.resize(0); } }
  { auto _e = IsClassification(); _o->IsClassification = _e; }
}

inline ::flatbuffers::Offset<TLDA> TLDA::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TLDAT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTLDA(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TLDA> CreateTLDA(::flatbuffers::FlatBufferBuilder &_fbb, const TLDAT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TLDAT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _TotalDimension = _o->TotalDimension;
  auto _NumClasses = _o->NumClasses;
  auto _ProjectionDimension = _o->ProjectionDimension;
  auto _ComputeProbabilities = _o->ComputeProbabilities;
  auto _ProjectionMatrix = _o->ProjectionMatrix.size() ? _fbb.CreateVector(_o->ProjectionMatrix) : 0;
  auto _IsClassification = _o->IsClassification;
  return NCatBoostFbs::NEmbeddings::CreateTLDA(
      _fbb,
      _TotalDimension,
      _NumClasses,
      _ProjectionDimension,
      _ComputeProbabilities,
      _ProjectionMatrix,
      _IsClassification);
}

inline TKNNT *TKNN::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TKNNT>(new TKNNT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TKNN::UnPackTo(TKNNT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = TotalDimension(); _o->TotalDimension = _e; }
  { auto _e = NumClasses(); _o->NumClasses = _e; }
  { auto _e = KNum(); _o->KNum = _e; }
  { auto _e = Size(); _o->Size = _e; }
  { auto _e = IsClassification(); _o->IsClassification = _e; }
}

inline ::flatbuffers::Offset<TKNN> TKNN::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TKNNT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTKNN(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TKNN> CreateTKNN(::flatbuffers::FlatBufferBuilder &_fbb, const TKNNT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TKNNT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _TotalDimension = _o->TotalDimension;
  auto _NumClasses = _o->NumClasses;
  auto _KNum = _o->KNum;
  auto _Size = _o->Size;
  auto _IsClassification = _o->IsClassification;
  return NCatBoostFbs::NEmbeddings::CreateTKNN(
      _fbb,
      _TotalDimension,
      _NumClasses,
      _KNum,
      _Size,
      _IsClassification);
}

inline TEmbeddingCalcerT::TEmbeddingCalcerT(const TEmbeddingCalcerT &o)
      : Id((o.Id) ? new NCatBoostFbs::TGuid(*o.Id) : nullptr),
        ActiveFeatureIndices(o.ActiveFeatureIndices),
        FeatureCalcerImpl(o.FeatureCalcerImpl) {
}

inline TEmbeddingCalcerT &TEmbeddingCalcerT::operator=(TEmbeddingCalcerT o) FLATBUFFERS_NOEXCEPT {
  std::swap(Id, o.Id);
  std::swap(ActiveFeatureIndices, o.ActiveFeatureIndices);
  std::swap(FeatureCalcerImpl, o.FeatureCalcerImpl);
  return *this;
}

inline TEmbeddingCalcerT *TEmbeddingCalcer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TEmbeddingCalcerT>(new TEmbeddingCalcerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TEmbeddingCalcer::UnPackTo(TEmbeddingCalcerT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Id(); if (_e) _o->Id = std::unique_ptr<NCatBoostFbs::TGuid>(new NCatBoostFbs::TGuid(*_e)); }
  { auto _e = ActiveFeatureIndices(); if (_e) { _o->ActiveFeatureIndices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ActiveFeatureIndices[_i] = _e->Get(_i); } } else { _o->ActiveFeatureIndices.resize(0); } }
  { auto _e = FeatureCalcerImpl_type(); _o->FeatureCalcerImpl.type = _e; }
  { auto _e = FeatureCalcerImpl(); if (_e) _o->FeatureCalcerImpl.value = NCatBoostFbs::NEmbeddings::TAnyEmbeddingCalcerUnion::UnPack(_e, FeatureCalcerImpl_type(), _resolver); }
}

inline ::flatbuffers::Offset<TEmbeddingCalcer> TEmbeddingCalcer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingCalcerT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTEmbeddingCalcer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TEmbeddingCalcer> CreateTEmbeddingCalcer(::flatbuffers::FlatBufferBuilder &_fbb, const TEmbeddingCalcerT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TEmbeddingCalcerT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Id = _o->Id ? _o->Id.get() : nullptr;
  auto _ActiveFeatureIndices = _o->ActiveFeatureIndices.size() ? _fbb.CreateVector(_o->ActiveFeatureIndices) : 0;
  auto _FeatureCalcerImpl_type = _o->FeatureCalcerImpl.type;
  auto _FeatureCalcerImpl = _o->FeatureCalcerImpl.Pack(_fbb);
  return NCatBoostFbs::NEmbeddings::CreateTEmbeddingCalcer(
      _fbb,
      _Id,
      _ActiveFeatureIndices,
      _FeatureCalcerImpl_type,
      _FeatureCalcerImpl);
}

inline bool VerifyTAnyEmbeddingCalcer(::flatbuffers::Verifier &verifier, const void *obj, TAnyEmbeddingCalcer type) {
  switch (type) {
    case TAnyEmbeddingCalcer_NONE: {
      return true;
    }
    case TAnyEmbeddingCalcer_TLDA: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::NEmbeddings::TLDA *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TAnyEmbeddingCalcer_TKNN: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::NEmbeddings::TKNN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTAnyEmbeddingCalcerVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTAnyEmbeddingCalcer(
        verifier,  values->Get(i), types->GetEnum<TAnyEmbeddingCalcer>(i))) {
      return false;
    }
  }
  return true;
}

inline void *TAnyEmbeddingCalcerUnion::UnPack(const void *obj, TAnyEmbeddingCalcer type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case TAnyEmbeddingCalcer_TLDA: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::NEmbeddings::TLDA *>(obj);
      return ptr->UnPack(resolver);
    }
    case TAnyEmbeddingCalcer_TKNN: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::NEmbeddings::TKNN *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> TAnyEmbeddingCalcerUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case TAnyEmbeddingCalcer_TLDA: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::NEmbeddings::TLDAT *>(value);
      return CreateTLDA(_fbb, ptr, _rehasher).Union();
    }
    case TAnyEmbeddingCalcer_TKNN: {
      auto ptr = reinterpret_cast<const NCatBoostFbs::NEmbeddings::TKNNT *>(value);
      return CreateTKNN(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline TAnyEmbeddingCalcerUnion::TAnyEmbeddingCalcerUnion(const TAnyEmbeddingCalcerUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case TAnyEmbeddingCalcer_TLDA: {
      value = new NCatBoostFbs::NEmbeddings::TLDAT(*reinterpret_cast<NCatBoostFbs::NEmbeddings::TLDAT *>(u.value));
      break;
    }
    case TAnyEmbeddingCalcer_TKNN: {
      value = new NCatBoostFbs::NEmbeddings::TKNNT(*reinterpret_cast<NCatBoostFbs::NEmbeddings::TKNNT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void TAnyEmbeddingCalcerUnion::Reset() {
  switch (type) {
    case TAnyEmbeddingCalcer_TLDA: {
      auto ptr = reinterpret_cast<NCatBoostFbs::NEmbeddings::TLDAT *>(value);
      delete ptr;
      break;
    }
    case TAnyEmbeddingCalcer_TKNN: {
      auto ptr = reinterpret_cast<NCatBoostFbs::NEmbeddings::TKNNT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = TAnyEmbeddingCalcer_NONE;
}

inline const NCatBoostFbs::NEmbeddings::TEmbeddingCalcer *GetTEmbeddingCalcer(const void *buf) {
  return ::flatbuffers::GetRoot<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer>(buf);
}

inline const NCatBoostFbs::NEmbeddings::TEmbeddingCalcer *GetSizePrefixedTEmbeddingCalcer(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer>(buf);
}

inline TEmbeddingCalcer *GetMutableTEmbeddingCalcer(void *buf) {
  return ::flatbuffers::GetMutableRoot<TEmbeddingCalcer>(buf);
}

inline NCatBoostFbs::NEmbeddings::TEmbeddingCalcer *GetMutableSizePrefixedTEmbeddingCalcer(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer>(buf);
}

inline bool VerifyTEmbeddingCalcerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer>(nullptr);
}

inline bool VerifySizePrefixedTEmbeddingCalcerBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer>(nullptr);
}

inline const char *TEmbeddingCalcerExtension() {
  return "bfbs";
}

inline void FinishTEmbeddingCalcerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTEmbeddingCalcerBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NCatBoostFbs::NEmbeddings::TEmbeddingCalcer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<NCatBoostFbs::NEmbeddings::TEmbeddingCalcerT> UnPackTEmbeddingCalcer(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::NEmbeddings::TEmbeddingCalcerT>(GetTEmbeddingCalcer(buf)->UnPack(res));
}

inline std::unique_ptr<NCatBoostFbs::NEmbeddings::TEmbeddingCalcerT> UnPackSizePrefixedTEmbeddingCalcer(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NCatBoostFbs::NEmbeddings::TEmbeddingCalcerT>(GetSizePrefixedTEmbeddingCalcer(buf)->UnPack(res));
}

}  // namespace NEmbeddings
}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_EMBEDDINGFEATURECALCERS_NCATBOOSTFBS_NEMBEDDINGS_H_
