# Дополнения к стайлгайду:
1. Все классы у которых нет декларации в .h файле должны находиться в анонимном неймспейсе, а все функции у которых нет декларации в .h должны быть помечены как `static`
2. `TDSVWriter` => `TDsvWriter` - аббревиатуры пишем маленькими буквами
3. Не используем сокращения, кроме общепринятых (типа `len`, `idx`, `tmp`).
4. Однобуквенные переменные только для цикла for (в порядке вложенности: `i`, `j`, `k`). Включая тесты и однострочные функции.
5. В названии функции используем глаголы, глагол идет на первом месте:
    `ui64 FeatureCount()` => `ui64 GetFeatureCount()` если просто геттер, `ui64 CountFeatures()`, если там какая-то работа в функции.
6. Имена файлов - через подчеркивание. И без сокращений тоже.
7. Про пустые строки:
    - В большинстве случаев достаточно одной пустой строки.
    - Две пустые строки норм ставить на верхнем уровне: между функциями, классами или классом и функцией (можно и одну)
    - Три -- вообще никогда не нужно.
8. Параметры в функциях передаются в следующем порядке:
    1. Входные (in) параметры (если есть)
    2. Параметры, состояние которых функция и использует и меняет (inout) (если есть). Обязательно передавать по указателю.
    3. Выходные (out) параметры (функция полностью меняет их состояние, не используя текущее, в отличие от inout). Обязательно передавать по указателю.
10. Пробел после template:
    ```
    template <class TSomeType>
    class TMyClass {
    };
    ```
11. Отступы при объявлении или вызове функции с большим числом и/или длиной параметров - аргументы начинаются со строки 2 + отступ в 4 пробела.
    ```
    void WriteHistory(
        const TVector<TString>& metricsDescription,
        const TVector<TVector<double>>& learnErrorsHistory,
        const TVector<TVector<TVector<double>>>& testErrorsHistory, // [iter][test][metric]
        const TVector<TVector<double>>& timeHistory,
        const TString& learnToken,
        const TVector<const TString>& testTokens,
        TLogger* logger) {
    ```
12. Длина строки <= 110 символов
13. Для размеров (массивов, но не только) и индексов следует предпочитать беззнаковые типы конкретного размера (для портабельности) - `ui64`, `ui32`, ... . Следует помнить, что CatBoost может работать с потенциально большими данными, так что во многих случаях (когда это не экономит память) разумным умолчанием будет являться `ui64`.
14. Если весь код модуля находится только в заголовочном файле (`<module_name>.h`), то все равно нужно создать парный ему `<module_name>.cpp` файл, который будет содержать только `#include "<module_name>.h" ` и включить этот .cpp файл в SRCS в ya.make.
15. Если при вызове функции из чтения кода вызова сразу не ясно, что значит выражение, передаваемое как какой-то из параметров (например, это bool литерал - `true` или `false`, в функции у которой несколько параметров такого типа), то рекомендуется вставить inline комментарий с названием параметра перед передаваемым выражением:
    ```
    MySort(/*useParallelImplementation*/ true, &container);
    ```
