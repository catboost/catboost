FAKEID=4953011

CPP_FAKEID=4659992

CURDIR=.
BINDIR=bin:/
SRCDIR=
YMAKE=ymake
ECHO=echo
INCLUDE_EXTS=.h .hh .hpp .rli .cuh .inc .i
CPP_EXT=.cpp
OBJ_SUF=
CFLAGS=
EXTRA_C_FLAGS=

DISABLE_RESOLVE_TO_MODULE_DIR=yes
TRAVERSE_INDUCED_DEPS=no
OUTPUT_INCLUDE_SKIP_STAR=no
SYSINCL=
SYSINCL+=build/sysincl/libc-to-nothing.yml
SYSINCL+=build/sysincl/stl-to-nothing.yml
SYSINCL+=build/sysincl/windows.yml
SYSINCL+=build/sysincl/misc.yml

when ($MUSL == "yes") {
    SYSINCL+=build/sysincl/libc-to-musl.yml
}

when ($OS_WINDOWS == "yes") {
    SYSINCL+=build/sysincl/misc-win.yml
}

when ($OS_ANDROID == "yes") {
    SYSINCL+=build/sysincl/android.yml
}


__COMMA__=${comma:""}

# Only to fix warning from library/build_info
SANDBOX_TASK_ID=0
KOSHER_SVN_VERSION=

ARCADIA_TEST_ROOT=../arcadia_tests_data/
DEFAULT_REQUIREMENTS=network:restricted

PEERDIRS_RULES_PATH=\
    build/rules/go/vendor.policy \
    build/rules/contrib.policy

FAIL_MODULE_CMD=$YMAKE_PYTHON ${input:"build/scripts/fail_module_cmd.py"} $TARGET ${kv;hide:"p ER"} ${kv;hide:"pc red"}

when ($USE_GCCFILTER == "yes") {
    GCCFILTER=${ARCADIA_ROOT}/devtools/gccfilter/gccfilter.pl
    when ($USE_GCCFILTER_COLOR == "yes") {
        GCCFILTER+=-c
    }
}
otherwise {
    GCCFILTER=
}

when ($CODENAVIGATION && $NOCODENAVIGATION != "yes") {
    PY_PROGRAM_LINK_EXE=$LINK_EXE ${kv;hide:"pyndex $TARGET"}
    YNDEXER_ARGS=$YMAKE_PYTHON ${input:"build/scripts/yndexer.py"} $CPPYNDEXER_RESOURCE_GLOBAL/yndexer 1500 $(SOURCE_ROOT) $ARCADIA_BUILD_ROOT ${input:SRC}
    YNDEXER_OUTPUT=$YNDEXER_OUTPUT_FILE
}
otherwise {
    PY_PROGRAM_LINK_EXE=$LINK_EXE
    YNDEXER_ARGS=
    YNDEXER_OUTPUT=
}

COVERAGE_FLAGS=
when ($GCOV_COVERAGE) {
    COVERAGE_FLAGS=-fprofile-arcs -ftest-coverage
    EXTRA_OUTPUT=$EXTRA_COVERAGE_OUTPUT
}

when ($ARCH_AARCH64 == "yes") {
    CFLAGS+=-fsigned-char -DIOV_MAX=1024
}
when ($ARCH_PPC64LE == "yes") {
    CFLAGS+=-fsigned-char
}

when ($OS_CYGWIN == "yes") {
    CFLAGS+=-D_LDBL_EQ_DBL=1 -U__STRICT_ANSI__
    USE_ASMLIB=no
    FSTACK=
    PICFLAGS=
}

CFLAGS+=$COVERAGE_FLAGS
LDFLAGS+=$COVERAGE_FLAGS

CHECKFLAG=
LEX_FLAGS=
NO_MAPREDUCE=

when ($NO_MAPREDUCE ==  "yes") {
    C_DEFINES+=-DNO_MAPREDUCE
}

SKIP_JUNK=yes

# USE_INTERNAL_STL is an internal flag (set on by default) but may be used externally to
# select system standard C++ library when USE_INTERNAL_STL=no is set.
#
# USE_STL_SYSTEM=yes is a regular way to select system standard C++ library.
#
when ($USE_STL_SYSTEM == "yes") {
    USE_INTERNAL_STL=no
}

when ($USE_INTERNAL_STL == "no") {
    USE_STL_SYSTEM=yes
}
otherwise {
    USE_INTERNAL_STL=yes
    SYSINCL+=build/sysincl/stl-to-libcxx.yml
}

USE_ARCADIA_PYTHON=yes
USE_ARCADIA_LIBM=no
USE_EAT_MY_DATA=no

SFDL_TMP_OUT= ${output;tmp:SRC.tmp}

when (!$USE_PERL_SYSTEM) {
    USE_PERL_SYSTEM=yes
}

when ($USE_LOCAL_TOOLS == "yes") {
    PERL=$LOCAL_PERL
    PERL_VERSION=$LOCAL_PERL_VERSION
    PERL_PRIVLIB=$LOCAL_PERL_PRIVLIB
    PERL_ARCHLIB=$LOCAL_PERL_ARCHLIB
    when ($LOCAL_PERL_LIBS) {
        PERL_LIBS=$LOCAL_PERL_LIBS
    }
}
otherwise {
    PERL=NO-PERL-SELECTED
    PERL_VERSION=NO-PERL-SELECTED-VERSION
    PERL_PRIVLIB=NO-PERL-SELECTED-PRIVLIB
    PERL_ARCHLIB=NO-PERL-SELECTED-ARCHLIB
}

PERL_LD_LIBRARY_PATH=
PERL_INCLUDE=

when ($USE_PERL_SYSTEM == "yes") {
    PERL_LIB_ARCH=

    select ($OS_SDK) {
        "ubuntu-12" ? {
            PERL_VERSION=5.14
            PERL_FROM_SANDBOX=yes
        }
        "ubuntu-14" ? {
            PERL_VERSION=5.18
            PERL_FROM_SANDBOX=yes
        }
        "ubuntu-16" ? {
            PERL_VERSION=5.22
            PERL_FROM_SANDBOX=yes
            PERL_LIB_ARCH=/x86_64-linux-gnu
        }
        "ubuntu-18" ? {
            PERL_VERSION=5.26
            PERL_FROM_SANDBOX=yes
            PERL_LIB_ARCH=/x86_64-linux-gnu
        }
    }

    when ($PERL_FROM_SANDBOX == "yes") {
        PERL=$SYSTEM_PERL_RESOURCE_GLOBAL/perl${PERL_VERSION}/bin/perl
        PERL_ARCHLIB=$SYSTEM_PERL_RESOURCE_GLOBAL/perl${PERL_VERSION}/lib$PERL_LIB_ARCH/perl/${PERL_VERSION}
        PERL_PRIVLIB=$SYSTEM_PERL_RESOURCE_GLOBAL/perl${PERL_VERSION}/share/perl/${PERL_VERSION}
        PERL_LIBS=$SYSTEM_PERL_RESOURCE_GLOBAL/perl${PERL_VERSION}/lib${PERL_LIB_ARCH}
        PERL_LD_LIBRARY_PATH=${env:"LD_LIBRARY_PATH=$SYSTEM_PERL_RESOURCE_GLOBAL/perl${PERL_VERSION}/lib"}

        # Perl searches it's modules in INC@ paths. They can not be sysrooted or disabled (at least I haven't found a way),
        # so default Perl module directories should be prepended to perl command lines when using non-local perl.
        PERL_INCLUDE=-I${PERL_ARCHLIB} -I${PERL_PRIVLIB}
    }
}

PERLSUFFIX=-csuffix .cpp
PERLOUTPUT=${stdout;output:SRC.cpp}
when ($PERLC == "yes") {
    PERLSUFFIX=-csuffix .c
    PERLOUTPUT=${stdout;output:SRC.c}
}
XSUBPPFLAGS=

ARCH_TOOL=${tool:"tools/archiver"}
PROTOC=${tool:"contrib/tools/protoc"}
PROTOC_STYLEGUIDE_OUT=--cpp_styleguide_out=$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE
PROTOC_PLUGIN_STYLEGUIDE=--plugin=protoc-gen-cpp_styleguide=${tool:"contrib/tools/protoc/plugins/cpp_styleguide"}
FML_TOOL=${tool:"tools/relev_fml_codegen"}
FML_UNUSED_TOOL=${tool:"tools/relev_fml_unused"}
LUA_TOOL=${tool:"tools/lua"}
ENUM_PARSER_TOOL=${tool:"tools/enum_parser/enum_parser"}

CYTHON_SCRIPT=${input:"${ARCADIA_ROOT}/contrib/tools/cython/cython.py"}
CYTHON_OUTPUT_INCLUDES=${output_include;hide:"contrib/libs/python/Include/Python.h"} \
${output_include;hide:"contrib/libs/python/Include/pyconfig.h"} \
${output_include;hide:"contrib/libs/python/Include/compile.h"} \
${output_include;hide:"contrib/libs/python/Include/frameobject.h"} \
${output_include;hide:"contrib/libs/python/Include/traceback.h"}

CYTHON_OPTIONS=
when ($OS_LINUX) {
    CYTHON_OPTIONS += -E UNAME_SYSNAME=Linux
}
elsewhen ($OS_DARWIN) {
    CYTHON_OPTIONS += -E UNAME_SYSNAME=Darwin
}
elsewhen ($OS_WINDOWS) {
    CYTHON_OPTIONS += -E UNAME_SYSNAME=Windows
}

SWIG_DEFAULT_INCLUDES=\
    contrib/tools/swig/Lib/python/python.swg \
    contrib/tools/swig/Lib/swig.swg
SWIG_DEFAULT_INDUCED=\
    contrib/libs/python/Include/Python.h \
    string.h \
    stdexcept


# PYTHON_DISTR={ "default" | "macos-brew" }  determine python system supply
# see build/platform/python/ya.make
PYTHON_DISTR="default"
when ($USE_SYSTEM_PYTHON) {
    USE_ARCADIA_PYTHON=no
    select ($USE_SYSTEM_PYTHON) {
        "2.7" ? {
            _SYSTEM_PYTHON27=yes
            PY_VERSION=2.7
            PY_FRAMEWORK_VERSION=2.7
        }
        "3.4" ? {
            _SYSTEM_PYTHON34=yes
            PY_VERSION=3.4m
            PY_FRAMEWORK_VERSION=3.4
        }
        "3.5" ? {
            _SYSTEM_PYTHON35=yes
            PY_VERSION=3.5m
            PY_FRAMEWORK_VERSION=3.5
        }
        "3.6" ? {
            _SYSTEM_PYTHON36=yes
            PY_VERSION=3.6m
            PY_FRAMEWORK_VERSION=3.6
        }
        "3.7" ? {
            _SYSTEM_PYTHON37=yes
            PY_VERSION=3.7m
            PY_FRAMEWORK_VERSION=3.7
        }
    }
}

#TODO: reuse PYTHON_PATH in other vars
PYTHON_TOOL=${ARCADIA_BUILD_ROOT}/contrib/tools/python/python
PYTHON_PATH=contrib/tools/python
PYTHON_BS_TOOL=${tool:"contrib/tools/python/bootstrap"}
when ($USE_ARCADIA_PYTHON == "no") {
    PYTHON_TOOL=python
    PYTHON_BS_TOOL=python
}
DEFAULT_ALLOCATOR=LF

when ($OS_ANDROID == "yes" || $MSVC == "yes") {
    DEFAULT_ALLOCATOR=J
}

when ($OS_CYGWIN == "yes") {
    DEFAULT_ALLOCATOR=SYSTEM
}

when ($SANITIZER_TYPE) {
    when ($SANITIZER_TYPE != "no") {
        DEFAULT_ALLOCATOR=SYSTEM
    }
    when ($SANITIZER_TYPE == "pg") {
        DEFAULT_ALLOCATOR=BS
    }
}

### @usage: CHECK_CONFIG_H(<conf_header>) # internal
###
### This internal macro adds checking code for configutaion header in external (contrib) library
### The check is needed to avoid conflicts on certain types and functions available in arcadia
### See https://a.yandex-team.ru/arc/trunk/arcadia/build/scripts/check_config_h.py for exact details
macro CHECK_CONFIG_H(Conf) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/check_config_h.py"} ${input;rootrel:Conf} ${output;nopath;noext:Conf.config.cpp} ${kv;hide:"p CH"} ${kv;hide:"pc yellow"}
    OUTPUT_INCLUDES=$Conf
}

PROTO_NAMESPACE=
PROTO_PATH=$ARCADIA_ROOT/contrib/libs/protobuf

GEN_PY_PROTOS=$YMAKE_PYTHON ${input:"build/scripts/gen_py_protos.py"}

CPP_PROTO_CMDLINE=
CPP_PROTO_OPTS=
CPP_PROTO_OUTS=
CPP_PROTO_SUFFIXES=.pb.h .pb.cc

CPP_EV_OPTS=
CPP_EV_OUTS=

PY_PROTO_OPTS=
PY_PROTO_OUTS=
PY_PROTO_OUTS_INTERNAL=
PY_PROTO_DEPS=
PY_PROTO_SUFFIXES=_pb2.py
PY_EVLOG_SUFFIXES=_ev_pb2.py

JAVA_PROTO_ARGS=

OPTIMIZE_PY_PROTOS_FLAG=no

### @usage: OPTIMIZE_PY_PROTOS()  # internal
###
### Enable Python proto optimization using embedding corresponding C++ code into binary.
### Python protobuf runtime will use C++ implementation instead of Python one if former is available
### This is default mode for most PROTO_LIBRARY's and PY_LIBRARY's, some system ones being exceptions
macro OPTIMIZE_PY_PROTOS() {
    SET(OPTIMIZE_PY_PROTOS_FLAG yes)
}

### @usage: NO_OPTIMIZE_PY_PROTOS() # internal
###
### Disable Python proto optimization using embedding corresponding C++ code into binary.
### Python protobuf runtime will use C++ implementation instead of Python one if former is available
### This is default mode only for some system libraries
macro NO_OPTIMIZE_PY_PROTOS() {
    SET(OPTIMIZE_PY_PROTOS_FLAG no)
}

macro _PROTO_PLUGIN_ARGS_BASE(Name, Tool) {
    .CMD=--plugin=protoc-gen-${Name}=\${tool:"$Tool"} --${Name}_out=$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE
}

macro _ADD_PY_PROTO_OUT(Suf) {
    SET_APPEND(PY_PROTO_OUTS \${output;hide;noauto;norel;nopath;noext;suf=$Suf:File})
    SET_APPEND(PY_PROTO_OUTS_INTERNAL \${output;hide;noauto;norel;nopath;noext;suf=__int__$Suf:File} \${hide;kv:"ext_out_name_for_\${nopath;noext;suf=__int__$Suf:File} \${nopath;noext;suf=$Suf:File}"})
    # XXX fix variable expansion in plugins
    SET(PY_PROTO_SUFFIXES $PY_PROTO_SUFFIXES $Suf)
}

GO_PROTOC_GEN_TOOL=vendor/github.com/golang/protobuf/protoc-gen-go
GO_PROTOC_GEN_PLUGINS=

GO_PROTOBUF_WELLKNOWN_TYPES=\
    vendor/github.com/golang/protobuf/ptypes \
    vendor/github.com/golang/protobuf/ptypes/any \
    vendor/github.com/golang/protobuf/ptypes/duration \
    vendor/github.com/golang/protobuf/ptypes/empty \
    vendor/github.com/golang/protobuf/ptypes/struct \
    vendor/github.com/golang/protobuf/ptypes/timestamp \
    vendor/github.com/golang/protobuf/ptypes/wrappers \
    vendor/google.golang.org/genproto/protobuf/api \
    vendor/google.golang.org/genproto/protobuf/field_mask \
    vendor/google.golang.org/genproto/protobuf/ptype \
    vendor/google.golang.org/genproto/protobuf/source_context

macro _GO_PROTOC_PLUGIN_ARGS_BASE(Name, Tool, Plugins="") {
    .CMD=--plugin=protoc-gen-${Name}=${tool:Tool} --${Name}_out=$Plugins$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE
}

macro _GO_PROTO_CMD(File) {
    .CMD=${cwd;rootdir;input:File} $YMAKE_PYTHON ${input:"build/scripts/go_proto_wrapper.py"} $GO_ARCADIA_PROJECT_PREFIX $GO_CONTRIB_PROJECT_PREFIX $PROTOC -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT/$PROTO_NAMESPACE -I=$ARCADIA_BUILD_ROOT -I=$PROTO_PATH ${input;rootrel:File} ${output;hide;noauto;norel;nopath;noext;suf=.pb.go:File} $_GO_PROTOC_PLUGIN_ARGS_BASE(go $GO_PROTOC_GEN_TOOL $GO_PROTOC_GEN_PLUGINS) ${kv;hide:"p PT"} ${kv;hide:"pc yellow"}
    .PEERDIR=${GOSTD}/fmt ${GOSTD}/math vendor/github.com/golang/protobuf/proto vendor/github.com/golang/protobuf/protoc-gen-go/descriptor contrib/libs/protobuf ${GO_PROTOBUF_WELLKNOWN_TYPES}
}

macro _CPP_PROTO_CMD(File) {
    .CMD=$CPP_PROTO_CMDLINE $CPP_PROTO_OPTS $CPP_PROTO_OUTS ${kv;hide:"p PB"} ${kv;hide:"pc yellow"}
    .PEERDIR=contrib/libs/protobuf
}

macro _CPP_EVLOG_CMD(File) {
    .CMD=$CPP_PROTO_CMDLINE $CPP_EV_OPTS $CPP_EV_OUTS ${kv;hide:"p EV"} ${kv;hide:"pc yellow"}
    .PEERDIR=library/eventlog contrib/libs/protobuf
}

macro _CPP_PROTO_EVLOG_CMD(File) {
    # process .proto as .ev
    .CMD=$CPP_PROTO_CMDLINE $CPP_EV_OPTS $CPP_PROTO_OUTS ${kv;hide:"p PB"} ${kv;hide:"pc yellow"}
    .PEERDIR=library/eventlog contrib/libs/protobuf
}

macro _MAPKIT_CPP_PROTO_CMD(File) {
    # We don't support GRPC for protoc used here
    .CMD=$CPP_PROTO_CMDLINE $CPP_PROTO_OUTS ${kv;hide:"p PB"} ${kv;hide:"pc yellow"}
    .PEERDIR=build/external_resources/mapkit_sdk
}

macro _PY_PROTO_CMD_BASE(File, Suf, Args...) {
    .CMD=$PROTOC -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT/$PROTO_NAMESPACE -I=$ARCADIA_BUILD_ROOT -I=$PROTO_PATH --python_out=$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE ${input;rootrel:File} ${output;hide;noauto;norel;nopath;noext;suf=$Suf:File} ${kv;hide:"p PT"} ${kv;hide:"pc yellow"} $Args
}

macro _PY_PROTO_CMD(File) {
    .CMD=${cwd;rootdir;input:File} $_PY_PROTO_CMD_BASE($File _pb2.py $PY_PROTO_OPTS $PY_PROTO_OUTS)
}

macro _PY_PROTO_CMD_INTERNAL(File) {
    .CMD=${cwd;rootdir;input:File} $GEN_PY_PROTOS --suffixes $PY_PROTO_SUFFIXES -- $_PY_PROTO_CMD_BASE($File __int___pb2.py $PY_PROTO_OPTS $PY_PROTO_OUTS_INTERNAL ${hide;kv:"ext_out_name_for_${nopath;noext;suf=__int___pb2.py:File} ${nopath;noext;suf=_pb2.py:File}"})
}

macro _JAVA_PROTO_CMD(File) {
    .CMD=${cwd;rootdir;input:File} $YMAKE_PYTHON ${input:"build/scripts/tared_protoc.py"} --tar-output ${output;norel;nopath;noext;suf=.jsrc:File} --protoc-out-dir $ARCADIA_BUILD_ROOT/java_out $PROTOC -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT -I=$PROTO_PATH --java_out=$ARCADIA_BUILD_ROOT/java_out ${input;rootrel:File} ${kv;hide:"p PT"} ${kv;hide:"pc yellow"} $JAVA_PROTO_ARGS
}


### @usage: XS_PROTO(InputProto Dir Outputs...) # deprecated
###
### Generate Perl code from protobuf.
### In order to use this macro one should predict all outputs protoc will emit from input_proto file and enlist those as outputs
macro XS_PROTO(File, Dir, Outputs...) {
    .CMD=$PROTOC -I=${ARCADIA_ROOT}/${Dir} -I=${ARCADIA_ROOT} -I=${PROTO_PATH} --perlxs_out=${BINDIR} ${input:File} ${hide;output:Outputs} ${output_include;hide;nopath;noext;suf=.pb.h:File}
    PEERDIR(${Dir})
    ADDINCL(${ARCADIA_BUILD_ROOT}/${Dir})
}

### @usage: PROTO2FBS(InputProto)
###
### Produce flatbuf schema out of protobuf descrition
macro PROTO2FBS(File) {
    .CMD=${cwd:BINDIR} ${tool:"contrib/tools/flatc"} -I . -I ${ARCADIA_ROOT} --proto ${input:File} ${output;hide;nopath;noext:File.fbs} ${kv;hide:"p FBS"} ${kv;hide:"pc yellow"}
}

when ($PY_PROTOS_FOR == "yes") {
    PEERDIR+=contrib/libs/protobuf/python
}

macro _PY_EVLOG_CMD_BASE(File, Suf, Args...) {
    .CMD=$_PY_PROTO_CMD_BASE($File $Suf $Args)
    .PEERDIR=library/eventlog/proto
}

macro _PY_EVLOG_CMD(File) {
    .CMD=${cwd;rootdir;input:File} $_PY_EVLOG_CMD_BASE($File _ev_pb2.py)
}

macro _PY_EVLOG_CMD_INTERNAL(File) {
    .CMD=${cwd;rootdir;input:File} $GEN_PY_PROTOS --suffixes $PY_EVLOG_SUFFIXES -- $_PY_EVLOG_CMD_BASE($File __int___ev_pb2.py ${hide;kv:"ext_out_name_for_${nopath;noext;suf=__int___ev_pb2.py:File} ${nopath;noext;suf=_ev_pb2.py:File}"})
}

macro _JAVA_EVLOG_CMD(File) {
    .CMD=$COPY_CMD ${input:File} ${output;nopath;noext;norel;suf=_ev.proto:File} ${kv;hide:"p EV"} ${kv;hide:"pc yellow"}
    .PEERDIR=library/eventlog/proto
}

RUN_NO_SANITIZE=$YMAKE_PYTHON ${input:"build/scripts/run_tool.py"} --

when ($IS_CROSS_SANITIZE) {
    RUN_NO_SANITIZE=
}

YIELD=$YMAKE_PYTHON ${input:"build/scripts/yield_line.py"} -- ${BINDIR}/__args
XARGS=$YMAKE_PYTHON ${input:"build/scripts/xargs.py"} -- ${BINDIR}/__args

RESPFILE_CMD=$YMAKE_PYTHON ${input:"build/scripts/writer.py"}

FS_TOOLS=$YMAKE_PYTHON ${input:"build/scripts/fs_tools.py"}

COPY_CMD=$FS_TOOLS copy
REMOVE_FILE=$FS_TOOLS remove
MOVE_FILE=$FS_TOOLS rename

MSVC_DYNAMICBASE=/DYNAMICBASE
when ($ALLOCATOR == "LF") {
    MSVC_DYNAMICBASE=/DYNAMICBASE:NO
}

SANITIZER_CFLAGS=

GRPC_FLAG=no

### @usage: GRPC()
###
### Emit GRPC code for all .proto files in a PROTO_LIBRARY
### This works for all available PROTO_LIBRARY versions (C++, Python 2.x, Pyton 3.x, Java and Go)
macro GRPC() {
    SET(GRPC_FLAG yes)

    # CPP
    SET_APPEND(CPP_PROTO_OPTS $_PROTO_PLUGIN_ARGS_BASE(grpc_cpp contrib/tools/protoc/plugins/grpc_cpp))

    when ($OPTIMIZE_PY_PROTOS_FLAG == "yes") {
        CPP_PROTO_OUTS+=${output;hide;norel;nopath;noext;noauto:File.grpc.pb.cc} ${output;hide;norel;nopath;noext;noauto:File.grpc.pb.h}
    }
    otherwise {
        CPP_PROTO_OUTS+=${output;hide;norel;nopath;noext:File.grpc.pb.cc} ${output;hide;norel;nopath;noext:File.grpc.pb.h}
    }

    SET_APPEND(PROTO_HEADER_INCLUDE contrib/libs/grpc/include/grpc++/impl/codegen/async_stream.h contrib/libs/grpc/include/grpc++/impl/codegen/async_unary_call.h contrib/libs/grpc/include/grpc++/impl/codegen/method_handler_impl.h contrib/libs/grpc/include/grpc++/impl/codegen/proto_utils.h contrib/libs/grpc/include/grpc++/impl/codegen/rpc_method.h contrib/libs/grpc/include/grpc++/impl/codegen/service_type.h contrib/libs/grpc/include/grpc++/impl/codegen/status.h contrib/libs/grpc/include/grpc++/impl/codegen/stub_options.h contrib/libs/grpc/include/grpc++/impl/codegen/sync_stream.h contrib/libs/grpc/include/grpcpp/impl/codegen/async_stream.h)
    SET_APPEND(PROTO_SOURCE_INCLUDE contrib/libs/grpc/include/grpc++/impl/codegen/async_stream.h contrib/libs/grpc/include/grpc++/impl/codegen/async_unary_call.h contrib/libs/grpc/include/grpc++/impl/codegen/channel_interface.h contrib/libs/grpc/include/grpc++/impl/codegen/client_unary_call.h contrib/libs/grpc/include/grpc++/impl/codegen/method_handler_impl.h contrib/libs/grpc/include/grpc++/impl/codegen/rpc_service_method.h contrib/libs/grpc/include/grpc++/impl/codegen/service_type.h contrib/libs/grpc/include/grpc++/impl/codegen/sync_stream.h)
    # XXX fix variable expansion in plugins
    SET(CPP_PROTO_SUFFIXES $CPP_PROTO_SUFFIXES .grpc.pb.h .grpc.pb.cc)

    # Python
    SET_APPEND(PY_PROTO_OPTS $_PROTO_PLUGIN_ARGS_BASE(grpc_py contrib/tools/protoc/plugins/grpc_python))
    _ADD_PY_PROTO_OUT(_pb2_grpc.py)
    # XXX fix variable expansion in plugins
    SET(PY_PROTO_DEPS $PY_PROTO_DEPS contrib/libs/grpc/python contrib/libs/grpc)

    # Java
    SET_APPEND(JAVA_PROTO_ARGS --plugin=protoc-gen-grpc_java=\${tool:"contrib/tools/protoc/plugins/grpc_java"} --grpc_java_out=$ARCADIA_BUILD_ROOT/java_out)
}


### @usage: YDB_GRPC() # reserved
### Reserved for YDB specific GRPC plugin
macro YDB_GRPC() {
    GRPC()
}

# variables must be defined for all module types to make generate_mf.py work
MODULE_PREFIX=
MODULE_SUFFIX=
LICENSE_NAMES=
NO_GPL=
NO_GPL_FLAG=
when ($NO_GPL == "yes") {
    NO_GPL_FLAG=--no-gpl
}
NEED_PLATFORM_PEERDIRS=yes
PEERDIR_TEST_TOOL=yes

PYTHON2=no
PYTHON3=no

### @usage: _BASE_UNIT  # internal
###
### The base of all buildable modules describing commong logic for all modules.
### To avoid surprises all buildable modules are better to be inherited from it or its descendants
module _BASE_UNIT {
    .EXTS=.*
    .CMD=TOUCH_UNIT
    .NODE_TYPE=Bundle
    .PEERDIR_POLICY=as_include
    .RESTRICTED=GRPC INDUCED_DEPS FUZZ_DICTS FUZZ_OPTS
    .FINAL_TARGET=no

    PEERDIR_TAGS=CPP_PROTO PY2 PY2_NATIVE YQL_UDF_STATIC __EMPTY__
    PROTO_SOURCE_INCLUDE=contrib/libs/protobuf/stubs/common.h contrib/libs/protobuf/generated_message_util.h contrib/libs/protobuf/repeated_field.h contrib/libs/protobuf/extension_set.h contrib/libs/protobuf/generated_message_reflection.h contrib/libs/protobuf/service.h contrib/libs/protobuf/messagext.h
    PROTO_HEADER_INCLUDE=contrib/libs/protobuf/stubs/once.h contrib/libs/protobuf/io/coded_stream.h contrib/libs/protobuf/wire_format_lite_inl.h contrib/libs/protobuf/descriptor.h contrib/libs/protobuf/reflection_ops.h contrib/libs/protobuf/wire_format.h contrib/libs/protobuf/map_entry.h contrib/libs/protobuf/map_field_inl.h
    PROTO_HEADER_EXTS=.pb.h

    CPP_PROTO_CMDLINE=${cwd;rootdir;input:File} $PROTOC -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT/$PROTO_NAMESPACE -I=$ARCADIA_BUILD_ROOT -I=$PROTO_PATH --cpp_out=$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE $PROTOC_STYLEGUIDE_OUT $PROTOC_PLUGIN_STYLEGUIDE ${input;rootrel:File}
    CPP_EV_OPTS=--plugin=protoc-gen-event2cpp=${tool:"tools/event2cpp"} --event2cpp_out=$ARCADIA_BUILD_ROOT -I=$ARCADIA_ROOT/library/eventlog

    DEFAULT(PY_PROTOS_FOR no)
    DEFAULT(BUILD_PROTO_AS_EVLOG no)

    when ($OPTIMIZE_PY_PROTOS_FLAG == "yes") {
        CPP_PROTO_OUTS+=${output;hide;norel;nopath;noext;noauto:File.pb.cc} ${output;main;hide;norel;nopath;noext;noauto:File.pb.h}
        CPP_EV_OUTS+=${output;hide;norel;noauto:File.pb.cc} ${output;hide;norel;noauto:File.pb.h}
    }
    otherwise {
        CPP_PROTO_OUTS+=${output;hide;norel;nopath;noext:File.pb.cc} ${output;main;hide;norel;nopath;noext:File.pb.h}
        CPP_EV_OUTS+=${output;hide;norel:File.pb.cc} ${output;hide;norel:File.pb.h}
    }

    when ($PY_PROTOS_FOR == "yes") {
        MACRO_ALIAS(EVLOG_CMD _PY_EVLOG_CMD)
        MACRO_ALIAS(PROTO_CMD _PY_PROTO_CMD)
    }
    otherwise {
        MACRO_ALIAS(EVLOG_CMD _CPP_EVLOG_CMD)
        when ($BUILD_PROTO_AS_EVLOG == "yes") {
            MACRO_ALIAS(PROTO_CMD _CPP_PROTO_EVLOG_CMD)
        }
        otherwise {
            when ($ARCADIA_MAPKIT) {
                PROTOC=$MAPKIT_SDK_RESOURCE_GLOBAL/mapkit_sdk/bin/protoc
                PROTOC_STYLEGUIDE_OUT=
                PROTOC_PLUGIN_STYLEGUIDE=
                PROTO_PATH=$MAPKIT_SDK_RESOURCE_GLOBAL/mapkit_sdk/include
                MACRO_ALIAS(PROTO_CMD _MAPKIT_CPP_PROTO_CMD)
                PROTO_SOURCE_INCLUDE=
                PROTO_HEADER_INCLUDE=
            }
            otherwise {
                MACRO_ALIAS(PROTO_CMD _CPP_PROTO_CMD)
            }
        }
    }

    FLATBUFFER_HEADER_INCLUDE=contrib/libs/flatbuffers/include/flatbuffers/flatbuffers.h
    FLATBUFFER64_HEADER_INCLUDE=contrib/libs/flatbuffers64/include/flatbuffers/flatbuffers.h

    when ($ARCADIA_MAPKIT) {
        FLATBUFFER_HEADER_INCLUDE=
        FLATBUFFER64_HEADER_INCLUDE=
    }

    SANITIZER_DEFINED=no

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no" && $SANITIZER_TYPE != "pg") {
        CFLAGS+=-fsanitize=$SANITIZER_TYPE -D${SANITIZER_TYPE}_sanitizer_enabled -fsanitize-blacklist=${input:"build/sanitize-blacklist.txt"} $SANITIZER_CFLAGS
        LDFLAGS+=-fsanitize=$SANITIZER_TYPE -fsanitize-blacklist=${input:"build/sanitize-blacklist.txt"}
        SANITIZER_DEFINED=yes
    }

    when ($SANITIZE_COVERAGE && $SANITIZE_COVERAGE != "no") {
        CFLAGS+=-fsanitize-coverage=$SANITIZE_COVERAGE
        LDFLAGS+=-fsanitize-coverage=$SANITIZE_COVERAGE
    }

    when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no") {
        CFLAGS+=-fprofile-instr-generate -fcoverage-mapping -DCLANG_COVERAGE
        LDFLAGS+=-fprofile-instr-generate -fcoverage-mapping
    }

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        CFLAGS+=-fno-omit-frame-pointer

        when ($SANITIZER_TYPE == "pg") {
            CFLAGS+=-Dpg_sanitizer_enabled
        }
    }

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        HAVE_CUDA=no
    }

    when ($GCC) {
        select ($SANITIZER_TYPE) {
            "address" ? {
                LDFLAGS+=-static-libasan
            }
            "undefined" ? {
                LDFLAGS+=-static-libubsan
            }
            "thread" ? {
                LDFLAGS+=-pie -static-libtsan
            }
        }
    }

    when ($HARDENING == "yes") {
        when ($CLANG) {
            CFLAGS+=-fstack-protector-all -fPIE -D_hardening_enabled_
            LDFLAGS+=-z relro -z now -z noexecstack -pie
        }
    }

    when ($USE_LTO == "yes") {
        when ($GCC) {
            CFLAGS+=-flto -fno-fat-lto-objects
            LDFLAGS+=-flto
        }
        when ($CLANG) {
            CFLAGS+=-flto
            LDFLAGS+=-flto
        }
    }

    when ($USE_THINLTO == "yes") {
        when ($GCC) {
            CFLAGS+=-flto=thin
            LDFLAGS+=-flto=thin
        }
        when ($CLANG) {
            CFLAGS+=-flto=thin
            LDFLAGS+=-flto=thin
        }
    }


    when ($CLANG) {
        when ($PGO_ADD == "yes") {
            CFLAGS+=-fprofile-instr-generate
            LDFLAGS+=-fprofile-instr-generate
        }
        when ($PGO_PATH) {
            CFLAGS+=-fprofile-instr-use=$PGO_PATH -Wno-profile-instr-unprofiled -Wno-profile-instr-out-of-date
            LDFLAGS+=-fprofile-instr-use=$PGO_PATH
        }
    }

    when ($COMPILER_PLATFORM && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=$COMPILER_PLATFORM
    }

    when ($NORUNTIME != "yes") {
        PEERDIR+=contrib/libs/cxxsupp
    }

    when ($NOUTIL != "yes") {
        PEERDIR+=util
    }

    when ($MUSL == "yes") {
        CFLAGS += -D_musl_
    }

    # g++ has proxy C-headers which are incompatible with libc++ proxy C-headers.
    # The same problem exists for clang toolchain. On the other hand, the problem
    # doesn't affect cl since it has united C/C++ library and doesn't need
    # proxy C-headers.
    # Disable all C++ headers including proxy C-headers when we use libc++.
    when ($USE_INTERNAL_STL == "yes" && $MSVC != "yes") {
        CXXFLAGS += -nostdinc++
    }

    when ($MSVC == "yes" && $NO_WINDOWS_STRICT != "yes") {
        CFLAGS+=/DSTRICT
    }

    when ($MSVC == "yes" && $NO_WIN32_LEAN != "yes") {
        CFLAGS+=/DNOMINMAX /DWIN32_LEAN_AND_MEAN
    }

    when ($CODENAVIGATION && $NOCODENAVIGATION != "yes") {
        PEERDIR += build/external_resources/codenavigation
    }

    when ($CYTHON_COVERAGE && $CYTHON_COVERAGE == "yes") {
        CFLAGS+=-DCYTHON_TRACE=1 -DCYTHON_TRACE_NOGIL=1
    }

    #TODO(spreis): switch this to "yes" after performance testing
    DEFAULT(USE_SSE4 no)

    when ($NOSSE != "yes") {
       CFLAGS+=$SSE_CFLAGS
       C_DEFINES+=$SSE_DEFINES
       when ($USE_SSE4 == "yes") {
           CFLAGS+=$SSE4_CFLAGS
           C_DEFINES+=$SSE4_DEFINES
       }
    }
    elsewhen ($MSVC != "yes") {
        CFLAGS += -mno-sse
    }

    DEFAULT(PACKAGE_PREFIX_ARGS)

    DEFAULT(MODULE_VERSION)
    DEFAULT(MODULE_PREFIX)
    DEFAULT(MODULE_SUFFIX)

    DEFAULT(BYACC_FLAGS -v)
    DEFAULT(SWIG_LANG python)
    DEFAULT(BISON_FLAGS -v)
    DEFAULT(GP_FLAGS -CtTLANSI-C -Dk* -c)
}

### @usage: LINK_UNIT  # internal
###
### The base of all linkable modules: programs, DLLs etc. Describes common linking logic
module LINK_UNIT: _BASE_UNIT {
    .EXTS=.o .obj
    .CMD=LINK_EXE
    .ALLOWED=EXTRALIBS OBJADDE_GLOBAL
    .NODE_TYPE=Program
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes

    DEFAULT(ALLOCATOR $DEFAULT_ALLOCATOR)
    _USE_LINKER()

    #link with libunwind manually
    when ($DARWIN == "yes" && $NOPLATFORM != "yes") {
        PEERDIR += contrib/libs/cxxsupp/libcxxrt
    }

    when ($USE_LIBCXXRT == "yes") {
        PEERDIR += contrib/libs/cxxsupp/libcxxrt
    }

    when ($USE_MKL == "yes") {
        NOPLATFORM=yes
    }

    when (($USE_EAT_MY_DATA == "yes") && ($WIN32 != "yes") && ($DARWIN != "yes") && ($OS_ANDROID != "yes") && ($MUSL != "yes")) {
        PEERDIR+=contrib/libs/libeatmydata
    }

    when ($USE_ARCADIA_LIBM == "yes") {
        PEERDIR+=contrib/libs/libm
    }
    when ($USE_ARCADIA_LIBM == "no") {
        C_SYSTEM_LIBRARIES+=-lm
    }

    when (($MUSL != "yes" && $WITH_VALGRIND == "yes") || $SANITIZER_DEFINED == "yes") {
        when ($ALLOCATOR in [ "GOOGLE", "J", "LF", "LF_YT", "LF_DBG", "B", "BM", "BS", "C" ]) {
            PEERDIR+=library/malloc/system
        }
    }
    otherwise {
        select ($ALLOCATOR) {
            "GOOGLE" ? {
                PEERDIR+=library/malloc/galloc
            }
            "J" ? {
                when ($WIN32 == "yes") {
                    PEERDIR+=library/malloc/system
                }
                otherwise {
                    PEERDIR+=library/malloc/jemalloc
                }
            }
            "LF" ? {
                PEERDIR+=library/lfalloc
            }
            "LF_YT" ? {
                PEERDIR+=library/lfalloc/yt
            }
            "LF_DBG" ? {
                PEERDIR+=library/lfalloc/dbg
            }
            "B" ? {
                PEERDIR+=library/balloc
            }
            "BM" ? {
                PEERDIR+=library/balloc_market
            }
            "BS" ? {
                PEERDIR+=library/balloc/sanitize
            }
            "C" ? {
                PEERDIR+=library/malloc/calloc
            }
            "LOCKLESS" ? {
                PEERDIR+=library/malloc/lockless
            }
        }
    }

    when ($ALLOCATOR == "SYSTEM") {
        PEERDIR+=library/malloc/system
    }
    # TODO: fix WERROR and MSVC_WERROR macros
    CFLAGS+=
    when ($NO_COMPILER_WARNINGS != "yes" && $WERROR != "no") {
        when ($WERROR_MODE == "all" || ($WERROR_MODE == "compiler_specific" && $WERROR == "yes")) {
            CFLAGS+=$WERROR_FLAG
        }
    }

    when ($ICC == "yes") {
        PEERDIR+=contrib/libs/intel/core
    }
    when ($WITH_VALGRIND == "yes") {
        PEERDIR+=contrib/libs/valgrind
    }
}

MODULE_TYPE=UNKNOWN

### @usage: _BASE_PROGRAM  # internal
###
### The base of all programs. It adds dependencies to make final artefact complete and runnable
module _BASE_PROGRAM: LINK_UNIT {
    .SYMLINK_POLICY=EXE
    .ALLOWED=INDUCED_DEPS
    .GLOBAL=LDFLAGS
    SET(MODULE_TYPE PROGRAM)

    when ($WIN32 == "yes" || $OS_CYGWIN == "yes") {
        MODULE_SUFFIX=.exe
    }

    when ($MSVC != "yes" && $NOPLATFORM != "yes" && $WITH_VALGRIND != "yes" && $USE_ASMLIB != "no" && $MIC_ARCH != "yes") {
        PEERDIR+=contrib/libs/asmlib
    }

    when ($MUSL == "yes") {
        PEERDIR += contrib/libs/musl-1.1.20/full
    }

    when ($MUSL == "yes" && $WITH_VALGRIND == "yes" && $OS_LINUX && $ARCH_X86_64) {
        # Force a dynamic interpreter into the binary. It is required by Valgrind
        # to preload it's runtime (vgpreload_core-amd64-linux.so) into the process
        # and intercept custom malloc/free implemetations.
        LDFLAGS += /lib64/ld-linux-x86-64.so.2
    }

    when ($USE_ARC_PROFILE == "yes" && $NOUTIL != "yes") {
        PEERDIR += library/execprofile/autostart
    }

    when ($SANITIZER_DEFINED == "yes") {
        PEERDIR += contrib/libs/cxxsupp/libsan
    }

    when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no") {
        PEERDIR+=library/testing/dump_clang_coverage
    }
}

### @usage: PROGRAM([progname])
### Regular program module.
### If name is not specified it will be generated from the name of the containing project directory.
module PROGRAM: _BASE_PROGRAM {
    ADD_YTEST($REALPRJNAME coverage.extractor)
}

### @usage: PY_PROGRAM([progname])
### Python 2.x binary program. Links all Python 2.x libraries and Python 2.x interpreter into itself to form regular executable.
### If name is not specified it will be generated from the name of the containing project directory.
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
### This only compatible with PYTHON2-tagged modules and selects those from multimodules
module PY_PROGRAM: _BASE_PY_PROGRAM {
    # Look's like we cannot avoid copy-paste util ymake supports multiple inheritance
    # We need to attach coverage.extractor to every py_program target, except pytest targets
    ADD_YTEST($REALPRJNAME coverage.extractor)
}

### @usage: PY3_PROGRAM([progname])
### Python 3.x binary program. Links all Python 3.x libraries and Python 3.x interpreter into itself to form regular executable.
### If name is not specified it will be generated from the name of the containing project directory.
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
### This only compatible with PYTHON3-tagged modules and selects those from multimodules
module PY3_PROGRAM: _BASE_PY3_PROGRAM {
    # Look's like we cannot avoid copy-paste util ymake supports multiple inheritance
    # We need to attach coverage.extractor to every py_program target, except pytest targets
    ADD_YTEST($REALPRJNAME coverage.extractor)
}

macro _YCR_GENERATE_CONFIGS_INTL(Package, App, Configs...) {
    .CMD=${tool:"maps/tools/yacare/scripts/make_configs"} $Package $App ${cwd:BINDIR} ${output;hide;pre=debian/$Package/:Configs}
}

macro _YCR_GENERATE_CONFIGS(Package, App) {
    .CMD=$_YCR_GENERATE_CONFIGS_INTL($Package $App ${pre=etc/yandex/maps/yacare/:App.conf} ${pre=etc/logrotate.d/:App} ${pre=etc/template_generator/templates/etc/logrotate.d/:App} ${pre=etc/monrun/conf.d/:App.conf} ${pre=etc/nginx/sites-available/:App.conf} ${pre=etc/syslog-ng/conf-available/:App.conf} ${pre=usr/lib/yandex/maps/yacare/checks/:App} ${pre=usr/lib/yandex/maps/yacare/stat/:App}  ${pre=etc/template_generator/config.d/:App.yaml} ${pre=/juggler/checks-available/yacare_;suf=/MANIFEST.json:App} ${pre=etc/yandex/maps/roquefort/:App.conf} ${pre=usr/lib/yandex/maps/yacare/lua/init_worker.d/rate_limiter_:App.lua} ${pre=usr/lib/yandex/maps/yacare/lua/init_worker.d/tvm_:App.lua} ${pre=usr/lib/yandex/maps/yacare/lua/init.d/tvm_:App.lua})
}

YCR_LINK_EXE=$LINK_EXE && $_YCR_GENERATE_CONFIGS($REALPRJNAME $REALPRJNAME)

### @usage: YCR_PROGRAM([progname])
### yacare-specific program module. Generates yacare configs in addition to producing the program
### If name is not specified it will be generated from the name of the containing project directory.
module YCR_PROGRAM: PROGRAM {
    .CMD=YCR_LINK_EXE
}

### @usage: EXPORTS_SCRIPT(symlist_file)
###
### This allows to specify exports script using separate macro within DLL and DLL-derived modules
### The other option use EXPORTS parameter of the module itself
### @see: [DLL](#module_DLL)
macro EXPORTS_SCRIPT(Arg) {
    SET(EXPORTS_FILE $Arg)
}

### @usage: _BASE_UNITTEST  # internal
###
### Module with base logic for all unit-test modules: it makes code runnable as unit-test by Arcadia testing machiery
module _BASE_UNITTEST: _BASE_PROGRAM {
    .FINAL_TARGET=no
    .NODE_TYPE=Program
    when ($UT_SKIP_EXCEPTIONS == "yes") {
        C_DEFINES+=-DUT_SKIP_EXCEPTIONS
    }
    ADD_YTEST($REALPRJNAME unittest.py)
}

### @usage: UNITTEST([name])
###
### Unit test module based on library/unittest
###
### It is recommended not to specify the name
### Documentation: https://wiki.yandex-team.ru/yatool/test/#opisanievya.make1
module UNITTEST: _BASE_UNITTEST {
    PEERDIR(library/unittest/main)
}

### @usage: YT_UNITTEST([name])
###
### YT Unit test module based on mapreduce/yt/library/utlib
module YT_UNITTEST: _BASE_UNITTEST {
    PEERDIR(mapreduce/yt/library/utlib)
}

### @usage: UNITTEST_WITH_CUSTOM_ENTRY_POINT([name])
###
### Generic unit test module
module UNITTEST_WITH_CUSTOM_ENTRY_POINT: _BASE_UNITTEST {
}

USE_AFL=no

### @usage: FUZZ()
###
### In order to start using Fuzzing in Arcadia, you need to create a FUZZ module with the implementation of the function LLVMFuzzerTestOneInput()
### (example: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/re2/re2/fuzzing/re2_fuzzer.cc?rev=2919463#L58)
### This module should be reachable by RECURSE from /autocheck project
### in Arcadia supported AFL and Libfuzzer on top of a single interface, but the automatic fuzzing still works only through Libfuzzer.
###
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
module FUZZ: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    .ALLOWED=FUZZ_DICTS FUZZ_OPTS

    DEFAULT(LIBFUZZER_PATH contrib/libs/libfuzzer)
    when ($USE_AFL == "no") {
        PEERDIR+=$LIBFUZZER_PATH
    }
    when ($USE_AFL == "yes") {
        PEERDIR+=contrib/libs/libfuzzer/afl
    }

    when (!$SANITIZER_TYPE || $SANITIZER_TYPE == "no") {
        PEERDIR+=devtools/nofuzz
    }

    ADD_YTEST($REALPRJNAME fuzz.test)
}

### @usage: BOOSTTEST([name]) #deprecated
###
### Test module based on boost/test/unit_test.hpp
### As with entire boost library usage of this technology is deprecated in Arcadia.
### No new module of this type should be introduced unless it is explicitly approved by C++ committee
module BOOSTTEST: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    PEERDIR(library/testing/ya_boost_test)
    ADD_YTEST($REALPRJNAME boost.test)
}

FUZZ_DICTS_VALUE=
### @usage: FUZZ_DICTS(path1 [path2...])
###
### Allows you to specify dictionaries, relative to the root of Arcadia, which will be used in Fuzzing.
### Libfuzzer and AFL use a single syntax for dictionary descriptions.
###
### Should only be used in FUZZ modules
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
macro FUZZ_DICTS(Data...) {
    SET_APPEND(FUZZ_DICTS_VALUE $Data)
}

FUZZ_OPTS_VALUE=
### @usage: FUZZ_OPTS(opt1 [Opt2...])
###
### Overrides or adds options to the corpus mining and fuzzer run.
### Currently supported only Libfuzzer, so you should use the options for it.
### Example:
### Fuzz_opts (
###-Max_len = 1024
###-RSS_LIMIT_MB = 8192
### )
###
### Should only be used in FUZZ modules
### Documentation: https://wiki.yandex-team.ru/yatool/fuzzing/
macro FUZZ_OPTS(Data...) {
    SET_APPEND(FUZZ_OPTS_VALUE $Data)
}

TEST_SRCS_VALUE=
### @usage: TEST_SRCS(Files...)
###
### In PYTEST, PY3TEST and PY*_LIBRARY modules used as PY_SRCS macro and additionally used to mine test cases to be executed by testing framework
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynapytest
macro TEST_SRCS(Tests...) {
    SET_APPEND(TEST_SRCS_VALUE $Tests)
}

TEST_DATA_VALUE=
### @usage: DATA([path...])
###
### Specifies the path to the data necessary test.
### Valid: arcadia/<path> , arcadia_tests_data/<path>.
###
### You can also specify the number of the resource required test in cbr format://<eng-id> (resource will be brought to the working directory of the test before it is started)
### Used only inside TEST modules
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#dannyeizrepozitorija
macro DATA(Data...) {
    SET_APPEND(TEST_DATA_VALUE $Data)
}

TEST_TAGS_VALUE=
### @usage: TAG ([tag...])
###
### Each test can have one or more tags used to filter tests list for running.
### There are also special tags affecting test behaviour, for example ya:external, sb:ssd.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#obshhieponjatija
macro TAG(Tags...) {
    SET_APPEND(TEST_TAGS_VALUE $Tags)
}

TEST_REQUIREMENTS_VALUE=
### @usage: REQUIREMENTS([cpu:<count>] [disk_usage:<size>] [ram:<size>] [ram_disk:<size>] [container:<id>] [network:<restricted|full>] [dns:dns64])
###
### Allows you to specify the requirements of the test.
###
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
macro REQUIREMENTS(Tags...) {
    SET(TEST_REQUIREMENTS_VALUE $Tags)
}

TEST_DEPENDS_VALUE=
### @usage: DEPENDS(path1 [path2...])
###
### Buildable targets that should be brought to the test run.
### It is reasonable to specify only final targets (like programs, DLLs or packages here). And only such targets are taken from multimodules
### DEPENDS to UNION is the only exception from the rule above: UNIONs are transitively closed at DEPENDS bringing all dependencies to the test
macro DEPENDS(Data...) {
    SET_APPEND(TEST_DEPENDS_VALUE $Data)
}

TEST_ENV_VALUE=
### @usage: ENV(key[=value])
###
### Sets env variable key to value (gets value from system env by default)
macro ENV(Data...) {
    SET_APPEND(TEST_ENV_VALUE ${quo:Data})
}

TEST_RECIPES_VALUE=
### @usage: USE_RECIPE(path [arg1 arg2...])
###
### Provides prepared environment via recipe for test
### Documentation: https://wiki.yandex-team.ru/yatool/test/recipes
macro USE_RECIPE(Data...) {
    SET_APPEND(TEST_RECIPES_VALUE $Data)
    SET_APPEND(TEST_RECIPES_VALUE "USE_RECIPE_DELIM")
}

TEST_PYTHON_PATH_VALUE=
### @usage: PYTHON_PATH(Path)
###
### Set path to Python that will be used to runs scripts in tests
macro PYTHON_PATH(Path) {
    SET(TEST_PYTHON_PATH_VALUE $Path)
}

SKIP_TEST_VALUE=
### @usage: SKIP_TEST(Reason)
###
### Skip the suite defined by test module. Provide a reason to be output in test execution report
macro SKIP_TEST(Reason...) {
    SET(SKIP_TEST_VALUE $Reason)
}

LINT_LEVEL_VALUE=base
### @usage: NO_LINT()
###
### Do not check for style files included in PY_SRCS, TEST_SRCS, JAVA_SRCS
macro NO_LINT() {
    SET(LINT_LEVEL_VALUE none)
}

### @usage: LINT(<none|base|strict>)
###
### Set linting levem for sources of the module
macro LINT(level) {
    SET(LINT_LEVEL_VALUE $level)
}

### @usage: _BASE_PYTEST  # internal
###
### Base logic of Python 2.x py.test modules: common module properties and dependencies
module _BASE_PYTEST: _BASE_PY_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    when ($USE_ARCADIA_PYTHON == "yes") {
        PEERDIR+=library/python/pytest
    }
    when ($USE_ARCADIA_PYTHON == "no") {
        MODULE_SUFFIX=.pkg.fake
        PEERDIR+=library/python/pytest/empty
    }

    # XXX DEVTOOLS-3210
    when ($PYTHON_COVERAGE == "yes") {
        PEERDIR+=contrib/python/coverage
    }
}

### @usage: PYTEST_BIN() #deprecated
###
### Same as PYTEST. Don't use this
module PYTEST_BIN: _BASE_PYTEST {
    .NODE_TYPE=Program
    SETUP_PYTEST_BIN()
}

### @usage: PYTEST([name])
###
### Definition of the test module for Python 2.x based on py.test
###
### This module is compatible only with PYTHON2-tagged modules and slects peers from multimodules accordingly
### This module is compatible with non-Arcadia Python
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynapytest
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module PYTEST: PYTEST_BIN {
    when ($BUILD_TYPE == "DEBUG") {
        NO_STRIP=yes
    }
}

### @usage: PY3TEST_BIN() #deprecated
###
### Same as PY3TEST. Don't use this
module PY3TEST_BIN: _BASE_PY3_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    SETUP_PYTEST_BIN()
    PEERDIR+=library/python/pytest
}

### @usage: PY3TEST([name])
###
### Definition of the test module for Python 3.x based on py.test
###
### This module is compatible only with PYTHON3-tagged modules and slects peers from multimodules accordingly
### This module is only compatible with Arcadia Python (to avoid tests duplication from Python2/3-tests). For non-Arcadia python use PYTEST
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynapytest
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module PY3TEST: PY3TEST_BIN {
    when ($BUILD_TYPE == "DEBUG") {
        NO_STRIP=yes
    }
}

### @usage: GTEST([name])
###
### Definition of the test module based on gtest (contrib/libs/gtest contrib/libs/gmock)
###
### Use publict documentation on gtest for details
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module GTEST: _BASE_PROGRAM {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    ADDINCL(contrib/libs/gtest contrib/libs/gmock)
    PEERDIR(contrib/libs/gtest contrib/libs/gmock)
    ADD_YTEST($REALPRJNAME gtest)
}

### @usage: YQL_UDF_TEST([name])
###
### Definition of the module to test YQL C++ UDF.
### Documentation: https://yql.yandex-team.ru/docs/yt/libraries/testing/
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module YQL_UDF_TEST: PYTEST {
    PEERDIR(yql/library/udf_test)
    PEERDIR(contrib/python/yt/lite)

    DEPENDS(yql/tools/astdiff)
    DEPENDS(yql/tools/udf_resolver)
    DEPENDS(yql/tools/yqlrun)
    DATA(arcadia/yql/mount)
}

### @usage: EXECTEST()
###
### Module definition of generic test that executes a binary
### Use macro RUN to specify binary to run
###
### @example:
###     EXECTEST()
###
###     OWNER(g:yatool)
###
###     RUN(
###        cat input.txt
###     )
###
###     DATA(
###         arcadia/devtools/ya/test/tests/exectest/data
###     )
###
###     DEPENDS(
###        devtools/dummy_arcadia/cat
###     )
###     TEST_CWD(devtools/ya/test/tests/exectest/data)
###
###     END()
###
### More examples: https://wiki.yandex-team.ru/yatool/test/#exec-testy
### @see: [RUN()](#macro_RUN)
module EXECTEST: _BASE_UNIT {
    .NODE_TYPE=Program
    .FINAL_TARGET=no
    SET(MODULE_SUFFIX .pkg.fake)
    NO_PLATFORM()
    SETUP_EXECTEST()
}

### @usage: BENCHMARK([benchmarkname])
###
### Benchmark test based on library library/testing/benchmark
### For more details see: https://wiki.yandex-team.ru/yatool/test/#zapuskbenchmark
module BENCHMARK: PROGRAM {
    PEERDIR(library/testing/benchmark/main)
}

TEST_ROOT=$(TESTS_DATA_ROOT)
RESULT_MAX_FILE=0
STRIP_FILES=--dont-strip-files
VERIFY_RESULTS=--verify-results
ADDITIONAL_PATH=

# set for tests variables to fill it by YA_DEV or YA
YA_ROOT=ya
when ($YA_DEV == "yes") {
    YA_ROOT=ya-dev
}

### @usage: UNITTEST_FOR(path/to/lib)
###
### Convenience module declaration - extension of UNITTEST module
### Module UNITTEST_FOR automatically makes SRCDIR + ADDINCL + PEERDIR on path/to/lib.
### path/to/lib is the path to the directory with the LIBRARY project.
### Documentation about the Arcadia test system: https://wiki.yandex-team.ru/yatool/test/
module UNITTEST_FOR: UNITTEST {
    PEERDIR(ADDINCL $UNITTEST_DIR)
    SRCDIR($UNITTEST_DIR)
}

### @usage: _LIBRARY # internal
###
### Base module definition for all libraries
### Contains basic logic like module properties, default variable values etc.
### All libraries similar to C++-libraries should be inherited from it
module _LIBRARY: _BASE_UNIT {
    .CMD=LINK_LIB
    .NODE_TYPE=Library
    .PEERDIR_POLICY=as_include
    .EXTS=.o .obj .a .mf
    .ALLOWED=GRPC EXTRALIBS OBJADDE_GLOBAL
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS LDFLAGS SRCS
    .RESTRICTED=ALLOCATOR SIZE TAG DATA TEST_DATA DEPENDS FORK_TESTS FORK_SUBTESTS SPLIT_FACTOR TEST_CWD RUN TIMEOUT SPLIT_DWARF
    .FINAL_TARGET=no
    #TODO: Remove this hack (really we do not need add fake src at all)
    ENABLE(NEED_ADD_FAKE_SRC)

    when ($USE_MKL == "yes") {
        NOPLATFORM=yes
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.lib
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.a
    }

    # TODO: fix WERROR and MSVC_WERROR macros
    CFLAGS+=
    when ($NO_COMPILER_WARNINGS != "yes" && $WERROR != "no") {
        when ($WERROR_MODE == "all" || ($WERROR_MODE == "compiler_specific" && $WERROR == "yes")) {
            CFLAGS+=$WERROR_FLAG
        }
    }

    when ($WITH_VALGRIND == "yes") {
        PEERDIR+=contrib/libs/valgrind
    }

    when ($USE_ARCADIA_LIBM == "yes") {
        PEERDIR+=contrib/libs/libm
    }
}

### @usage: LIBRARY()
###
### Definition of the static library module.
### This is C++ library, and it selects peers from multimodules accordingly
###
### It is recommended not to specify the name.
module LIBRARY: _LIBRARY {
    when ($GRPC_FLAG == "yes") {
        PEERDIR+=contrib/libs/grpc
    }
    SET(MODULE_TYPE LIBRARY)
}

# XXX: dirty hack for correct LDFLAGS passing
RESOURCES_LIBRARY_LINK=$LINK_LIB ${hide:LDFLAGS_GLOBAL} ${hide:LDFLAGS}

### @usage: RESOURCES_LIBRARY()
###
### Definition of a module that brings its content from external source (sandbox)
### via DECLARE_EXTERNAL_RESOURCE macro
### This can participate in PEERDIRs of others as library but it cannot have own sources
###
### It is recommended not to specify the name.
### @see: [DECLARE_EXTERNAL_RESOURCE()](#macro_DECLARE_EXTERNAL_RESOURCE)
module RESOURCES_LIBRARY: _LIBRARY {
    .CMD=RESOURCES_LIBRARY_LINK
    .ALLOWED=DECLARE_EXTERNAL_RESOURCE
    .RESTRICTED=ALLOCATOR SIZE TAG DATA TEST_DATA DEPENDS FORK_TESTS FORK_SUBTESTS SPLIT_FACTOR TEST_CWD RUN TIMEOUT SRCS PEERDIR SPLIT_DWARF

    SET(NEED_PLATFORM_PEERDIRS no)
    SET(PEERDIR_TEST_TOOL no)
    DISABLE(WITH_VALGRIND)
    NO_CODENAVIGATION()
    NO_PLATFORM()
    NO_RUNTIME()
    NO_UTIL()
}


### @usage: FAT_OBJECT()
###
### Definition of the "fat" object module. It will contain all its transitive dependencies reachable by PEERDIRs:
### static libraries, local (from own SRCS) and global (from peers') object files.
###
### Designed for use in XCode projects for iOS.
### It is recommended not to specify the name
module FAT_OBJECT: LIBRARY {
    .CMD=LINK_FAT_OBJECT
    .PEERDIR_POLICY=as_build_from
    SET(MODULE_SUFFIX .o)

    # This module requires at least one .o which is not subject to removal so just add _fake_src.cpp as SRCS
    # ymake's handling of NEED_ADD_FAKE_SRC may insert arbitrary command, not necessarily compilation
    DISABLE(NEED_ADD_FAKE_SRC)
    SRCS(build/scripts/_fake_src.cpp)
}

### @usage: DLL_UNIT # internal
###
### Base module for all dynamically linked libraries as final artifacts.
### Contains all general logic for such kind of modules. Supports versioning and export files
### Cannot participate in linking to programs, intended to be used as final artifact (packaged and deployed).
module DLL_UNIT: LINK_UNIT {
    .CMD=LINK_DYN_LIB
    .NODE_TYPE=Library
    .SYMLINK_POLICY=SO
    .GLOBAL=USER_CFLAGS USER_CXXFLAGS LDFLAGS
    ALLOCATOR(FAKE)

    when ($MODULE_VERSION) {
        # TODO(somov): SONAME is already used in ymake_conf.py. Check whether both usages are coreect.
        LINK_DYN_LIB_FLAGS+=--soname ${output;nopath;noext:SONAME}
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.dll
    }
    elsewhen ($DARWIN == "yes" || $OS_IOS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dylib$MODULE_VERSION
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.so$MODULE_VERSION
    }

    when ($LINUX == "yes") {
        # `-z notext' is needed for linking mkl into shared libraries
        LDFLAGS += -Wl,-z,notext
        LINK_DYN_LIB_FLAGS+=--fix-elf ${tool:"tools/fix_elf"}
    }

    when ($MUSL == "yes") {
        LINK_DYN_LIB_FLAGS += --musl
    }

    when ($DARWIN == "yes") {
        LDFLAGS += -undefined dynamic_lookup
    }

    when ($CLANG_COVERAGE && $CLANG_COVERAGE != "no") {
        PEERDIR+=library/testing/dump_clang_coverage
    }
}

### @usage: PY_ANY_MODULE(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
### Definition of the Python external module for any arcadia and system Python.
### 1. major_ver and minor_ver must be integers.
### 2. The resulting .so will have the prefix "lib".
### 3. Processing EXPORTS and PREFIX is the same as for DLL module
###
### Note: Use PYTHON2_MODULE()/PYTHON3_MODULE in order to PEERDIR proper version of PY23_NATIVE_LIBRARY
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
module PY_ANY_MODULE: DLL_UNIT {
    when ($MSVC != "yes" && $DARWIN != "yes") {
        LDFLAGS+= -Wl,-Bsymbolic
    }

    when ($USE_ARCADIA_PYTHON == "no") {
        when ($USE_SYSTEM_PYTHON) {
            PEERDIR+=build/platform/python
        }
        otherwise {
            when ($MSVC == "yes" || $CYGWIN == "yes") {
                LDFLAGS+=$PYTHON_LIBRARIES
            }
        }
    }

    # -bundle
    when ($DARWIN == "yes") {
        LDFLAGS+=-flat_namespace
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=
        MODULE_SUFFIX=.pyd$MODULE_VERSION
    }
    otherwise {
        MODULE_PREFIX=
        MODULE_SUFFIX=.so$MODULE_VERSION
    }
    .RESTRICTED=USE_PYTHON USE_PYTHON3 PY_SRCS PY_MAIN
}

### @usage: PYMODULE(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
### Definition of the Python external module for Python2 and any system Python
### 1. major_ver and minor_ver must be integers.
### 2. The resulting .so will have the prefix "lib".
### 3. Processing EXPORTS and PREFIX is the same as for DLL module
###
### Note: this module will always PEERDIR Python2 version of PY23_NATIVE_LIBRARY
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
module PYMODULE: PY_ANY_MODULE {
    PYTHON2_MODULE()
    .RESTRICTED=PYTHON3_MODULE PYTHON3_ADDINCL
}

### @usage: PYTHON2_MODULE()
###
### Use in PY_ANY_MODULE to set it up for Python 2.x
macro PYTHON2_MODULE() {
    when ($USE_ARCADIA_PYTHON == "yes" && $MSVC == "yes" || $IS_CROSS_TOOLS == "yes") {
        PEERDIR+=contrib/tools/python/lib
    }

    PYTHON_ADDINCL()
}

### @usage: PYTHON2_MODULE()
###
### Use in PY_ANY_MODULE to set it up for Python 3.x
macro PYTHON3_MODULE() {
    when ($USE_ARCADIA_PYTHON == "yes" && $MSVC == "yes" || $IS_CROSS_TOOLS == "yes") {
        PEERDIR+=contrib/tools/python3/lib
    }

    PYTHON3_ADDINCL()
}

### @usage: R_MODULE(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
### Definition of the external module for R language
### 1. major_ver and minor_ver must be integers.
### 2. The resulting .so will have the prefix "lib".
### 3. Processing EXPORTS and PREFIX is the same as for DLL module
module R_MODULE: DLL_UNIT {
    when ($DARWIN == "yes") {
        LDFLAGS+=-flat_namespace
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dll
    }
    otherwise {
        MODULE_SUFFIX=.so$MODULE_VERSION
    }

    ADDINCL(contrib/libs/r-lang)
}

### @usage: DLL(name major_ver [minor_ver] [EXPORTS symlist_file] [PREFIX prefix])
### Definition of the project is a dynamic library.
### 1. major_ver and minor_ver must be integers.
### 2. EXPORTS allows you to explicitly specify the list of exported functions.
### 3. PREFIX allows you to change the prefix of the output file (default DLL has the prefix "lib").
###
### DLL cannot participate in linking to programs but can be used from Java or as final artifact (packaged and deployed).
module DLL: DLL_UNIT {
    SET(MAKE_ONLY_SHARED_LIB yes)

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.dll
    }

    # TODO: Make it possible to use this syntax
    # DEFAULT(DLL_FOR_DIR no)
    ### FIXME: XXX
    ###when ($DLL_FOR_DIR != "no") {
    ###    SRCDIR($DLL_FOR_DIR)
    ###    ADDINCL($DLL_FOR_DIR)
    ###}
}

DLL_PROXY_CMD_MF=$GENERATE_MF && $COPY_CMD $AUTO_INPUT $TARGET

### @usage: DEV_DLL_PROXY() # deprecated
###
### The use of this module is strictly prohibited!!!
### This is a temporary and project-specific solution.
module DEV_DLL_PROXY: _BASE_UNIT {
    .NODE_TYPE=Library
    .EXTS=.so .dll .mf
    .CMD=DLL_PROXY_CMD_MF

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.dll
    }
    elsewhen ($DARWIN == "yes" || $OS_IOS == "yes") {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.dylib$MODULE_VERSION
    }
    otherwise {
        MODULE_PREFIX=lib
        MODULE_SUFFIX=.so$MODULE_VERSION
    }
}

### @usage: DLL_JAVA()
###
### DLL built using swig for Java produces dynamic library and a .jar.
### Dynamic library is treated the same as in the case of PEERDIR from Java to DLL.
### .jar goes on the classpath.
###
### Documentation: https://wiki.yandex-team.ru/yatool/java/#integracijascpp/pythonsborkojj
module DLL_JAVA: DLL {
    .EXTS=.o .obj .jsrc .java .mf
    .CMD=SWIG_DLL_JAR_CMD
    PEERDIR(build/platform/java/jdk)

    SET(SWIG_LANG java)
}

### @usage: UDF_BASE(name [EXPORTS symlist_file] [PREFIX prefix]) #internal
###
### The base logic of all UDF externsion modules (User-Defined Functions)
### Processing EXPORTS and PREFIX is the same as for DLL
### https://wiki.yandex-team.ru/robot/manual/kiwi/userguide/#polzovatelskiefunkciiudftriggerykwcalc
module UDF_BASE: DLL_UNIT  {
    PRINT_MODULE_TYPE(UDF $REALPRJNAME)

    when ($MSVC != "yes" && $DARWIN != "yes") {
        LDFLAGS+= -Wl,-Bsymbolic
    }
}

### @usage: UDF(name [EXPORTS symlist_file] [PREFIX prefix]) # deprecated
###
### Definition of the KiWi UDF module
### Processing EXPORTS and PREFIX is the same as for DLL
### https://wiki.yandex-team.ru/robot/manual/kiwi/userguide/#polzovatelskiefunkciiudftriggerykwcalc
module UDF: UDF_BASE {
    PEERDIR(yweb/robot/kiwi/kwcalc/udflib)
}

### @usage: UDF_LIB([name]) # deprecated
###
### The LIBRARY module for KiWi UDF, so has default PEERDIR to yweb/robot/kiwi/kwcalc/udflib
### It is recommended not to specify a name
module UDF_LIB: LIBRARY {
    PEERDIR(yweb/robot/kiwi/kwcalc/udflib)
}

when ($SANITIZER_TYPE || $USE_ARCADIA_PYTHON == "no") {
    YQL_UDF_LINK_CMD=$LINK_DYN_LIB
}
otherwise {
    YQL_UDF_LINK_CMD=$LINK_DYN_LIB && ${tool:"yql/tools/udf_probe"} $TARGET ${kv;hide:"p UD"}
}

### @usage: YQL_UDF_MODULE(name)
###
### Definition of the extension module for YQL with C++ UDF (User Defined Function YQL)
### https://yql.yandex-team.ru/docs/yt/udf/cpp/
module YQL_UDF_MODULE: UDF_BASE {
    .CMD=YQL_UDF_LINK_CMD

    PEERDIR(yql/library/udf)
    PEERDIR(yql/library/udf/support)
    SET_APPEND(USER_CXXFLAGS -DBUILD_UDF)
    # For Windows using declspecs
    DEFAULT(YQL_UDF_EXPORT ${ARCADIA_ROOT}/yql/library/udf/udfs_exports.exports)

    when ($WINDOWS == "yes") {
        YQL_UDF_EXPORT=
    }

    SET(EXPORTS_FILE $YQL_UDF_EXPORT)
}

### @usage USE_YQL()
###
### Add required PEERDIRs for YQL module.
### Can be used for in-place module definition in user LIBRARY.
macro USE_YQL() {
    PEERDIR(yql/library/udf)
    PEERDIR(yql/library/udf/support)
    PEERDIR(yql/library/udf/service/terminate_policy)
}

### @usage: GLOBAL_SRCS(filenames...)
###
### Make all source files listed as GLOBAL
### Call to GLOBAL_SRCS macro is equivalent to call to SRCS macro when each source file is marked with GLOBAL keyword.
### Arcadia root relative or project dir relative paths are supported for filenames arguments. GLOBAL keyword is not
### recognized for GLOBAL_SRCS in contrast to SRCS macro.
###
### @example:
### Consider the file to ya.make:
### ```
###     LIBRARY()
###     GLOBAL_SRCS(foo.cpp bar.cpp)
###     END()
### ```
### @see: [SRCS()](#macro_SRCS)
macro GLOBAL_SRCS(Files...) {
    SRCS(${pre=GLOBAL :Files})
}

### @usage: ALL_SRCS([GLOBAL] filenames...)
###
### Make all source files listed as GLOBAL or not depending on the keyword GLOBAL
### Call to ALL_SRCS macro is equivalent to call to GLOBAL_SRCS macro when GLOBAL keyword is specified
### as the first argument and is equivalent to call to SRCS macro otherwise.
###
### @example:
### Consider the file to ya.make:
### ```
###     LIBRARY()
###     SET(MAKE_IT_GLOBAL GLOBAL)
###     ALL_SRCS(${MAKE_IT_GLOBAL} foo.cpp bar.cpp)
###     END()
### ```
### @see: [GLOBAL_SRCS()](#macro_GLOBAL_SRCS), [SRCS()](#macro_SRCS)
macro ALL_SRCS(GLOBAL?"GLOBAL":"", Files...) {
    SRCS(${pre=$GLOBAL :Files})
}

### @usage: _DLL_COMPATIBLE_LIBRARY # internal
###
### Base module to place DLLs into multimodules back to back with libraries
### In order to function properly all modules in multimodule shall have the
### same set of arguments. So this module is just library that accepts but
### ignores all DLL arguments
module _DLL_COMPATIBLE_LIBRARY: LIBRARY {
}

### @usage: YQL_UDF(name)
### Definition of multimodule which is YQL_UDF_MODULE when built directly or referred by BUNDLE and DEPENDS
### and static LIBRARY is used by PEERDIR
multimodule YQL_UDF {
    module YQL_UDF_SHARED: YQL_UDF_MODULE {
    }
    module YQL_UDF_STATIC: _DLL_COMPATIBLE_LIBRARY {
        .ALIASES=SRCS=GLOBAL_SRCS
        OBJ_SUF=.udfs
        USE_YQL()
    }
}

### @usage: YQL_ABI_VERSION(major minor release))
### Specifying the supported ABI for YQL_UDF.
### @see: [YQL_UDF()](#multimodule_YQL_UDF)
macro YQL_ABI_VERSION(Major, Minor, Patch) {
    YQL_ABI_FLAGS=-DUDF_ABI_VERSION_MAJOR=$Major -DUDF_ABI_VERSION_MINOR=$Minor -DUDF_ABI_VERSION_PATCH=$Patch
    SET_APPEND(USER_CXXFLAGS $YQL_ABI_FLAGS)
}

### @usage: YQL_PYTHON_UDF(name)
###
### Definition of the extension module for YQL with Python 2.x UDF (User Defined Function YQL)
### https://yql.yandex-team.ru/docs/yt/udf/python/
module YQL_PYTHON_UDF: YQL_UDF_MODULE {
    .IGNORED=PYTHON_ADDINCL USE_PYTHON
    .RESTRICTED=PYTHON3_ADDINCL USE_PYTHON3
    _ARCADIA_PYTHON_ADDINCL()
    PEERDIR(build/platform/python/ldflags)

    DEFAULT(YQL_PYTHON_UDF_EXPORT ${ARCADIA_ROOT}/yql/udfs/common/python/python_udf/python_udfs_exports.exports)

    when ($WINDOWS == "yes") {
        YQL_PYTHON_UDF_EXPORT=
    }

    ### FIXME: XXX the statement below uncoditionally set EXPORTS_FILE (due to incorrect behaviour of old ConfReader
    ###when ($USE_ARCADIA_PYTHON == "yes") SET(EXPORTS_FILE $YQL_PYTHON_UDF_EXPORT)
    SET(EXPORTS_FILE $YQL_PYTHON_UDF_EXPORT)
}

### @usage: YQL_PYTHON3_UDF(name)
###
### Definition of the extension module for YQL with Python 3.x UDF (User Defined Function YQL)
### Documentation: https://yql.yandex-team.ru/docs/yt/udf/python/
module YQL_PYTHON3_UDF: YQL_UDF_MODULE {
    .IGNORED=PYTHON_ADDINCL PYTHON3_ADDINCL USE_PYTHON USE_PYTHON3
    _ARCADIA_PYTHON3_ADDINCL()
    PEERDIR(build/platform/python/ldflags)

    DEFAULT(YQL_PYTHON_UDF_EXPORT ${ARCADIA_ROOT}/yql/udfs/common/python/python_udf/python_udfs_exports.exports)

    when ($WINDOWS == "yes") {
        YQL_PYTHON_UDF_EXPORT=
    }

    ### FIXME: XXX the statement below uncoditionally set EXPORTS_FILE (due to incorrect behaviour of old ConfReader
    ###when ($USE_ARCADIA_PYTHON == "yes") SET(EXPORTS_FILE $YQL_PYTHON_UDF_EXPORT)
    SET(EXPORTS_FILE $YQL_PYTHON_UDF_EXPORT)
}

### @usage: YQL_PYTHON_UDF_TEST(name)
###
### Definition of the Python test for UDF (User Defined Function YQL)
### Documentation: https://yql.yandex-team.ru/docs/yt/udf/python/
### @example: https://a.yandex-team.ru/arc/trunk/arcadia/yql/udfs/test/simple/ya.make
module YQL_PYTHON_UDF_TEST: YQL_PYTHON_UDF {
    PEERDIR(library/python/pytest)
    DEPENDS(yql/tools/run_python_udf)
    SETUP_PYTEST_BIN(RUNNER_BIN $(BUILD_ROOT)/yql/tools/run_python_udf/run_python_udf)
}

# as SRCS in packages use macro BUNDLE_SRCS!

PACKED_PACKAGE_ARGS=
PACKED_PACKAGE_EXT=
### @usage: PACK(archive_type)
### Is placed inside the PACKAGE module, packs the build results tree to the archive with specified extension.
macro PACK(Ext) {
    SET(PACKED_PACKAGE_EXT $Ext)
}

PACKAGE_STRICT_VALUE=
macro PACKAGE_STRICT() {
    SET(PACKAGE_STRICT_VALUE yes)
}

### @usage: PACKAGE(name)
### Module collects what is described directly inside it, builds and collects all its transitively available PEERDIRs.
### As a result, build directory of the project gets the structure of the accessible part of Arcadia, where the build result of each PEERDIR is placed to relevant Arcadia subpath.
###
### Is only used together with the macros FILES(), PACK(), COPY(), CONFIGURE_FILE(), FROM_SANDBOX(), PEERDIR().
###
### Documentation: https://wiki.yandex-team.ru/yatool/large-data/
module PACKAGE: _BASE_UNIT  {
    .CMD=TOUCH_PACKAGE_MF
    .PEERDIR_POLICY=as_build_from
    .ALL_INS_TO_OUT=yes
    .FINAL_TARGET=yes
    SET(MODULE_SUFFIX .pkg.fake)
    SET(DONT_RESOLVE_INCLUDES yes)
    NO_PLATFORM()
    when ($PACKED_PACKAGE_EXT) {
        PACKED_PACKAGE_ARGS+=--dest-arch ${output;suf=.$PACKED_PACKAGE_EXT:REALPRJNAME}
    }
    SET(NEED_PLATFORM_PEERDIRS no)
    PEERDIR_TAGS=CPP_PROTO PY2 PY2_NATIVE YQL_UDF_SHARED __EMPTY__ DOCBOOK
}

TOUCH_UNIT_MF=$TOUCH_UNIT && $GENERATE_MF
TOUCH_DOCS=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${kv;hide:"p DC"} ${kv;hide:"pc light-cyan"} $TARGET
TOUCH_DOCS_MF=$TOUCH_DOCS && $GENERATE_MF

### @usage: UNION(name)
### Module is able to collect what is described directly inside it, remember PEERDIRs listed in it, go there and build them.
### However PEERDIRs build results are not used themselves, semantics of PEERDIR is the same as for LIBRARY.
### When built directly PEEDIRs won't be built unless it is built via DEPENDS macro, which treats the UNION specially.
###
### Is only used together with the macros FILES(), PEERDIR(), COPY(), FROM_SANDBOX().
###
### Documentation: https://wiki.yandex-team.ru/yatool/large-data/
module UNION: _BASE_UNIT {
    .ALL_INS_TO_OUT=yes
    .FINAL_TARGET=no
    NO_PLATFORM()
    SET(MODULE_SUFFIX .pkg.fake)
    SET(DONT_RESOLVE_INCLUDES yes)
    .CMD=TOUCH_UNIT_MF
    SET(NEED_PLATFORM_PEERDIRS no)
    PEERDIR_TAGS=CPP_PROTO PY2 PY2_NATIVE YQL_UDF_SHARED __EMPTY__ DOCBOOK
}


### @usage: PY_PACKAGE(name) # internal, deprecated
### This is module created via PY_PROTOS_FOR() macro
module PY_PACKAGE: UNION {
    .EXTS=.py
    .ALL_INS_TO_OUT=yes
    .ALLOWED=GRPC
    .FINAL_TARGET=yes
}

### @usage: DOCS()
### Definition of the documentation multimodule.
###
### The output artifact is docs.tar.gz with statically generated site (using mkdocs as builder) when built directly
### When PEERDIRed from other DOCS() behaves like a library (supplying own content and dependencies to build target).
### Is only used together with the macros DOCS_DIR(), DOCS_CONFIG(), DOCS_VARS().
### @see: [DOCS_DIR()](#macro_DOCS_DIR), [DOCS_CONFIG()](#macro_DOCS_CONFIG), [DOCS_VARS()](#macro_DOCS_VARS).
multimodule DOCS {

    module DOCBOOK: PACKAGE {
        .ALL_INS_TO_OUT=yes
        .CMD=TOUCH_DOCS_MF
        .FINAL_TARGET=yes
        SET(PEERDIR_TAGS DOCSLIB)
        SET(MODULE_TAG DOCBOOK)
        PROCESS_DOCS()
    }

    module DOCSLIB: UNION {
        .ALL_INS_TO_OUT=yes
        .CMD=TOUCH_DOCS_MF
        .FINAL_TARGET=no
        SET(MODULE_SUFFIX .pkg-dep.fake)
        SET(PEERDIR_TAGS DOCSLIB)
        SET(MODULE_TAG DOCSLIB)
        PROCESS_DOCSLIB()
    }

}

DOCSDIR=

### @usage: DOCS_DIR(path)
### Specify directory with source .md files for DOCS multimodule if it differs from project directory.
### Path must be Arcadia root relative.
### @see: [DOCS](#multimodule_DOCS)
macro DOCS_DIR(Dir) {
    SET(DOCSDIR $Dir)
}

DOCSCONFIG=

### @usage: DOCS_CONFIG(path)
### Specify path to config .yml file for DOCS multimodule if it differs from "%%project_directory%%/mkdocs.yml".
### Path must be either Arcadia root relative or lie in project directory.
### @see: [DOCS](#multimodule_DOCS)
macro DOCS_CONFIG(File) {
    SET(DOCSCONFIG $File)
}

DOCSVARS=

### @usage: DOCS_VARS(variable1=value1 variable2=value2 ...)
### Specify a set of default values of template variables for DOCS multimodule.
### There must be no spaces around "=". Values will be treated as strings.
### @see: [DOCS](#multimodule_DOCS)
macro DOCS_VARS(Args...) {
    SET_APPEND(DOCSVARS $Args)
}

PY_NAMESPACE_VALUE=

### @usage: PY_NAMESPACE(prefix)
### Sets default Python namespace for all python sources in the module
### Especially suitable in PROTO_LIBRARY where Python sources are generated
### and there is no PY_SRCS to place NAMESPACE parameter
macro PY_NAMESPACE(Arg) {
    SET(PY_NAMESPACE_VALUE $Arg)
}

COMPILE_JAVA_MF=$COMPILE_JAVA && $GENERATE_MF

### @usage: _JAVA_LIBRARY()
###
### _JAVA_LIBRARY() is a module for creating a .jar file using non-Java code (generators etc.)
module _JAVA_LIBRARY: _BASE_UNIT {
    .EXTS=.jsrc .java .jar .mf
    .NODE_TYPE=Bundle
    .CMD=COMPILE_JAVA_MF
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=no

    PEERDIR(build/platform/java/jdk)

    PEERDIR_TAGS=JAVA_PROTO
    MACRO_ALIAS(PROTO_CMD _JAVA_PROTO_CMD)
    MACRO_ALIAS(EVLOG_CMD _JAVA_EVLOG_CMD)

    when ($PACKAGE_PREFIX) {
        PACKAGE_PREFIX_ARGS=--package-prefix=$PACKAGE_PREFIX
    }

    NO_PLATFORM()
    SET(MODULE_SUFFIX .jar)
    SET(DONT_RESOLVE_INCLUDES yes)
}

JAVA_PROTOBUF=contrib/java/com/google/protobuf/protobuf-java/3.5.1
JAVA_GRPC_STUB=contrib/java/io/grpc/grpc-stub/1.18.0
JAVA_GRPC_PROTOBUF=contrib/java/io/grpc/grpc-protobuf/1.18.0

### @usage: PY_LIBRARY()
###
### Python 2.x binary library. Builds sources from PY_SRCS to data suitable for PY_PROGRAM
### Adds dependencies to Python 2.x runtime library from Arcadia.
### This module is only compatible with PYTHON2-tagged modules and selects those from multimodules
### This module is only compatible with Arcadia Python build
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
module PY_LIBRARY: _LIBRARY {
    _ARCADIA_PYTHON_ADDINCL()
    OPTIMIZE_PY_PROTOS()

    when ($NO_PYTHON_INCLS != "yes") {
        PEERDIR+=contrib/libs/python
    }
    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=py
    }
    otherwise {
        MODULE_PREFIX=libpy
    }
    .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER PYTHON_ADDINCL USE_PYTHON
    .RESTRICTED=PYTHON3_ADDINCL USE_PYTHON3
}

### @usage: PY3_LIBRARY()
###
### Python 3.x binary library. Builds sources from PY_SRCS to data suitable for PY_PROGRAM
### Adds dependencies to Python 2.x runtime library from Arcadia.
### This module is only compatible with PYTHON3-tagged modules and selects those from multimodules
### This module is only compatible with Arcadia Python build
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
module PY3_LIBRARY: _LIBRARY {
    _ARCADIA_PYTHON3_ADDINCL()
    OPTIMIZE_PY_PROTOS()

    when ($NO_PYTHON_INCLS != "yes") {
        PEERDIR+=contrib/libs/python
    }
    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_PREFIX=py
    }
    otherwise {
        MODULE_PREFIX=libpy
    }
    .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER PYTHON_ADDINCL PYTHON3_ADDINCL USE_PYTHON USE_PYTHON3
}

### @usage: _BASE_PY_PROGRAM #internal
###
### The base module for all Python 2.x binary programs. Adds linking logic, relevant module properties and
### dependency on Python 2.x interpreter. Also adds import tests on all sources including libraries.
### Links all Python 2.x libraries and Python 2.x interpreter into itself to form regular executable.
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
### This only compatible with PYTHON2-tagged modules and selects those from multimodules
module _BASE_PY_PROGRAM: _BASE_PROGRAM {
    .CMD=PY_PROGRAM_LINK_EXE
    _ARCADIA_PYTHON_ADDINCL()

    ADD_CHECK_PY_IMPORTS()
    OPTIMIZE_PY_PROTOS()

    when ($NO_PYTHON_INCLS != "yes") {
        PEERDIR+=contrib/libs/python
    }
    when ($USE_ARCADIA_PYTHON == "yes") {
        PEERDIR+=library/python/runtime/main contrib/python/subprocess32
    }

    ALLOCATOR(J)
    STRIP()

    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        NO_STRIP=yes
    }
    .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER PYTHON_ADDINCL USE_PYTHON
    .RESTRICTED=PYTHON3_ADDINCL USE_PYTHON3
}

### @usage: _BASE_PY_PROGRAM #internal
###
### The base module for all Python 3.x binary programs. Adds linking logic, relevant module properties and
### dependency on Python 3.x interpreter. Also adds import tests on all sources including libraries.
### Links all Python 3.x libraries and Python 3.x interpreter into itself to form regular executable.
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs/
### This only compatible with PYTHON3-tagged modules and selects those from multimodules
module _BASE_PY3_PROGRAM: _BASE_PROGRAM {
    _ARCADIA_PYTHON3_ADDINCL()
    PEERDIR(library/python/runtime_py3/main)

    ADD_CHECK_PY_IMPORTS()

    ALLOCATOR(J)
    STRIP()

    when ($NO_PYTHON_INCLS != "yes") {
        PEERDIR+=contrib/libs/python
    }
    when ($SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
        NO_STRIP=yes
    }
    .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER PYTHON_ADDINCL PYTHON3_ADDINCL USE_PYTHON USE_PYTHON3
}

JAVA_SWIG_DELIM=JAVA_SWIG_DELIM

JAVAC_OPTS=
when ($USE_SYSTEM_JDK) {
    JDK_RESOURCE=$USE_SYSTEM_JDK
}
otherwise {
    JDK_RESOURCE=$JDK_RESOURCE_GLOBAL
}
COMPILE_JAVA=${cwd:ARCADIA_BUILD_ROOT} $YMAKE_PYTHON ${input:"build/scripts/compile_java.py"} --javac-bin $JDK_RESOURCE/bin/javac --jar-bin $JDK_RESOURCE/bin/jar $PACKAGE_PREFIX_ARGS --jar-output $TARGET --srcs-jar-output ${output;suf=-sources.jar:REALPRJNAME} $AUTO_INPUT DELIM $JAVAC_OPTS DELIM $PEERS ${kv;hide:"p JV"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"} ${kv;hide:"PEERS $PEERS"}
REAL_SWIG_DLL_JAR_CMD=${cwd:ARCADIA_BUILD_ROOT} $YMAKE_PYTHON ${input:"build/scripts/build_dll_and_java.py"} $JAVA_SWIG_DELIM $REAL_LINK_DYN_LIB $JAVA_SWIG_DELIM $COMPILE_JAVA $JAVA_SWIG_DELIM $AUTO_INPUT $JAVA_SWIG_DELIM $TARGET $JAVA_SWIG_DELIM ${output;suf=.jar:REALPRJNAME} $JAVA_SWIG_DELIM ${output;suf=-sources.jar:REALPRJNAME} $JAVA_SWIG_DELIM $ARCADIA_BUILD_ROOT

### @usage: METAQUERY()
### Project Definition - KIWI Meta query. (Objected)
### https://wiki.yandex-team.ru/robot/manual/kiwi/techdoc/design/metaquery/
module METAQUERY: _BASE_UNIT  {
    .ALL_INS_TO_OUT=yes
    .FINAL_TARGET=yes
    PRINT_MODULE_TYPE(METAQUERY $REALPRJNAME)
}

ARGS_DELIM="MACRO_CALLS_DELIM"

SYSTEM_PROPERTIES_VALUE=
### @usage: SYSTEM_PROPERTIES([<Key Value>...] [<File Path>...])
### List of Key,Value pairs that will be available to test via System.getProperty.
### FILE means that parst should be read from file specifies as Path
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro SYSTEM_PROPERTIES(Args...) {
    SET_APPEND(SYSTEM_PROPERTIES_VALUE $Args)
}

JVM_ARGS_VALUE=
### @usage: JVM_ARGS(Args...)
### Arguments to run Java programs in tests
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro JVM_ARGS(Args...) {
    SET_APPEND(JVM_ARGS_VALUE $Args)
}

CHECK_JAVA_DEPS_VALUE=
### @usage: CHECK_JAVA_DEPS(<yes|no>)
### Check for different classes with duplicate name in classpath
### Documentation: https://wiki.yandex-team.ru/yatool/test/
macro CHECK_JAVA_DEPS(Arg) {
    SET(CHECK_JAVA_DEPS_VALUE $Arg)
}

ERROR_PRONE_VALUE=
### @usage: USE_ERROR_PRONE()
### Use errorprone instead of javac for .java compilation
macro USE_ERROR_PRONE() {
    SET(ERROR_PRONE_VALUE yes)
}

TEST_CWD_VALUE=
### @usage: TEST_CWD(path)
###
### Defines cwd test. Used in conjunction with DATA()
###
### Is only used inside of the TEST modules
macro TEST_CWD(Arg) {
    SET(TEST_CWD_VALUE $Arg)
}

MAKE_UBERJAR_VALUE=
### @usage: UBERJAR()
###
### UBERJAR is a single all-in-one jar-archive that includes all its Java dependencies (achievable PERDIR).
### It also supports shading classes inside the archive by moving them to a different package (similar to the maven-shade-plugin).
### Use UBERJAR inside JAVA_PROGRAM module.
###
### You can use the following macros to configure the archive:
### 1. UBERJAR_HIDING_PREFIX prefix for classes to shade (classes remain in their packages by default)
### 2. UBERJAR_HIDE_EXCLUDE_PATTERN exculude classes matching this patterns from shading (if enabled).
### 3. UBERJAR_PATH_EXCLUDE_PREFIX the prefix for classes that should not get into the jar archive (all classes are placed into the archive by default)
### Documentation: https://wiki.yandex-team.ru/yatool/java/
### @see: [JAVA_PROGRAM](#module_JAVA_PROGRAM), [UBERJAR_HIDING_PREFIX](#macro_UBERJAR_HIDING_PREFIX), [UBERJAR_HIDE_EXCLUDE_PATTERN](#macro_UBERJAR_HIDE_EXCLUDE_PATTERN), [UBERJAR_PATH_EXCLUDE_PREFIX](#macro_UBERJAR_PATH_EXCLUDE_PREFIX)
macro UBERJAR() {
    SET(MAKE_UBERJAR_VALUE yes)
}

UBERJAR_PREFIX_VALUE=
### @usage: UBERJAR_HIDING_PREFIX(Arg)
### Set prefix for classes to shade. All classes in UBERJAR will be moved into package prefixed with Arg
### Classes remain in their packages by default
### @see: [UBERJAR](#macro_UBERJAR)
macro UBERJAR_HIDING_PREFIX(Arg) {
    SET(UBERJAR_PREFIX_VALUE $Arg)
}

UBERJAR_HIDE_EXCLUDE_VALUE=
### @usage: UBERJAR_HIDE_EXCLUDE_PATTERN(Args...)
### Exculude classes matching this patterns from shading (if enabled)
### Pattern may contain '*' and '**' globs
### Shading is enabled for UBERJAR program using UBERJAR_HIDING_PREFIX macro. If this macro is not specified all classes are shaded.
### @see: [UBERJAR](#macro_UBERJAR), [UBERJAR_HIDING_PREFIX](#macro_UBERJAR_HIDING_PREFIX)
macro UBERJAR_HIDE_EXCLUDE_PATTERN(Args...) {
    SET_APPEND(UBERJAR_HIDE_EXCLUDE_VALUE $ARGS_DELIM $Args)
}

UBERJAR_PATH_EXCLUDE_VALUE=
### @usage: UBERJAR_PATH_EXCLUDE_PREFIX(Args...)
### Exculude classes matching this patterns from UBERJAR.
### By default all dependencies of UBERJAR program will lend in a .jar archive.
### @see: [UBERJAR](#macro_UBERJAR)
macro UBERJAR_PATH_EXCLUDE_PREFIX(Args...) {
    SET_APPEND(UBERJAR_PATH_EXCLUDE_VALUE $ARGS_DELIM $Args)
}

ADD_WAR_VALUE=

### @usage: ADD_WAR([INCLUDE Path Pattern...] [EXCLUDE Path Pattern...] [INCLUDE_DEFAULT Pattern...] [EXCLUDE_DEFAULT Pattern...])
###
### Pack Java module (JAVA_PROGRAM or JAVA_LIBRARY) into war.
### Parameters control what should be added or shouldn't be added to war archive.
### Documentation: https://wiki.yandex-team.ru/yatool/java/war
macro ADD_WAR(Args...) {
    SET_APPEND(ADD_WAR_VALUE $ARGS_DELIM $Args)
}

IDEA_EXCLUDE_DIRS_VALUE=
### @usage: IDEA_EXCLUDE_DIRS(<excluded dirs>)
### Macro excludes specified directories from an idea project generated by ya ide idea
macro IDEA_EXCLUDE_DIRS(Args...) {
    SET_APPEND(IDEA_EXCLUDE_DIRS_VALUE $Args)
}

IDEA_RESOURCE_DIRS_VALUE=
### @usage: IDEA_RESOURCE_DIRS(<additional dirs>)
### Macro sets specified resource directories in an idea project generated by ya ide idea
macro IDEA_RESOURCE_DIRS(Args...) {
    SET_APPEND(IDEA_RESOURCE_DIRS_VALUE $Args)
}

JAVAC_FLAGS_VALUE=
### @usage: JAVAC_FLAGS(Args...)
### Set additional Java compilation flags
macro JAVAC_FLAGS(Args...) {
    SET_APPEND(JAVAC_FLAGS_VALUE $ARGS_DELIM $Args)
}

MAVEN_GROUP_ID_VALUE=
### @usage: MAVEN_GROUP_ID(group_id_for_maven_export)
### Set maven export group id for JAVA_PROGRAM() and JAVA_LIBRARY()
macro MAVEN_GROUP_ID(Arg) {
    SET(MAVEN_GROUP_ID_VALUE $Arg)
}


ANNOTATION_PROCESSOR_VALUE=
### @usage: ANNOTATION_PROCESSOR(processors...)
### The macro is in development.
### Used to specify annotation processors to build JAVA_PROGRAM() and JAVA_LIBRARY()
macro ANNOTATION_PROCESSOR(Args...) {
    SET_APPEND(ANNOTATION_PROCESSOR_VALUE $ARGS_DELIM $Args)
}

EXCLUDE_VALUE=
### EXCLUDE(prefixes)
### The macro is in development.
### Specifies which libraries should be excluded from the classpath.
macro EXCLUDE(Args...) {
    SET_APPEND(EXCLUDE_VALUE $ARGS_DELIM $Args)
}

JAVA_SRCS_VALUE=
### @usage: JAVA_SRCS(srcs)
### Using the macro JAVA_SRCS() specifies the java source files and resources. A macro can be contained in any of four java modules.
### Keywords:
### 1. X SRCDIR - specify the directory x is performed relatively to search the source code for these patterns. If there is no SRCDIR, the source will be searched relative to the module directory.
### 2. PACKAGE_PREFIX x - use if source paths relative to the SRCDIR does not coincide with the full class names. For example, if all sources of module are in the same package, you can create a directory package/name , and just put the source code in the SRCDIR and specify PACKAGE_PREFIX package.name.
###
### @example:
###  - example/ya.make
###
###     JAVA_PROGRAM()
###     JAVA_SRCS(SRCDIR src/main/java **/*)
###     END()
###
###  - example/src/main/java/ru/yandex/example/HelloWorld.java
###
###     package ru.yandex.example;
###     public class HelloWorld {
###         public static void main(String[] args) {
###             System.out.println("Hello, World!");
###         }
###     }
###
###     macro JAVA_SRCS(Args...) {
###         SET_APPEND(JAVA_SRCS_VALUE $ARGS_DELIM $Args)
###     }
### Documentation: https://wiki.yandex-team.ru/yatool/java/#javasrcs
macro JAVA_SRCS(Args...) {
    SET_APPEND(JAVA_SRCS_VALUE $ARGS_DELIM $Args)
}

JAVA_ADD_DLLS_VALUE=no
macro ADD_DLLS_TO_JAR() {
    SET(JAVA_ADD_DLLS_VALUE yes)
}

EXTERNAL_JAR_VALUE=
### @usage: EXTERNAL_JAR(library.jar)
### Is used to indicate the collected external java libraries inside the project JAVA_LIBRARY()
###
### Documentation: https://wiki.yandex-team.ru/yatool/java/#ispolzovanievneshnixmavenbibliotek
macro EXTERNAL_JAR(Args...) {
    SET_APPEND(EXTERNAL_JAR_VALUE $ARGS_DELIM $Args)
}

DEPENDENCY_MANAGEMENT_VALUE=
### @usage: DEPENDENCY_MANAGEMENT(path/to/lib1 path/to/lib2 ...)
###
### It allow you to lock the versions of the libraries from the contrib/java in one place,
###   and all modules of the project when writing PEERDIR not specify a version.
### For example, if the module says PEERDIR (contrib/java/junit/junit), and
###   1. written DEPENDENCY_MANAGEMENT(contrib/java/junit/junit/4.12),
###      the PEERDIR is automatically replaced by contrib/java/junit/junit/4.12
###   2. not written appropriate DEPENDENCY_MANAGEMENT, PEERDIR automatically replaced
###      with the default from contrib/java/junit/junit/ya.make.
###      These defaults are always there and are supported in maven-import, which is put
###      there the maximum(available in contrib/java ) version.
### The property is transitive. That is, if module a depends on module B,
### and PEERDIR is written in B(contrib/java/junit/junit), and this junit was replaced by junit-4.12, then junit-4.12 will come to A through B.
### Allows you to lock the versions of the libraries from the contrib/java falling in the classpath transitive.
### For example, if a module written DEPENDENCY_MANAGEMENT(contrib/java/junit/junit/4.12),
### but not written appropriate PEERDIR(contrib/java/junit/junit),
###   1. if you are attracted by dependencies, such as contrib/java/junit/junit/4.11, it will be replaced by contrib/java/junit / junit / 4.12
###   2. if the dependency does not extend any junit DEPENDENCY_MANAGEMENT this has no effect
### This property is not passed transitively. That is, if module a depends on B,
### and B replaced itself transitively arriving junit-4.11 on junit-4.12, in a through B all the same will arrive junit-4.11.
###
### In the case when the module is written at the same time DEPENDENCY_MANAGEMENT(contrib/java/junit/junit/4.12) and PERDIR(contrib/java/junit/junit/4.11) PEERDIR wins.
macro DEPENDENCY_MANAGEMENT(Args...) {
    SET_APPEND(DEPENDENCY_MANAGEMENT_VALUE $ARGS_DELIM $Args)
}

WITH_JDK_VALUE=
macro WITH_JDK() {
    SET(WITH_JDK_VALUE yes)
}

module _JAVA_PLACEHOLDER: _BASE_UNIT  {
    .CMD=TOUCH_JAVA_UNIT
    .FINAL_TARGET=yes
    PEERDIR_TAGS=JAVA_PROTO
    PEERDIR(build/platform/java/jdk)
    when($MAKE_UBERJAR_VALUE) {
        PEERDIR+=build/platform/java/uberjar
    }
    when($ERROR_PRONE_VALUE) {
        PEERDIR+=build/platform/java/error_prone
    }

    NO_PLATFORM()
    JAVA_MODULE()
}

### @usage: JAVA_PROGRAM()
### JAVA_PROGRAM() - module for describing java programs.
### Output artifacts: .jar and directory with all the jar to the classpath of the formation.
###
### Documentation: https://wiki.yandex-team.ru/yatool/java/
module JAVA_PROGRAM: _JAVA_PLACEHOLDER {
    SET(MODULE_TYPE JAVA_PROGRAM)
}

### @usage: JAVA_LIBRARY()
### Documentation: https://wiki.yandex-team.ru/yatool/java/
module JAVA_LIBRARY: _JAVA_PLACEHOLDER {
    SET(MODULE_TYPE JAVA_LIBRARY)
}

### @usage: JTEST()
### Java tests module based on JUnit 4 framework
###
### If requested, build system will scan the source code of the module for the presence of junit tests and run them.
### Output artifacts: a jar, a directory of exhaust tests(if required run the tests) - test logs, system logs testiranja, temporary files, tests, etc.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynajava
module JTEST: _JAVA_PLACEHOLDER {
    SET(MODULE_TYPE JTEST)

    # TODO: if <needs_sonar>
    DEPENDS(contrib/java/org/sonarsource/scanner/cli/sonar-scanner-cli/2.8)
    DEPENDS(devtools/junit-runner devtools/jacoco-agent)
    JAVA_TEST()
}

### @usage: TESTNG()
### Java tests module based on TestNG framework
###
### If requested, build system will scan the source code of the module for the presence of junit tests and run them.
### Output artifacts: a jar, a directory of exhaust tests(if required run the tests) - test logs, system logs testiranja, temporary files, tests, etc.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynajava
module TESTNG: _JAVA_PLACEHOLDER {
    SET(MODULE_TYPE TESTNG)
    PEERDIR(devtools/testng_plugin)
    JAVA_TEST()
}

### @usage: JUNIT5()
### Java tests module based on JUnit 5 framework
###
### If requested, build system will scan the source code of the module for the presence of junit tests and run them.
### Output artifacts: a jar, a directory of exhaust tests(if required run the tests) - test logs, system logs testiranja, temporary files, tests, etc.
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynajava
module JUNIT5: _JAVA_PLACEHOLDER {
    SET(MODULE_TYPE JUNIT5)
    DEPENDS(devtools/junit5-runner devtools/jacoco-agent)
    JAVA_TEST()
}

### @usage: JTEST_FOR(ModuleDir)
### Java tests module based on JUnit 4 framework for specified library or program
###
### In contrast to the JTEST, the build system will scan for the presence of the test sources of the module in ModuleDir . As ModuleDir should contain JAVA_PROGRAM or JAVA_LIBRARY . JTEST_FOR also can have its own source, in this case they will be compiled and added to the classpath of a test run.
### Output artifacts: a jar, a directory of exhaust tests(if requested tests are run).
###
### Documentation: https://wiki.yandex-team.ru/yatool/test/#testynajava
module JTEST_FOR: JTEST {
    SET(MODULE_TYPE JTEST_FOR)
    PEERDIR($UNITTEST_DIR)
    SET(REALPRJNAME jtest)
    JAVA_TEST()
}

### @usage: SANDBOX_TASK([Name])
### Multimodule describing Sandbox task (Python code that can be executed by Sandbox system)
###
### As a final target this multimodule builds Sandbox binary task. It may PEERDIR other SANDBOX_TASKs as libraries.
### As PEERDIR target it works like normal PY_LIBRARY with predefined dependency on Sanbox SDK
###
### Currenly Sandbox supports only Python 2.x, so both variants will be
### compatible only with Python 2.x modules and will select mutimodule variants accordingly.
### Documentation: https://wiki.yandex-team.ru/sandbox/tasks/binary
multimodule SANDBOX_TASK {
    module SB_TASK_BIN: PY_PROGRAM {
        PY_MAIN(sandbox.taskbox.binary)
        PEERDIR(sandbox/bin sandbox/sdk2 sandbox/sandboxsdk sandbox/taskbox/worker)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE api.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE kernel.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE library.*)
        SET_APPEND(NO_CHECK_IMPORTS_FOR_VALUE sky*)
    }
    module PY2: PY_LIBRARY {
        PEERDIR(sandbox/sdk2 sandbox/sandboxsdk)
    }
}

NO_PYTHON_INCLS=no

### @usage: NO_PYTHON_INCLUDES() # internal
###
### Disable dependencies on libraries providing Python headers.
### This is only used in Python libraries themselves to avoid PEERDIR loops
macro NO_PYTHON_INCLUDES() {
    ENABLE(NO_PYTHON_INCLS)
}

### @usage: PYTHON_ADDINCL()
###
### This macro adds include path for Python headers (Python 2.x variant)
### This should be used in 2 cases only:
### - In PYMODULE since it compiles into .so and uses external Python runtime
### - In system Python libraries themselves since proper PEERDIR there may create a loop
###
### Never use this macro in PY_PROGRAM, PY_LIBRARY and PY23_LIBRARY: they have everything by default
### In all other cases use USE_PYTHON macro instead
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs
macro PYTHON_ADDINCL() {
    _PYTHON_ADDINCL()
    SET(MODULE_TAG PY2_NATIVE)
    SET(PEERDIR_TAGS CPP_PROTO PY2_NATIVE YQL_UDF_STATIC __EMPTY__)
}

### @usage: _ARCADIA_PYTHON_ADDINCL()  # internal
### This macro sets up Python headers for modules with Arcadia python (e.g. PY_LIBRARY) and configures module as Python 2.x
macro _ARCADIA_PYTHON_ADDINCL() {
    _PYTHON_ADDINCL()
    SET(MODULE_TAG PY2)
    SET(PEERDIR_TAGS PY2 PY2_NATIVE PY_PROTO YQL_UDF_STATIC __EMPTY__)
}

### @usage: _PYTHON_ADDINCL()  # internal
### This macro sets up Python 2.x headers for both Arcadia and non-Arcadia python
macro _PYTHON_ADDINCL() {
    SET(PYTHON2 yes)
    SET(PYTHON3 no)
    when ($USE_ARCADIA_PYTHON == "yes") {
        ADDINCL+=GLOBAL contrib/libs/python/Include
    }
    otherwise {
        when ($USE_SYSTEM_PYTHON) {
            PEERDIR+=build/platform/python
        }
        otherwise {
            CFLAGS+=$PYTHON_INCLUDE
        }
    }
}

### @usage: PYTHON3_ADDINCL()
### This macro adds include path for Python headers (Python 3.x variant)
### This should be used in 2 cases only:
### - In PYMODULE since it compiles into .so and uses external Python runtime
### - In system Python libraries themselves since peerdir there may create a loop
###
### Never use this macro in PY3_PROGRAM and PY3_LIBRARY and PY23_LIBRARY: they have everything by default
### In all other cases use USE_PYTHON3() macro instead
###
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/py_srcs
macro PYTHON3_ADDINCL() {
    _PYTHON3_ADDINCL()
    SET(MODULE_TAG PY3_NATIVE)
    SET(PEERDIR_TAGS CPP_PROTO PY3_NATIVE YQL_UDF_STATIC __EMPTY__)
}

### @usage: _ARCADIA_PYTHON3_ADDINCL()  # internal
### This macro sets up Python3 headers for modules with Arcadia python (e.g. PY3_LIBRARY) and configures module as Python 3.x
macro _ARCADIA_PYTHON3_ADDINCL() {
    _PYTHON3_ADDINCL()
    SET(MODULE_TAG PY3)
    SET(PEERDIR_TAGS PY3 PY3_NATIVE PY3_PROTO YQL_UDF_STATIC __EMPTY__)
}

### @usage: _PYTHON_ADDINCL()  # internal
### This macro sets up Python 3.x headers for both Arcadia and non-Arcadia python
macro _PYTHON3_ADDINCL() {
    SET(PYTHON3 yes)
    SET(PYTHON2 no)
    when ($USE_ARCADIA_PYTHON == "yes") {
        CFLAGS+=-DUSE_PYTHON3
        ADDINCL+=GLOBAL contrib/libs/python/Include
    }
    otherwise {
        when ($USE_SYSTEM_PYTHON) {
            PEERDIR+=build/platform/python
        }
        otherwise {
            CFLAGS+=$PYTHON_INCLUDE
        }
    }
}

### @usage: USE_PYTHON()
###
### This adds Python 2.x runtime library to your LIBRARY and makes it Python2-compatible
### If you'd like to use #include <Python.h> with Python2 specify USE_PYTHON or better make it PY_LIBRARY
### If you'd like to use #include <Python.h> with Python3 specify USE_PYTHON3 or better make it PY3_LIBRARY
### If you'd like to use #include <Python.h> with both Python2 and Python3 convert your LIBRARY to PY23_LIBRARY
### @see: [PY_LIBRARY](#module_PY_LIBRARY), [PY3_LIBRARY](#module_PY3_LIBRARY), [PY23_LIBRARY](#multimodule_PY23_LIBRARY)
macro USE_PYTHON() {
    _ARCADIA_PYTHON_ADDINCL()
    SET(PEERDIR_TAGS PY2 PY2_NATIVE CPP_PROTO YQL_UDF_STATIC __EMPTY__)
    PEERDIR(contrib/libs/python)
}

### @usage: USE_PYTHON3()
### This adds Python3 library to your LIBRARY and makes it Python3-compatible
### If you'd like to use #include <Python.h> with Python3 specify USE_PYTHON3 or better make it PY3_LIBRARY
### If you'd like to use #include <Python.h> with Python2 specify USE_PYTHON or better make it PY_LIBRARY
### If you'd like to use #include <Python.h> with both Python2 and Python3 convert your LIBRARY to PY23_LIBRARY
### @see: [PY_LIBRARY](#module_PY_LIBRARY), [PY3_LIBRARY](#module_PY3_LIBRARY), [PY23_LIBRARY](#multimodule_PY23_LIBRARY)
macro USE_PYTHON3() {
    _ARCADIA_PYTHON3_ADDINCL()
    SET(PEERDIR_TAGS PY3 PY3_NATIVE CPP_PROTO YQL_UDF_STATIC __EMPTY__)
    PEERDIR(contrib/libs/python)

    when ($USE_ARCADIA_PYTHON == "yes") {
        PEERDIR+=library/python/runtime_py3
    }
}

when (($PERLXS == "yes") || ($PERLXSCPP == "yes") || ($USE_PERL == "yes")) {
    PEERDIR+=build/platform/perl
}

### @usage: USE_PERL_LIB()
### Add dependency on Perl to your LIBRARY
macro USE_PERL_LIB() {
    PEERDIR(build/platform/perl)
}

### @usage: ADD_PERL_MODULE(Dir ModuleName)
### Add dependency on specified Perl module to the library
macro ADD_PERL_MODULE(Dir, Module) {
    PEERDIR($Dir)
    SET_APPEND(modules $Module)
}

### @usage: ALLOCATOR(Alloc)  # Default: LF
### Set allocator implementation for a program
### This may only be specified for programs. Use inside LIBRARY ALLOCATOR() END() leads to errors and stop the build.
### Available allocators are: "LF", "LF_YT", "LF_DBG", "J", "B", "BS", "BM", "C", "GOOGLE", "LOCKLESS", "SYSTEM", "FAKE"
###   - LF - lfalloc (https://a.yandex-team.ru/arc/trunk/arcadia/library/lfalloc)
###   - LF_YT -  Allocator selection for YT (https://a.yandex-team.ru/arc/trunk/arcadia/library/lfalloc/yt/ya.make)
###   - LF_DBG -  Debug allocator selection(https://a.yandex-team.ru/arc/trunk/arcadia/library/lfalloc/dbg/ya.make)
###   - J - The JEMalloc allocator (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/jemalloc)
###   - B - The balloc allocator named Pyotr Popov and Anton Samokhvalov
###       - Discussion: https://ironpeter.at.yandex-team.ru/replies.xml?item_no=126
###       - Code: https://a.yandex-team.ru/arc/trunk/arcadia/library/balloc
###   - BS - The balloc allocator with leak sanitizer (https://a.yandex-team.ru/arc/trunk/arcadia/library/balloc/sanitize)
###   - BM - The balloc for market (agri@ commits from july 2018 till november 2018 saved)
###   - C - Like B, but can be disabled for each thread to LF or SYSTEM one (B can be disabled only to SYSTEM)
###   - GOOGLE -  Google TCMalloc (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/galloc)
###   - LOCKLESS - Allocator based upon lockless queues (https://a.yandex-team.ru/arc/trunk/arcadia/library/malloc/lockless)
###   - SYSTEM - Use target system allocator
###   - FAKE - Don't link with any allocator
###
### More about the allocator in Arcadia: https://wiki.yandex-team.ru/arcadia/allocators/
macro ALLOCATOR(Alloc) {
    SET(ALLOCATOR $Alloc)

    when ($ALLOCATOR in [ "LF", "LF_YT", "LF_DBG", "J", "B", "BS", "BM", "C", "GOOGLE", "LOCKLESS", "SYSTEM", "FAKE" ]) {
    }
    otherwise {
        PEERDIR+=___configure_error___unknown_allocator_type___$ALLOCATOR
    }
}


#LINK_STATICALLY=yes

when ($MIC_ARCH == "yes") {
    CFLAGS+=-mmic
    LDFLAGS+=-mmic
}
when ($USE_OPENMP == "yes") {
    PEERDIR+=contrib/libs/openmp
}

when ($STRIP == "yes" && $NO_STRIP != "yes") {
    STRIP_FLAG=$LD_STRIP_FLAG
    DWARF_COMMAND=
}

OBJCOPY_TOOL=$BINUTILS_ROOT_RESOURCE_GLOBAL/bin/objcopy
STRIP_TOOL=$BINUTILS_ROOT_RESOURCE_GLOBAL/bin/strip

SPLIT_DWARF_VALUE=no
NO_SPLIT_DWARF=no

### @usage: SPLIT_DWARF()
###
### Emit debug info for the PROGRAM as a separate file <module_name>.debug
### This may only be specified for programs. Use inside LIBRARY ALLOCATOR() END() leads to errors and stop the build.
macro SPLIT_DWARF() {
    SET(SPLIT_DWARF_VALUE yes)
}

SPLIT_DWARF_OUTPUT=${output;tobindir;pre=$MODULE_PREFIX;suf=$MODULE_SUFFIX.debug:REALPRJNAME}
when ($SPLIT_DWARF_VALUE == "yes" && $NO_SPLIT_DWARF != "yes" && $NO_DEBUGINFO != "yes" && $HOST_OS_LINUX == "yes" && $TARGET_PLATFORM == "LINUX") {
    DWARF_COMMAND+= \
        $OBJCOPY_TOOL --only-keep-debug $TARGET $SPLIT_DWARF_OUTPUT && \
        $STRIP_TOOL --remove-section .gnu_debuglink $TARGET && \
        $OBJCOPY_TOOL --add-gnu-debuglink $SPLIT_DWARF_OUTPUT $TARGET
    PEERDIR+=build/platform/binutils
}

### @usage: EXTRALIBS_STATIC(Libs...)
### Add the specified external static libraries to the program link
macro EXTRALIBS_STATIC(Args...) {
    LDFLAGS(-Wl,-Bstatic ${Args} -Wl,-Bdynamic)
}

### @usage ADD_COMPILABLE_TRANSLATE(Dict Name Options...)
### Generate translation dictionary code to transdict.LOWER(Name).cpp that will than be compiled into library
macro ADD_COMPILABLE_TRANSLATE(Dict, Name, MakeTransDictOptions...) {
     __translatename_lower=${tolower:Name}
     __translate_dict=${BINDIR}/transdict.${__translatename_lower}.cpp
     RUN_PROGRAM(dict/tools/maketransdict -i ${Dict} ${MakeTransDictOptions} ${Name} STDOUT ${__translate_dict} IN ${Dict})
}

### @usage ADD_COMPILABLE_TRANSLIT(TranslitTable NGrams Name Options...)
### Generate transliteration dictionary code
### This will emit both translit, untranslit and ngrams table codes those will be than further compiled into library
macro ADD_COMPILABLE_TRANSLIT(TranslitTable, NGrams, Name, Options...) {
     __translitname_lower=${tolower:Name}
     __translit_table=${BINDIR}/translit_trie_${__translitname_lower}.cpp
     __untranslit_table=${BINDIR}/untranslit_trie_${__translitname_lower}.cpp
     __ngrams_table=${BINDIR}/ngr_arr_${__translitname_lower}.cpp
     __gentrie_dir=dict/tools/make_untranslit_trie

     RUN_PROGRAM(${__gentrie_dir} -i ${TranslitTable} ${Options} ${__translitname_lower} IN ${TranslitTable} STDOUT ${__untranslit_table})
     RUN_PROGRAM(${__gentrie_dir} -i ${TranslitTable} -n ${Options} ${__translitname_lower} IN ${TranslitTable} STDOUT ${__translit_table})
     RUN_PROGRAM(dict/tools/make_ngrams -i ${NGrams} ${Options} ${__translitname_lower} IN ${NGrams} STDOUT ${__ngrams_table})
}

### @usage GENERATE_PY_PROTOS(ProtoFiles...) # deprecated
###
### Generate python bindings for protobuf files.
### Macro is obsolete and not recommended for use!
macro GENERATE_PY_PROTOS(FILES...) {
    foreach (FILE : $FILES) {
        _PY_PROTO_CMD($FILE)
    }
}

macro _GENERATE_PY_PROTOS_INTERNAL(FILES...) {
    foreach (FILE : $FILES) {
        _PY_PROTO_CMD_INTERNAL($FILE)
    }
}

macro _GENERATE_PY_EVS_INTERNAL(FILES...) {
    foreach (FILE : $FILES) {
        _PY_EVLOG_CMD_INTERNAL($FILE)
    }
}

### @usage: COPY_FILE(File Destination)
### Copy file to build root. It is possible to change both location and the name.
### The file will be just copied. You should explicitly mention it in SRCS under new name for further processing
macro COPY_FILE(File, Destination) {
    .CMD=$COPY_CMD ${input:File} ${output;noauto:Destination} ${kv;hide:"p CP"} ${kv;hide:"pc light-cyan"}
}

### @usage: COPY_FILE_WITH_DEPS(File Destination [OUTPUT_INCLUDES Deps...])
###
### Copy file to build root and specify additional dependencies for it.
### It is possible to change both location and the name.
### The file will be just copied. You should explicitly mention it in SRCS under new name for further compilation.
### File will be recompiled (but not re-copied) if any of specified dependencies changes
macro COPY_FILE_WITH_DEPS(File, Destination, OUTPUT_INCLUDES[]) {
    .CMD=$COPY_CMD ${input:File} ${output:Destination} ${output_include;hide:OUTPUT_INCLUDES} ${kv;hide:"p CP"} ${kv;hide:"pc light-cyan"}
}

macro _BUNDLE_TARGET(Target, Destination) {
    .CMD=$MOVE_FILE ${result:Target} ${output:Destination} ${kv;hide:"p BN"} ${kv;hide:"pc light-cyan"}
}

### @usage: TIMEOUT(TIMEOUT)
### Sets a timeout on test execution
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro TIMEOUT(Time) {
    SET(TEST_TIMEOUT $Time)
}

TEST_FORK_MODE=none

### @usage: FORK_TESTS()
###
### Splits a test run on chunks classes.
### The number of chunks can be overridden using the macro SPLIT_FACTOR.
###
### Allows to run tests in parallel. Supported C++ ut and PyTest.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_TESTS() {
    SET(TEST_FORK_MODE tests)
}

### @usage: FORK_SUBTESTS()
###
### Splits the test run in chunks on subtests.
### The number of chunks can be overridden using the macro SPLIT_FACTOR.
###
### Allows to run tests in parallel. Supported C++ ut and PyTest.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_SUBTESTS() {
    SET(TEST_FORK_MODE subtests)
}

### @usage: SPLIT_FACTOR(x)
### Sets the number of chunks for parallel run tests when using FORK_TESTS, FORK_SUBTESTS
### As yourself use means the macro FORK_TESTS.
###
### Supports C++ ut and PyTest.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro SPLIT_FACTOR(Factor) {
    SET(TEST_SPLIT_FACTOR $Factor)
}

FORK_TEST_FILES_MODE=off
### @usage: FORK_TEST_FILES()
###
### Only for PYTEST: splits a file executable with the tests on chunks in the files listed in TEST_SRCS
### Compatible with FORK_(SUB)TESTS.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro FORK_TEST_FILES() {
    SET(FORK_TEST_FILES_MODE on)
}

TEST_SIZE_NAME=SMALL
### @usage: SIZE(SMALL/MEDIUM/LARGE)
### Marks a test of the specified size.
###
### Documentation about the system test: https://wiki.yandex-team.ru/yatool/test/
macro SIZE(Type) {
    SET(TEST_SIZE_NAME $Type)
}

### @usage: JOIN_SRCS(Out Src...)
### Join set of sources into single file named Out and send it for further processing.
### This macro doesn't place all file into Out, it emits #include<Src>... Use the for C++ source files only.
### You should specify file name with the extension as Out
macro JOIN_SRCS(Out, Src...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_join_srcs.py"} ${output:Out} ${input;rootrel:Src} ${output_include;hide:Src} ${kv;hide:"p JS"} ${kv;hide:"pc magenta"}
}

### @usage: JOIN_SRCS_GLOBAL(Out Src...)
### Join set of sources into single file named Out and send it for further processing as if it were listed as SRCS(GLOBAL Out)
### This macro doesn't place all file into Out, it emits #include<Src>... Use the for C++ source files only.
### You should specify file name with the extension as Out
macro JOIN_SRCS_GLOBAL(Out, Src...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_join_srcs.py"} ${output;noauto:Out} ${input;rootrel:Src} ${output_include;hide:Src} ${kv;hide:"p JS"} ${kv;hide:"pc magenta"}
    SRCS(GLOBAL $Out)
}

### @usage: FLAT_JOIN_SRCS_GLOBAL(Out Src...)
### Join set of sources into single file named Out and send it for further processing as if it were listed as SRCS(GLOBAL Out)
### This macro places all files into single file, so will work with any sources.
### You should specify file name with the extension as Out
macro FLAT_JOIN_SRCS_GLOBAL(Out, Src...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/fs_tools.py"} cat ${output;noauto:Out} ${input:Src} ${output_include;hide:Src} ${kv;hide:"p JS"} ${kv;hide:"pc magenta"}
    SRCS(GLOBAL $Out)
}

### @usage: PROVIDES(Name...)
### Specifies provided features. The names must be C identifiers.
### Different libraries providing the same features can not be linked into one program.
macro PROVIDES(Name...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/provides.py"} ${output;noauto;pre=_provides:CPP_EXT} $Name ${kv;hide:"p PS"} ${kv;hide:"pc cyan"}
    SRCS(GLOBAL ${pre=_provides:CPP_EXT})
}

SSE2_CFLAGS=
SSE3_CFLAGS=
SSSE3_CFLAGS=
SSE41_CFLAGS=
SSE42_CFLAGS=
POPCNT_CFLAGS=
PCLMUL_CFLAGS=
AVX_CFLAGS=
AVX2_CFLAGS=

SSE_DEFINES=
SSE_CFLAGS=
SSE4_DEFINES=
SSE4_CFLAGS=

when ($ARCH_X86_64 || $ARCH_I386) {
    when ($CLANG || $CLANG_CL || $GCC) {
        SSE2_CFLAGS=-msse2
        SSE3_CFLAGS=-msse3
        SSSE3_CFLAGS=-mssse3
        SSE41_CFLAGS=-msse4.1
        SSE42_CFLAGS=-msse4.2
        POPCNT_CFLAGS=-mpopcnt
        PCLMUL_CFLAGS=-mpclmul
        AVX_CFLAGS=-mavx
        AVX2_CFLAGS=-mavx2
        SSE_DEFINES=-DSSE_ENABLED=1 -DSSE3_ENABLED=1 -DSSSE3_ENABLED=1
        SSE4_DEFINES=-DSSE41_ENABLED=1 -DSSE42_ENABLED=1 -DPOPCNT_ENABLED=1
    }
    elsewhen ($MSVC) {
        SSE2_CFLAGS=/D__SSE2__=1
        SSE3_CFLAGS=/D__SSE3__=1
        SSSE3_CFLAGS=/D__SSSE3__=1
        SSE41_CFLAGS=/D__SSE4_1__=1
        SSE42_CFLAGS=/D__SSE4_2__=1
        POPCNT_CFLAGS=/D__POPCNT__=1
        PCLMUL_CFLAGS=/D__PCLMUL__=1
        AVX_CFLAGS=/arch:AVX /DAVX_ENABLED=1
        AVX2_CFLAGS=/arch:AVX2 /DAVX2_ENABLED=1
        SSE_DEFINES=/DSSE_ENABLED=1 /DSSE3_ENABLED=1 /DSSSE3_ENABLED=1
        SSE4_DEFINES=/DSSE41_ENABLED=1 /DSSE42_ENABLED=1 /DPOPCNT_ENABLED=1
    }
    SSE_CFLAGS=$SSE2_CFLAGS $SSE3_CFLAGS $SSSE3_CFLAGS
    SSE4_CFLAGS=$SSE41_CFLAGS $SSE42_CFLAGS $POPCNT_CFLAGS
}

when ($NOSSE == "yes") {
    USE_SSE4=no
}

### @usage: NO_SSE4()
### Compile module without SSE4
macro NO_SSE4() {
    SET(USE_SSE4 no)
}

### @usage: _SRC(Ext Src Flags) # internal
###
### Basic building block of extension-based command dispatching
### To enable specific extension processing define _SRC() macro with fixed first argument (Ext).
### Internal logic will apply this macro to all files with this Ext listed in SRC/SRCS macros or outputs
### of other commands (except ones marked as noauto)
macro _SRC(EXT, SRC, SRCFLAGS...) {
    # Generic macro definition for _SRC (just a placeholder, it does nothing)
}

macro _SRC("S", SRC, SRCFLAGS...) {
    .CMD=$GCCFILTER $C_COMPILER $C_FLAGS_PLATFORM -c -o ${output:SRC.o} ${input:SRC} ${pre=-I:INCLUDE} ${SRCFLAGS} ${kv;hide:"p CC"} ${kv;hide:"pc light-green"} $TOOLCHAIN_ENV
}

macro _SRC("s", SRC, SRCFLAGS...) {
    .CMD=$_SRC(S, $SRC $SRCFLAGS)
}

macro _SRC("mm", SRC, SRCFLAGS...) {
    .CMD=$GCCFILTER $C_COMPILER $C_FLAGS_PLATFORM -x objective-c++ -fobjc-arc -fobjc-abi-version=2 -c -o ${output:SRC.o} ${input:SRC} $CXXFLAGS ${pre=-I:INCLUDE} ${SRCFLAGS} ${kv;hide:"p CC"} ${kv;hide:"pc light-green"} $TOOLCHAIN_ENV
}

macro _SRC("fml", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL $CHECKFLAG -b -o ${output:SRC.inc} -T ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

macro _SRC("fml2", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL $CHECKFLAG -b -o ${output;nopath;noext:SRC.fml.inc} -2 -O ${output;nopath;noext:SRC.fml.cpp} -T ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

macro _SRC("fml3", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL $CHECKFLAG -b -o ${output;nopath;noext:SRC.fml.inc} -3 -O ${output;nopath;noext:SRC.fml.cpp} -L ${input;nopath;noext:SRC.list} -P ${nopath;noext:SRC} -T ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

macro _SRC("sfdl", SRC, SRCFLAGS...) {
    .CMD=$CXX_COMPILER $C_FLAGS_PLATFORM $CXXFLAGS $SFDL_FLAG ${SRCFLAGS} ${input:SRC} && ${tool:"tools/calcstaticopt"} -i ${tmp:SRC.tmp} -a $ARCADIA_ROOT ${output;stdout;nopath;noext;defext=.inc:SRC} ${kv;hide:"p SF"} ${kv;hide:"pc yellow"} $TOOLCHAIN_ENV
}

macro _SRC("xs", SRC, SRCFLAGS...) {
    .CMD=$PERL_LD_LIBRARY_PATH $PERL $PERL_INCLUDE ${suf=/ExtUtils/xsubpp:PERL_PRIVLIB} -typemap ${suf=/ExtUtils/typemap:PERL_PRIVLIB} $PERLSUFFIX $XSUBPPFLAGS ${SRCFLAGS} ${input:SRC} $PERLOUTPUT ${kv;hide:"p XS"} ${kv;hide:"pc yellow"}
}

macro _SRC("y", SRC, SRCFLAGS...) {
    # .CMD=${tool:"contrib/tools/byacc"} $BYACC_FLAGS ${nopath;noext;output:SRC.cpp} ${input:SRC} ${nopath;noext;hide;output;addincl:SRC.h} ${kv;hide:"p YC"} ${kv;hide:"pc light-green"}
    .CMD=${tool:"contrib/tools/bison/bison"} $BISON_FLAGS --m4=${tool:"contrib/tools/bison/m4"} -d -o ${nopath;noext;output;main;hide:SRC.h} ${nopath;noext;output:SRC.cpp} ${input:SRC} ${SRCFLAGS} && $YMAKE_PYTHON ${input:"build/scripts/preprocess.py"} ${nopath;noext;output;addincl:SRC.h} ${kv;hide:"p YC"} ${kv;hide:"pc light-green"}
}

macro _SRC("ypp", SRC, SRCFLAGS...) {
    .CMD=$_SRC(y $SRC $SRCFLAGS)
}

macro _SRC("gperf", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/gperf"} $GP_FLAGS ${SRCFLAGS} ${pre=-Nin_;suf=_set;nopath;noallext:SRC} ${input:SRC} ${output;stdout;nopath;noext;defext=.gperf.cpp:SRC} ${kv;hide:"p GP"} ${kv;hide:"pc yellow"}
}

macro _SRC("rl", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel5/ragel"} $RAGEL_FLAGS ${SRCFLAGS} -o ${tmp:SRC.tmp} ${input:SRC} && $RUN_NO_SANITIZE ${tool:"contrib/tools/ragel5/rlgen-cd"} $RLGEN_FLAGS -o ${output;nopath;noext;defext=.cpp:SRC} ${tmp:SRC.tmp} ${kv;hide:"p R5"} ${kv;hide:"pc yellow"}
}

macro _SRC("rl5", SRC, SRCFLAGS...) {
    .CMD=$_SRC(rl $SRC $SRCFLAGS)
}

macro _SRC("asp", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"tools/html2cpp"} ${input:SRC} ${output:SRC.cpp} ${kv;hide:"p HT"} ${kv;hide:"pc yellow"}
}

macro _SRC("rl6", SRC, SRCFLAGS...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel6"} $RAGEL6_FLAGS ${SRCFLAGS} -I${ARCADIA_ROOT} -o ${output;nopath;noext;defext=.rl6.cpp:SRC} ${input:SRC} ${kv;hide:"p R6"} ${kv;hide:"pc yellow"}
}

macro _SRC("l", SRC, SRCFLAGS...) {
    .CMD=${tool:"contrib/tools/flex-old"} $LEX_FLAGS ${SRCFLAGS} -o${output:SRC.cpp} ${output_include;hide:"util/system/compiler.h"} ${input:SRC} ${kv;hide:"p LX"} ${kv;hide:"pc yellow"}
    .ADDINCL=contrib/tools/flex-old
}

macro _SRC("lex", SRC, SRCFLAGS...) {
    .CMD=$_SRC(l $SRC $SRCFLAGS)
}

macro _SRC("lpp", SRC, SRCFLAGS...) {
    .CMD=$_SRC(l $SRC $SRCFLAGS)
}

macro _SRC("pln", SRC, SRCFLAGS...) {
    .CMD=$FML_TOOL -b -o ${output;pre=pln.;nopath;noext:SRC.cpp} -f ${input:SRC} ${SRCFLAGS} ${kv;hide:"p FM"} ${kv;hide:"pc yellow"}
}

macro _SRC("xsyn", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"library/xml/parslib/xsyn2ragel.py"} ${input:SRC} ${input:"library/xml/parslib/xmlpars.xh"} dontuse ${output;stdout:SRC.h.rl5} ${kv;hide:"p XN"} ${kv;hide:"pc yellow"}
}

macro _SRC("ev", SRC, SRCFLAGS...) {
    .CMD=$EVLOG_CMD($SRC)
}

macro _SRC("proto", SRC, SRCFLAGS...) {
    .CMD=$PROTO_CMD($SRC)
}

macro _SRC("gztproto", SRC, SRCFLAGS...) {
    # PROTO_PATH is before ARCADIA_ROOT in includes because in gazetteer we don't use builtins now and paths'canonization (resolving) depends on order of roots.
    # descriptor.proto must be resolved as google/protobuf/descriptor.proto
    .CMD=${tool:"dict/gazetteer/converter"} -I$PROTO_PATH -I$ARCADIA_ROOT ${SRCFLAGS} ${input:SRC} ${output;nopath;noext:SRC.proto} ${kv;hide:"p GZ"} ${kv;hide:"pc yellow"}
    .PEERDIR=kernel/gazetteer/proto
}

macro _SRC("pyx", SRC, SRCFLAGS...) {
    # Copy-paste from BUILDWITH_CYTHON
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS --cplus -I$ARCADIA_ROOT ${input:SRC} -o ${output;tobindir:SRC.cpp} $CYTHON_OUTPUT_INCLUDES ${SRCFLAGS} ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    .ADDINCL=contrib/tools/cython/Cython/Includes
}

macro _SRC("in", SRC, SRCFLAGS...) {
   .CMD=$CONFIGURE_FILE(${SRC} ${nopath;noext:SRC})
}

macro _SRC("sc", SRC, SRCFLAGS...) {
    .CMD=${tool:"tools/domschemec"} --in ${input:SRC} --out ${output:SRC.h} ${output_include;hide:"util/generic/strbuf.h"} ${output_include;hide:"util/generic/string.h"} ${output_include;hide:"util/generic/vector.h"} ${output_include;hide:"util/string/cast.h"} ${SRCFLAGS} ${kv;hide:"p SC"} ${kv;hide:"pc yellow"}
}

macro _SRC("external", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/fetch_from_external.py"} ${input:SRC} ${output;nopath;noext:SRC} ${kv;hide:"p CC"} ${kv;hide:"pc light-green"}
}

macro _SRC("f", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/f2c.py"} -t ${tool:"contrib/tools/f2c"} -c ${input:SRC} -o ${output:SRC.c} ${kv;hide:"p FT"} ${kv;hide:"pc light-green"}
    .PEERDIR=contrib/libs/libf2c
    .ADDINCL=contrib/libs/libf2c
}

macro _SRC("cpp", SRC, SRCFLAGS...) {
    .CMD=$_SRC_cpp($SRC $SRCFLAGS)
}

macro _SRC("cxx", SRC, SRCFLAGS...) {
    .CMD=$_SRC(cpp $SRC $SRCFLAGS)
}

macro _SRC("cc", SRC, SRCFLAGS...) {
    .CMD=$_SRC(cpp $SRC $SRCFLAGS)
}

macro _SRC("C", SRC, SRCFLAGS...) {
    .CMD=$_SRC(cpp $SRC $SRCFLAGS)
}

macro _SRC("c", SRC, SRCFLAGS...) {
    .CMD=$_SRC_c($SRC $SRCFLAGS)
}

macro _SRC("m", SRC, SRCFLAGS...) {
    .CMD=$_SRC(c $SRC $SRCFLAGS)
}

macro _SRC("masm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_masm($SRC $SRCFLAGS)
}

macro _SRC("yasm", SRC, SRCFLAGS...) {
    .CMD=$_SRC_yasm($SRC $SRCFLAGS)
}

macro _SRC("asm", SRC, SRCFLAGS...) {
    .CMD=$_SRC(yasm $SRC $SRCFLAGS)
}

macro _SRC("po", SRC, SRCFLAGS...) {
    .CMD=$YMAKE_PYTHON ${input:"contrib/tools/python/src/Tools/i18n/msgfmt.py"} -o ${output;noauto;nopath;noext;tobindir:SRC.mo} ${input:SRC}
}

macro _SRC("supp", SRC, SRCFLAGS...) {
    .CMD=$COPY_CMD ${input:SRC} ${output;suf=.o:SRC} ${kv;hide:"p SP"} ${kv;hide:"pc light-cyan"}
}

macro _SRC("ydl", SRC, SRCFLAGS...) {
    .CMD=${tool:"statbox/ydl/compiler/tooling/ydlc/bin"} --force-color -I ${ARCADIA_ROOT} --cpp-output-header ${output;suf=.h:SRC} --cpp-output-source ${output;suf=.cpp:SRC} ${input:SRC} ${output_include;hide:"statbox/ydl/runtime/cpp/gen_support/standard_includes.h"} ${kv;hide:"p YDL"} ${kv;hide:"pc yellow"}
    .PEERDIR+=statbox/ydl/runtime/cpp
}

### @usage SRC(File Flags...)
###
### Compile single file with extra Flags.
### Compilation is driven by the last extension of the File and Flags are specific to corresponding compilation command
macro SRC(FILE, FLAGS...) {
    _SRC(${lastext:FILE} $FILE $FLAGS)
}

### @usage: SRCS(<[GLOBAL] File> ...)
###
### Source files of the project
### Arcadia Paths from the root and is relative to the project's LIST are supported
###
### GLOBAL marks next file as direct input link of the program/shared library project built into
### The scope of the GLOBAL keyword - the following file (that is, in the case of SRCS(GLOBAL foo.the cpp bar.cpp) global will be only foo.cpp)
###
### @example:
### Consider the file to ya.make:
### ```
###     LIBRARY(test_global)
###     SRCS(GLOBAL foo.cpp)
###     END()
### ```
### SRCS(GLOBAL foo.cpp) - use to PROGRAM and DLL that is implicitly* peerdir Yat test_global had clearly been linked with foo.cpp.o.
### - we say that prog1 (or dll1) implicitly peerdirs libN, if there is a
### relationship of the form: "prog1 (or dll1) peerdirs lib1, lib1 peerdirs lib2,
### ..., libN-1 peerdirs libN"
macro SRCS(FILES...) {
    foreach (FILE : $FILES) {
        _SRC(${lastext:FILE} $FILE)
    }
}

### @usage SRC_C_SSE2(File Flags...)
### Compile single .c-file with SSE2 and extra Flags
macro SRC_C_SSE2(FILE, FLAGS...) {
    _SRC(c $FILE $SSE2_CFLAGS $FLAGS)
}

### @usage SRC_C_SSE3(File Flags...)
### Compile single .c-file with SSE3 and extra Flags
macro SRC_C_SSE3(FILE, FLAGS...) {
    _SRC(c $FILE $SSE3_CFLAGS $FLAGS)
}

### @usage SRC_C_SSSE3(File Flags...)
### Compile single .c-file with SSSE3 and extra Flags
macro SRC_C_SSSE3(FILE, FLAGS...) {
    _SRC(c $FILE $SSSE3_CFLAGS $FLAGS)
}

### @usage SRC_C_SSE41(File Flags...)
### Compile single .c-file with SSE4.1 and extra Flags
macro SRC_C_SSE41(FILE, FLAGS...) {
    _SRC(c $FILE $SSE41_CFLAGS $FLAGS)
}

### @usage SRC_C_SSE4(File Flags...)
### Compile single .c-file with SSE4 (SSE4.1, SSE4.2 and POPCNT) and extra Flags
macro SRC_C_SSE4(FILE, FLAGS...) {
    _SRC(c $FILE $SSE4_CFLAGS $FLAGS)
}

### @usage SRC_C_AVX(File Flags...)
### Compile single .c-file with AVX and extra Flags
macro SRC_C_AVX(FILE, FLAGS...) {
    _SRC(c $FILE $AVX_CFLAGS $FLAGS)
}

### @usage SRC_C_AVX2(File Flags...)
### Compile single .c-file with AVX2 and extra Flags
macro SRC_C_AVX2(FILE, FLAGS...) {
    _SRC(c $FILE $AVX2_CFLAGS $FLAGS)
}

### @usage SRC_CPP_SSE2(File Flags...)
### Compile single .cpp-file with SSE2 and extra Flags
macro SRC_CPP_SSE2(FILE, FLAGS...) {
    _SRC(cpp $FILE $SSE2_CFLAGS $FLAGS)
}

### @usage SRC_CPP_SSE3(File Flags...)
### Compile single .cpp-file with SSE3 and extra Flags
macro SRC_CPP_SSE3(FILE, FLAGS...) {
    _SRC(cpp $FILE $SSE3_CFLAGS $FLAGS)
}

### @usage SRC_CPP_SSSE3(File Flags...)
### Compile single .cpp-file with SSSE3 and extra Flags
macro SRC_CPP_SSSE3(FILE, FLAGS...) {
    _SRC(cpp $FILE $SSSE3_CFLAGS $FLAGS)
}

### @usage SRC_CPP_SSE41(File Flags...)
### Compile single .cpp-file with SSE4.1 and extra Flags
macro SRC_CPP_SSE41(FILE, FLAGS...) {
    _SRC(cpp $FILE $SSE41_CFLAGS $FLAGS)
}

### @usage SRC_CPP_SSE4(File Flags...)
### Compile single .cpp-file with SSE4 (SSE4.1, SSE4.2 and POPCNT) and extra Flags
macro SRC_CPP_SSE4(FILE, FLAGS...) {
    _SRC(cpp $FILE $SSE4_CFLAGS $FLAGS)
}

### @usage SRC_CPP_AVX(File Flags...)
### Compile single .cpp-file with AVX and extra Flags
macro SRC_CPP_AVX(FILE, FLAGS...) {
    _SRC(cpp $FILE $AVX_CFLAGS $FLAGS)
}

### @usage SRC_CPP_AVX2(File Flags...)
### Compile single .cpp-file with AVX2 and extra Flags
macro SRC_CPP_AVX2(FILE, FLAGS...) {
    _SRC(cpp $FILE $AVX2_CFLAGS $FLAGS)
}

# TODO: use it in [.pyx] cmd
### @usage: BUILDWITH_CYTHON_CPP(Src Options...)
###
### Generates. cpp file from .pyx
macro BUILDWITH_CYTHON_CPP(Src, Options...) {
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} --cplus -I$ARCADIA_ROOT ${input:Src} -o ${output;tobindir:Src.cpp} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(contrib/tools/cython/Cython/Includes)
}

### @usage: _BUILDWITH_CYTHON_CPP_DEP(Src Dep Options...) # internal
###
### Generates .cpp file from .pyx and attach extra input Dep
### If Dep changes the .cpp file will be re-generated
macro _BUILDWITH_CYTHON_CPP_DEP(Src, Dep, Options...) {
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} --cplus -I$ARCADIA_ROOT ${input:Src} ${input;hide:Dep} -o ${output;tobindir:Src.cpp} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(contrib/tools/cython/Cython/Includes)
}

### @usage: BUILDWITH_CYTHON_C(Src Options...)
###
### Generates .c file from .pyx
macro BUILDWITH_CYTHON_C(Src, Options...) {
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} -I$ARCADIA_ROOT ${input:Src} -o ${output;tobindir:Src.c} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(contrib/tools/cython/Cython/Includes)
}

### @usage: _BUILDWITH_CYTHON_C_DEP(Src Dep Options...) # internal
###
### Generates .c file from .pyx and attach extra input Dep
### If Dep changes the .c file will be re-generated
macro _BUILDWITH_CYTHON_C_DEP(Src, Dep, Options...) {
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} -I$ARCADIA_ROOT ${input:Src} ${input;hide:Dep} -o ${output;tobindir:Src.c} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(contrib/tools/cython/Cython/Includes)
}

### @usage: _BUILDWITH_CYTHON_C_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_C without .pyx infix and with cdef public .h file.
macro _BUILDWITH_CYTHON_C_H(Src, Dep, Options...) {
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} -I$ARCADIA_ROOT ${input:Src} ${input;hide:Dep} -o ${output;noext;tobindir:Src.c} ${output;hide;addincl;noext;tobindir:Src.h} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(contrib/tools/cython/Cython/Includes)
}

### @usage: _BUILDWITH_CYTHON_C_API_H(Src Dep Options...) # internal
###
### BUILDWITH_CYTHON_C_H with cdef api _api.h file.
macro _BUILDWITH_CYTHON_C_API_H(Src, Dep, Options...) {
    .CMD=$YMAKE_PYTHON $CYTHON_SCRIPT $CYTHON_OPTIONS ${Options} -I$ARCADIA_ROOT ${input:Src} ${input;hide:Dep} -o ${output;noext;tobindir:Src.c} ${output;hide;addincl;noext;tobindir:Src.h} ${output;hide;addincl;noext;defext=_api.h;tobindir:Src} $CYTHON_OUTPUT_INCLUDES ${kv;hide:"p CY"} ${kv;hide:"pc yellow"}
    ADDINCL(contrib/tools/cython/Cython/Includes)
}

### @usage: BUILDWITH_RAGEL6(Src Options...)
###
### Compile .rl file using Ragel6
macro BUILDWITH_RAGEL6(Src, Options...) {
    .CMD=$RUN_NO_SANITIZE ${tool:"contrib/tools/ragel6"} $RAGEL6_FLAGS ${Options} -I${ARCADIA_ROOT} -o ${output;nopath;noext;defext=.rl6.cpp:Src} ${input:Src} ${kv;hide:"p R6"} ${kv;hide:"pc yellow"}
}

# TODO: use it in [.pyx] cmd
### @usage: _PY_REGISTER() # internal
###
### Register Python 2.x module in internal resource file system. Arcadia Python 2.x importer will be retrieve these on import directive
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY_REGISTER(Func) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_py_reg.py"} $Func ${output;noauto:Func.reg.cpp} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Func.reg.cpp)
}

### @usage: _PY3_REGISTER() # internal
###
### Register Python 3.x module in internal resource file system. Arcadia Python 3.x importer will be retrieve these on import directive
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY3_REGISTER(Func) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_py3_reg.py"} $Func ${output;noauto:Func.reg3.cpp} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Func.reg3.cpp)
}

### @usage: _PY_COMPILE_BYTECODE(SrcX Src) # internal
###
### Compile Python 2.x .py source file into Arcadia binary form suitable for PY_PROGRAM
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY_COMPILE_BYTECODE(SrcX, Src) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/py_compile.py"} $SrcX ${input:Src} ${output;noauto:Src.yapyc} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
}

### @usage: _PY3_COMPILE_BYTECODE(SrcX Src) # internal
###
### Compile Python 3.x .py source file into Arcadia binary form suitable for PY3_PROGRAM
### Documentation: https://wiki.yandex-team.ru/devtools/commandsandvars/pysrcs/#makrospyregister
macro _PY3_COMPILE_BYTECODE(SrcX, Src) {
    .CMD=${env:"PYTHONHASHSEED=0"} ${tool:"contrib/tools/python3/pycc"} $SrcX ${input:Src} ${output;noauto:Src.yapyc3} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"}
}

### @usage: ARCHIVE_ASM(NAME archive_name files...)
###
### Similar to the macro ARCHIVE, but ARCHIVE_ASM:
### 1. works faster and it is better to use for large files.
### 2. Different syntax (see examples in codesearch or users/pg/tests/archive_test)
macro ARCHIVE_ASM(NAME="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q $DONTCOMPRESS ${input;join=\: :Files}: -o ${output;chksum;suf=$OBJ_SUF.rodata:NAME} ${kv;hide:"p AR"} ${kv;hide:"pc light-cyan"}
}

### yweb specific
macro PIRE_INLINE_CMD(SRC) {
   .CMD=${tool:"library/regex/pire/inline"} -o ${output:SRC} ${input:SRC} ${output_include;hide:SRC} ${kv;hide:"p PI"} ${kv;hide:"pc yellow"}
}

macro PIRE_INLINE(FILES...) {
    foreach (FILE : $FILES) {
        PIRE_INLINE_CMD($FILE)
    }
}

### @usage: ARCHIVE(NAME, archive_name files...)
###
### To add data (resources, arbitrary files)
### Example: https://wiki.yandex-team.ru/yatool/howtowriteyamakefiles/#a1ispolzujjtekomanduarchive
macro ARCHIVE(NAME="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q -x $DONTCOMPRESS ${input;join=\: :Files}: -o ${output;chksum;addincl;noauto:NAME} ${kv;hide:"p AR"} ${kv;hide:"pc light-red"}
}

macro ARCHIVE_BY_KEYS(NAME="", KEYS="", DONTCOMPRESS?"-p":"", Files...) {
    .CMD=$ARCH_TOOL -q -x $DONTCOMPRESS ${input:Files} -k $KEYS -o ${output;chksum;addincl;noauto:NAME} ${kv;hide:"p AR"} ${kv;hide:"pc light-red"}
}

#scripts

#special commands
SVNVERSION_SCRIPT=build/scripts/svn_version_gen.py
BUILDVERSION_SCRIPT=build/scripts/build_info_gen.py
SVNVERSION_JAVA_MARKER=output-java-class
SVNVERSION_GO_MARKER=output-go

### @usage: CREATE_SVNVERSION_FOR()
### Creates a .h-file with information about the svn revision and various other things
###
### Can lead to frequent rebuilding programs.
### Partly off by setting to yes NO_SVN_DEPENDS
macro CREATE_SVNVERSION_FOR(Unused, GenHdr) {
    .CMD=$YIELD $ARCADIA_ROOT && $YIELD $ARCADIA_BUILD_ROOT && $YIELD ${quo:YMAKE_PYTHON} && $XARGS $YMAKE_PYTHON ${input:SVNVERSION_SCRIPT} ${output;chksum:GenHdr} $SVN_DEPENDS $SVN_DEPENDS_CACHE ${kv;hide:"p SV"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"}
}

### @usage: CREATE_JAVA_SVNVERSION_FOR()
### Creates a .java-file with information about the svn revision and various other things
###
### Can lead to frequent rebuilding programs.
### Partly off by setting to yes NO_SVN_DEPENDS
macro CREATE_JAVA_SVNVERSION_FOR(GenHdr) {
    .CMD=$YIELD $SVNVERSION_JAVA_MARKER && $YIELD $ARCADIA_ROOT && $YIELD $ARCADIA_BUILD_ROOT && $YIELD ${quo:YMAKE_PYTHON} && $XARGS $YMAKE_PYTHON ${input:SVNVERSION_SCRIPT} ${output;chksum:GenHdr} $SVN_DEPENDS $SVN_DEPENDS_CACHE ${kv;hide:"p SV"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"}
}

### @usage: CREATE_GO_SVNVERSION_FOR()
### Creates a .go-file with information about the svn revision and various other things
###
### Can lead to frequent rebuilding programs.
### Partly off by setting to yes NO_SVN_DEPENDS
macro CREATE_GO_SVNVERSION_FOR(GenHdr) {
    .CMD=$YIELD $SVNVERSION_GO_MARKER && $YIELD $ARCADIA_ROOT && $YIELD $ARCADIA_BUILD_ROOT && $YIELD ${quo:YMAKE_PYTHON} && $XARGS $YMAKE_PYTHON ${input:SVNVERSION_SCRIPT} ${output;chksum:GenHdr} $SVN_DEPENDS $SVN_DEPENDS_CACHE ${kv;hide:"p SV"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"}
}

### @usage: CREATE_BUILDINFO_FOR(GenHdr)
### Creates header file to access some information about build specified via configuration variables
### Unlike CREATE_SVNVERSION_FOR() it doesn't take revion information from VCS, it uses revision and SandboxTaskId passed via -D options to ya make
macro CREATE_BUILDINFO_FOR(GenHdr) {
    .CMD=$YIELD $CXX_COMPILER && $YIELD $CXXFLAGS && $XARGS $YMAKE_PYTHON ${input:BUILDVERSION_SCRIPT} ${output:GenHdr} ${kv;hide:"p BI"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"} $SVN_DEPENDS_CACHE
}

DECIMAL_MD5_SCRIPT=build/scripts/decimal_md5.py
DECIMAL_MD5_FIXED=

### @usage: DECIMAL_MD5_LOWER_32_BITS(<fileName> [FUNCNAME funcName] [inputs...])
###
### Generates .cpp file <fileName> with one defined function 'const char* <funcName>() { return "<calculated_md5_hash>"; }'.
### <calculated_md5_hash> will be md5 hash for all inputs passed to this macro.
macro DECIMAL_MD5_LOWER_32_BITS(File, FUNCNAME="", Opts...) {
    .CMD=$YMAKE_PYTHON ${input:DECIMAL_MD5_SCRIPT} --fixed-output=${DECIMAL_MD5_FIXED} --func-name=${FUNCNAME} --lower-bits 32 --source-root=$ARCADIA_ROOT ${input:Opts} ${output;stdout;chksum:File} ${kv;hide:"p SV"} ${kv;hide:"pc yellow"} ${hide;kv:"show_out"}
}

### @usage $CFG_VARS # internal
### Mark commands that embed Configuration variables into files
macro CFG_VARS() {
    .GEN_FROM_FILE=yes
}

### @usage: CONFIGURE_FILE(from to @ONLY)
### Copy files with the replacement @CMakeListsVar@ variable CMakeListsVar from ya.make during the build.
### Similar to the processing of files with the extension .in
macro CONFIGURE_FILE(Src, Dst) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/configure_file.py"} ${input:Src} ${output;addincl:Dst} $CFG_VARS ${kv;hide:"p CF"} ${kv;hide:"pc yellow"}
}

### @usage: BASE_CODEGEN(tool_path prefix)
###
### Generator ${prefix}.cpp + ${prefix}.h files based on ${prefix}.in
macro BASE_CODEGEN(Tool, Prefix, Opts...) {
    .CMD=${tool:Tool} ${input:Prefix.in} ${output;nopath;noauto:Prefix.cpp} ${output;nopath:Prefix.h} $Opts ${kv;hide:"p BC"} ${kv;hide:"pc yellow"}
}

### @usage: _SPLIT_CODEGEN_BASE(tool prefix OUTS[] OUTPUT_INCLUDES[]) # internal
###
### Generator of a certain number .the. cpp file + one header .h file from .in
### This is the call of the generator. Python macro SPLIT_CODEGEN() is defined in order to properly fill command outputs from OUT_NUM argument
macro _SPLIT_CODEGEN_BASE(Tool, Prefix, OUT[], OPTS[], OUTPUT_INCLUDES[]) {
    .CMD=${tool:Tool} ${input:Prefix.in} ${output;hide:OUT} ${output;nopath;noauto:Prefix.cpp} ${output;nopath:Prefix.h} $OPTS ${output_include;hide:OUTPUT_INCLUDES} ${kv;hide:"p SC"} ${kv;hide:"pc yellow"}
}

STRUCT_CODEGEN_OUTPUT_INCLUDES=${output_include;hide:"util/generic/singleton.h"} \
${output_include;hide:"util/generic/strbuf.h"} \
${output_include;hide:"util/generic/vector.h"} \
${output_include;hide:"util/generic/ptr.h"} \
${output_include;hide:"util/generic/yexception.h"} \
${output_include;hide:"kernel/struct_codegen/reflection/reflection.h"} \
${output_include;hide:"kernel/struct_codegen/reflection/floats.h"}

### @usage: STRUCT_CODEGEN(Prefix)
### A special case BASE_CODEGEN, in which the kernel/struct_codegen/codegen_tool tool is used
macro STRUCT_CODEGEN(Prefix) {
    .CMD=$BASE_CODEGEN(kernel/struct_codegen/codegen_tool, $Prefix, $STRUCT_CODEGEN_OUTPUT_INCLUDES)
    .PEERDIR=kernel/struct_codegen/metadata kernel/struct_codegen/reflection
}

### @usage: DUMPERF_CODEGEN(Prefix)
### A special case BASE_CODEGEN, in which the extsearch/images/robot/tools/dumperf/codegen tool is used
macro DUMPERF_CODEGEN(Prefix) {
    .CMD=$BASE_CODEGEN(extsearch/images/robot/tools/dumperf/codegen, $Prefix, ${output_include;hide:"extsearch/images/kernel/erf/erf_format.h"})
}

### @usage: LDFLAGS(LinkerFlags...)
###
### Add flags to the linkage command line of executable or shared library/dll.
### Note: LDFLAGS are always global - when set in the library module they will affect all programs/dlls/tests the library is linked into.
### Note: remember about the incompatibility of flags for gcc and cl.
macro LDFLAGS(Flags...) {
    SET_APPEND(LDFLAGS_GLOBAL $Flags)
}

### @usage: LDFLAGS_FIXED(LinkerFlags...)
###
### Fixed version of LDFLAGS "macro" which does not substitute build variables in some cases.
### Use this fixed version to workaround.
### Note: LDFLAGS are always global - when set in the library module they will affect all programs/dlls/tests the library is linked into.
### Note: remember about the incompatibility of flags for gcc and cl.
macro LDFLAGS_FIXED(Flags...) {
    SET_APPEND(LDFLAGS $Flags)
    SET_APPEND(LDFLAGS_GLOBAL $Flags)
}

### @usage: CFLAGS([GLOBAL compiler_flag]* compiler_flags)
### Add the specified flags to the compilation command of C and C++ files.
### @params: GLOBAL - Propagates these flags to dependent projects
### Note: remember about the incompatibility flags for gcc and cl (to set flags specifically for cl.exe use MSVC_FLAGS).
macro CFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CFLAGS $Flags)
}

### @usage: MASMFLAGS(compiler flags)
### Add the specified flags to the compilation command of .masm files.
macro MASMFLAGS(Flags...) {
   SET_APPEND(MASMFLAGS $Flags)
}

### @usage: CONLYFLAGS([GLOBAL compiler_flag]* compiler_flags)
### Add the specified flags to the compilation command of .c (but not .cpp) files.
### @params: GLOBAL - Distributes these flags on dependent projects
macro CONLYFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CONLYFLAGS $Flags)
}

### @usage: CXXFLAGS(compiler_flags)
### Add the specified flags to the compilation command of .cpp (but not .c) files.
macro CXXFLAGS(Flags...) {
   SET_APPEND_WITH_GLOBAL(USER_CXXFLAGS $Flags)
}

### @usage: CUDA_NVCC_FLAGS(compiler flags)
### Add the specified flags to the compile line .cu-files.
macro CUDA_NVCC_FLAGS(Flags...) {
   SET_APPEND(CUDA_NVCC_FLAGS $Flags)
}

### @usage: STRIP()
### Strip debug info from a PROGRAM, DLL or TEST.
### This macro doesn't work in LIBRARY's, UNION's and PACKAGE's
macro STRIP() {
    ENABLE(STRIP)
}

### @usage: NO_OPTIMIZE()
### Build code without any optimizations (-O0 mode)
macro NO_OPTIMIZE() {
    ENABLE(NO_OPTIMIZE)
}

### @usage: NO_COMPILER_WARNINGS()
### Diasable all compiler warnings in the module.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR
macro NO_COMPILER_WARNINGS() {
    ENABLE(NO_COMPILER_WARNINGS)
    ENABLE(NO_WSHADOW)
}

### @usage: WERROR()
### Consider warnings as errors in the current module.
### In the bright future will be removed, since WERROR is the default.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR
macro WERROR() {
    # TODO: fix WERROR and MSVC_WERROR macros
    # when ($MSVC != "yes") ENABLE(WERROR)
    ENABLE(WERROR)
}

### @usage: NO_WERROR()
### Override WERROR() behavior
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR
macro NO_WERROR() {
    DISABLE(WERROR)
}

### @usage: NO_WSHADOW()
### Disable C++ shadowing warnings
macro NO_WSHADOW() {
    ENABLE(NO_WSHADOW)
}

### @usage: NO_PLATFORM_RESOURCES() # incternal
### Exlude dependency on platform resources libraries.
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro NO_PLATFORM_RESOURCES() {
    ENABLE(NOPLATFORM_RESOURCES)
}

### @usage: NO_CODENAVIGATION() # incternal
### Disable codenaviagtion for a module. Needed to avoid PEERDIR loops in codenavigation support.
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro NO_CODENAVIGATION() {
    ENABLE(NOCODENAVIGATION)
}

### @usage: NO_UTIL()
### Build module without dependency on util.
### Note: use this with care. Util most likely will be linked into executable anyway,
### so using util headers/functions/classes may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_UTIL() {
    ENABLE(NOUTIL)
}

### @usage: NO_RUNTIME()
###
### This macro:
### 1. Sets the ENABLE(NOUTIL) + DISABLE(USE_INTERNAL_STL)
### 2. If the project that contains the macro NO_RUNTIME(), peerdir-it project does not contain NO_RUNTIME() => Warning
### Note: use this with care. Arcadia STL most likely will be linked into executable anyway,
### so using STL headers/functions/classes may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_RUNTIME() {
    SET(USE_ARCADIA_LIBM no)
    NO_UTIL()
    ENABLE(NORUNTIME)
}

### @usage: NO_LIBC()
###
### Exclude dependencies on C++ and C runtimes (including util, musl and libeatmydata)
### Note: use this with care. libc most likely will be linked into executable anyway,
### so using libc headers/functions may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_LIBC() {
    NO_RUNTIME()
    DISABLE(MUSL)
    # libeatmydata isn't compatible with MUSL
    DISABLE(USE_EAT_MY_DATA)
}

### @usage: NO_PLATFORM()
###
### Exclude dependencies on C++ and C runtimes (including util, musl and libeatmydata) and set NO_PLATFORM variable for special processing.
### Note: use this with care. libc most likely will be linked into executable anyway,
### so using libc headers/functions may not be detected at build time and may lead to unpredictable behavors at configure time.
macro NO_PLATFORM() {
    NO_LIBC()
    ENABLE(NOPLATFORM)
}


### @usage: NO_JOIN_SRC() # deprecated, does-nothing
### This macro currently does nothing. This is default behavior which cannot be overriden at module level.
macro NO_JOIN_SRC() {
    ENABLE(UNUSED_MACRO)
}

### @usage: JOINSRC() # deprecated, does-nothing
### This macro currently does nothing. Use JOIN_SRCS and similar macros to make one file of set of sources.
macro JOINSRC() {
    ENABLE(UNUSED_MACRO)
}

### @usage: NO_SANITIZE()
###
### Disable all sanitizers for the module
macro NO_SANITIZE() {
    DISABLE(SANITIZER_TYPE)
}

### @usage: NO_SANITIZE_COVERAGE()
###
### Disable lightweight coverage (-fsanitize-coverage) for the module
macro NO_SANITIZE_COVERAGE() {
    DISABLE(SANITIZE_COVERAGE)
}

### @usage: NO_CLANG_COVERAGE()
###
### Disable heavyweight clang coverage for the module
macro NO_CLANG_COVERAGE() {
    DISABLE(CLANG_COVERAGE)
}

LUAJIT_PATH=$ARCADIA_ROOT/contrib/libs/luajit/
macro _LUAJIT_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_PATH} ${tool:"contrib/libs/luajit/compiler"} -b -g ${input:Src} ${output;noauto:OUT} ${kv;hide:"p LJ"} ${kv;hide:"pc light-cyan"}
}

LUAJIT_21_PATH=$ARCADIA_ROOT/contrib/libs/luajit_21/
macro _LUAJIT_21_OBJDUMP(Src, OUT="") {
   .CMD=${cwd:LUAJIT_21_PATH} ${tool:"contrib/libs/luajit_21/compiler"} -b -g ${input:Src} ${output;noauto:OUT} ${kv;hide:"p LJ"} ${kv;hide:"pc light-cyan"}
}

macro _MX_BIN_TO_INFO(Src) {
    .CMD=${tool:"tools/mx_bin2info"} ${input:Src} ${output;nopath;noext;noauto:Src.info} ${kv;hide:"p MX"} ${kv;hide:"pc yellow"}
}

MX_GEN_TABLE_INCLS=${output_include;hide:"yabs_mx_calc_table.h"} \
${output_include;hide:"kernel/matrixnet/mn_sse.h"} \
${output_include;hide:"library/archive/yarchive.h"} \
${output_include;hide:"util/memory/blob.h"} \
${output_include;hide:"util/generic/hash.h"} \
${output_include;hide:"util/generic/ptr.h"} \
${output_include;hide:"util/generic/singleton.h"}

macro _MX_GEN_TABLE(Srcs...) {
   .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_mx_table.py"} $Srcs ${output;stdout:"mx_tables.cpp"} $MX_GEN_TABLE_INCLS ${kv;hide:"p MX"} ${kv;hide:"pc yellow"}
   PEERDIR(kernel/matrixnet)
   PEERDIR(library/archive)
}

RELEV_FML_CODEGEN_INCLS=${output_include;hide:"kernel/relevfml/relev_fml.h"} ${output_include;hide:"library/sse/sse.h"}

### @usage: GENERATE_ENUM_SERIALIZATION(File.h)
###
### Create serialization support for enumeration members defined in the header (String <-> Enum conversions) and compile it into the module.
### Documentation: https://wiki.yandex-team.ru/yatool/HowToWriteYaMakeFiles/
macro GENERATE_ENUM_SERIALIZATION(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --include-path ${input;rootrel:File} --output ${output;chksum;suf=_serialized.cpp:File} ${output_include;hide:File} ${output_include;hide:"util/generic/serialized_enum.h"} ${kv;hide:"p EN"} ${kv;hide:"pc yellow"}
    PEERDIR(tools/enum_parser/enum_serialization_runtime)
}

### @usage: GENERATE_ENUM_SERIALIZATION_WITH_HEADER(File.h)
### Create serialization support for enumeration members defined in the header (String <-> Enum conversions) and compile it into the module
### Provide access to serialization functions via generated header File_serialized.h
### Documentation: https://wiki.yandex-team.ru/yatool/HowToWriteYaMakeFiles/
macro GENERATE_ENUM_SERIALIZATION_WITH_HEADER(File) {
    .CMD=$ENUM_PARSER_TOOL ${input:File} --include-path ${input;rootrel:File} --output ${output;chksum;suf=_serialized.cpp:File} --header ${output;chksum;suf=_serialized.h:File} ${output_include;hide:File} ${kv;hide:"p EN"} ${kv;hide:"pc yellow"}
    PEERDIR(tools/enum_parser/enum_serialization_runtime)
}

### @usage: DEB_VERSION(File)
###
### Creates a header file DebianVersion.h define the DEBIAN_VERSION taken from the File
macro DEB_VERSION(File) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/mkver.py"} ${input:File} ${output;stdout:"DebianVersion.h"} ${kv;hide:"p CL"} ${kv;hide:"pc yellow"}
}

BUILD_MN_SCRIPT=build/scripts/build_mn.py

### @usage: BUILD_MN([CHECK] [PTR] [MULTI] mninfo mnname) # matrixnet
###
### Generate MatrixNet data and access code using single command.
### Alternative macro BUILD_MNS() works faster and better for large files.
macro BUILD_MN(MnInfo, MnName, CHECK?"fml_tool=$FML_UNUSED_TOOL CHECK":"", MULTI?, PTR?, RANKING_SUFFIX="") {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnF $ARCADIA_ROOT $ARCH_TOOL ${input:MnInfo} $MnName ranking_suffix=$RANKING_SUFFIX ${output;chksum;pre=mn.:MnName.cpp} ${output;hide;pre=MN_External_;suf=.rodata:MnName} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} $CHECK $MULTI $PTR ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

macro _BUILD_MNS_FILE(Input, Name, Output, Suffix, Check, Fml_tool, AsmDataName) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnsFilesF $ARCADIA_ROOT $BINDIR $ARCH_TOOL fml_tool=$Fml_tool $Name ranking_suffix=$Suffix ${input:Input} ${output;hide:Output} ${output;hide;pre=MN_External_;suf=.rodata:AsmDataName} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

MNS_OUTPUT=mnmodels

macro _BUILD_MNS_CPP(NAME="", CHECK?, RANKING_SUFFIX="", Files...) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnsCppF $NAME ranking_suffix=$RANKING_SUFFIX ${input:MNS_OUTPUT.h} ${output:MNS_OUTPUT.cpp} ${input:Files} ${output_include;hide:MNS_OUTPUT.h} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

macro _BUILD_MNS_HEADER(NAME="", CHECK?, RANKING_SUFFIX="", Files...) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_MN_SCRIPT} BuildMnsHeaderF $NAME ranking_suffix=$RANKING_SUFFIX ${output:MNS_OUTPUT.h} ${input:Files} ${output_include;hide:"kernel/matrixnet/mn_sse.h"} ${output_include;hide:"kernel/matrixnet/mn_multi_categ.h"} ${kv;hide:"p MN"} ${kv;hide:"pc yellow"}
}

# TODO: support foreach_in and keywords simultaneous usage (look at BUILD_MNS_FILES)

### @usage: BUILD_MNS([CHECK] NAME listname mninfos...) # matrixnet
###
### Generate MatrixNet data and access code using separate commands for support code, interface and data.
### Faster version of BUILD_MN() macro for large files.
macro BUILD_MNS(Files...) {
    _BUILD_MNS_HEADER($Files)
    _BUILD_MNS_CPP($Files)
    _BUILD_MNS_FILES($Files)
}


BUILD_CATBOOST_SCRIPT=build/scripts/build_catboost.py
### @usage: BUILD_CB(cbmodel cbname)
###
### Generate catboost model and access code
### cbmodel - CatBoost model file name (*.cmb)
### cbname - name for a variable (of NCatboostCalcer::TCatboostCalcer type) to be available in CPP code
### CatBoost specific macro
macro BUILD_CATBOOST(CbModel, CbName) {
    .CMD=$YMAKE_PYTHON ${input:BUILD_CATBOOST_SCRIPT} build_cb_f $ARCADIA_ROOT $ARCH_TOOL ${input:CbModel} $CbName ${output;chksum;pre=cb.:CbName.cpp} ${output;hide;pre=CB_External_;suf=.rodata:CbName} ${output_include;hide:"kernel/catboost/catboost_calcer.h"} ${kv;hide:"p CB"} ${kv;hide:"pc yellow"}
}

### @usage: BUILD_PLNS(Src...)
###
### Generate interface header plnmodels.h for Relev model (PLN)
### Relev specific macro
macro BUILD_PLNS(Src...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/build_pln_header.py"} ${output:"plnmodels.h"} ${input:Src} $RELEV_FML_CODEGEN_INCLS ${kv;hide:"p PN"} ${kv;hide:"pc yellow"}
    .PEERDIR=kernel/relevfml library/sse
}

### @usage: NEED_CHECK()
###
### Commits to the project marked with this macro will be blocked by pre-commit check and then will be
### automatically merged to trunk only if there is no new broken build targets in check results.
### The use of this macro is disabled by default.
macro NEED_CHECK(Flags...) {
    # TODO: FIXME
    ENABLE(UNUSED_MACRO)
}

### @usage: NO_NEED_CHECK()
###
### Commits to the project marked with this macro will not be affected by higher-level NEED_CHECK macro.
macro NO_NEED_CHECK(Flags...) {
    ENABLE(UNUSED_MACRO)
}

### @usage: NEED_REVIEW() # deprecated
###
### Mark the project as needing review.
### Reviewers are listed in the macro OWNER. The use of this macro is disabled by default.
### Details can be found here: https://clubs.at.yandex-team.ru/arcadia/6104
macro NEED_REVIEW(Flags...) {
    # TODO: FIXME
    ENABLE(UNUSED_MACRO)
}

### @usage: LICENSE(licenses...)
###
### Specify the license of the module, separated by spaces
###
### A license must be prescribed for contribs
macro LICENSE(Flags...) {
    SET(LICENSE_NAMES $Flags)
}

### @usage: NO_GPL()
###
### To check the license of the dependencies, indicated by macro LICENSE, and fail the build in case of detection of GPL-like licenses.
### Do not use with LIBRARY().
### Issues a warning if the detected dependencies from contrib-ov in which the license is not specified.
macro NO_GPL() {
    SET(NO_GPL yes)
}

### @usage: VERSION(Args...)
###
### Specify version of a module. Currently unused by build system, only informative.
macro VERSION(Flags...) {
    ENABLE(UNUSED_MACRO)
}

DATAWORK_SCHEEME_EXPORT_FLAGS=

when ($UNIX == "yes") {
    SCHEEME2_CFLAGS= -E -x c++
}

when ($WIN32 == "yes") {
    SCHEEME2_CFLAGS= /E /TP
}

SCHEEME2_STRUCT_INFO_FLAGS=-f "const static ui32 RecordSig" -u "RecordSig" --gcc44_no_typename --no_complex_overloaded_func_export
### @usage: GEN_SCHEEME2(scheeme_name from_file dependent_files...)
###
### Generates a C++ description for structure(contains the field RecordSig) in the specified file (and connected).
###
### 1. ${scheeme_name}.inc - the name of the generated file.
### 2. Use an environment variable - DATAWORK_SCHEEME_EXPORT_FLAGS that allows to specify flags to tools/structparser
###
### @example:
###
###     SET(DATAWORK_SCHEEME_EXPORT_FLAGS --final_only -m "::")
###
### all options are passed to structparser (in this example --final_only - do not export heirs with public base that contains the required field,,- m "::" only from the root namespace)
### sets in extra option
###
### @example:
###
###     SET(EXTRACT_STRUCT_INFO_FLAGS -f \"const static ui32 RecordSig\"
###         -u \"RecordSig\" -n${scheeme_name}SchemeInfo ----gcc44_no_typename no_complex_overloaded_func_export
###         ${DATAWORK_SCHEEME_EXPORT_FLAGS})
###
### for compatibility with C++ compiler and the external environment.
### (the details necessary to look in tools/structparser)
macro GEN_SCHEEME2(ScheemeName, FromFile) {
    .CMD=$GCCFILTER $CXX_COMPILER -c ${tmp;stdout:FromFile.cph} $SCHEEME2_CFLAGS ${input:FromFile} ${pre=-I:INCLUDE} $CXXFLAGS -Wno-error && ${tool:"tools/structparser"} -o ${output:ScheemeName.inc} -n N${ScheemeName}SchemeInfo $SCHEEME2_STRUCT_INFO_FLAGS $DATAWORK_SCHEEME_EXPORT_FLAGS ${tmp:FromFile.cph} ${output;stdout;noauto:ScheemeName.inc.log} ${kv;hide:"p SH"} ${kv;hide:"pc yellow"}
}

### @usage: SYMLINK(from to)
### Add symlink
macro SYMLINK(From, To) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/symlink.py"} ${input;dirallowed:From} ${output;noauto:To} ${kv;hide:"p LN"} ${kv;hide:"pc light-cyan"}
}

### @usage: RUN_PROGRAM(tool_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...])
###
### Run a program from arcadia.
### These macros are similar: RUN_PROGRAM, LUA, PYTHON, BUILTIN_PYTHON.
###
### Parameters:
### - tool_path - Path to the directory of the tool.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN inputs... - Input files.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro RUN_PROGRAM(Tool, IN{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} ${tool:Tool} $Args ${input;hide:IN} ${input;hide:IN_DEPS} ${output_include;hide:OUTPUT_INCLUDES} ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p PR"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
}

### @usage: LUA(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...])
###
### Run a lua script.
### These macros are similar: RUN_PROGRAM, LUA, PYTHON, BUILTIN_PYTHON.
###
### Parameters:
### - script_path - Path to the script.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN inputs... - Input files.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro LUA(ScriptPath, IN{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $LUA_TOOL ${input:ScriptPath} $Args ${input;hide:IN} ${input;hide:IN_DEPS} ${output_include;hide:OUTPUT_INCLUDES} ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p LU"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
}

### @usage: PYTHON(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output] [OUTPUT_INCLUDES output_includes...])
###
### Run a python script with contrib/tools/python.
### These macros are similar: RUN_PROGRAM, LUA, PYTHON, BUILTIN_PYTHON.
###
### Parameters:
### - script_path - Path to the script.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN inputs... - Input files.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro PYTHON(ScriptPath, IN{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $PYTHON_BS_TOOL ${input:ScriptPath} $Args ${input;hide:IN} ${input;hide:IN_DEPS} ${output_include;hide:OUTPUT_INCLUDES} ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
}

### @usage: BUILTIN_PYTHON(script_path args... [CWD dir] [ENV key=value...] [TOOL tools...] [IN inputs...] [OUT[_NOAUTO] outputs...] [STDOUT[_NOAUTO] output]) [OUTPUT_INCLUDES output_includes...])
###
### Run a python script with ymake python.
### These macros are similar: RUN_PROGRAM, LUA, PYTHON, BUILTIN_PYTHON.
###
### Parameters:
### - script_path - Path to the script.
### - args... - Program arguments. Relative paths listed in TOOL, IN, OUT, STDOUT become absolute.
### - CWD dir - Absolute path of the working directory.
### - ENV key=value... - Environment variables.
### - TOOL tools... - Auxiliary tool directories.
### - IN inputs... - Input files.
### - OUT[_NOAUTO] outputs... - Output files. NOAUTO outputs are not automatically added to the build process.
### - STDOUT[_NOAUTO] output - Redirect the standard output to the output file.
### - OUTPUT_INCLUDES output_includes... - Includes of the output files that are needed to build them.
###
### For absolute paths use ${ARCADIA_ROOT} and ${ARCADIA_BUILD_ROOT}, or
### ${CURDIR} and ${BINDIR} which are expanded where the outputs are used.
macro BUILTIN_PYTHON(ScriptPath, IN{input}[], OUT{output}[], OUT_NOAUTO{output}[], TOOL{tool}[], OUTPUT_INCLUDES[], IN_DEPS[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], Args...) {
    .CMD=${cwd:CWD} ${env:ENV} $YMAKE_PYTHON ${input:ScriptPath} $Args ${input;hide:IN} ${input;hide:IN_DEPS} ${output_include;hide:OUTPUT_INCLUDES} ${tool;hide:TOOL} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p PY"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
}

macro _RUN_JAVA(IN{input}[], OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], TOOL[], STDOUT="", STDOUT_NOAUTO="", CWD="", ENV[], HIDE_OUTPUT?"stderr2stdout":"stdout2stderr", Args...) {
    PEERDIR(build/platform/java/jdk)
    .CMD=${cwd:CWD} ${env:ENV} $YMAKE_PYTHON ${input;pre=build/scripts/:HIDE_OUTPUT.py} $JDK_RESOURCE/bin/java $Args ${tool;hide:TOOL} ${input;hide:IN} ${output_include;hide:OUTPUT_INCLUDES} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${output;stdout:STDOUT} ${output;stdout;noauto:STDOUT_NOAUTO} ${kv;hide:"p JV"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"}
}

### @usage: FROM_SANDBOX([FILE] resource_id is OUT_[NOAUTO] <files from resource>)
###
### Downloads the file from the sandbox to the resource number, unpacks (if not explicitly specified word FILE) and adds the files with the specified names in the build.
### If the files do not compile, then you need to use the parameter OUT_NOAUTO.
### Specify the directory, as it build models - input and output data for the node assemblies must be determined.
macro FROM_SANDBOX(Id, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], FILE?"--copy-to-dir":"--untar-to", AUTOUPDATED="", PREFIX=".", Args...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_sandbox.py"} --resource-id $Id $FILE $PREFIX $OUT $OUT_NOAUTO ${input;hide:"build/scripts/fetch_from.py"} ${output_include;hide:OUTPUT_INCLUDES} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${requirements;hide:"network:full"} ${kv;hide:"p SB"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    ADD_CHECK(check.resource $Id)
}

### @usage: FROM_MDS([FILE] key OUT_[NOAUTO] <files from resource>)
###
### Downloads the file from MDS using key, unpacks (if not explicitly specified word FILE) and adds the files with the specified names in the build.
### If the files do not compile, then you need to use the parameter OUT_NOAUTO.
### Specify the directory, as it build models - input and output data for the node assemblies must be determined.
macro FROM_MDS(Key, OUT{output}[], OUT_NOAUTO{output}[], OUTPUT_INCLUDES[], FILE?"--copy-to-dir":"--untar-to", Args...) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/fetch_from_mds.py"} --key $Key $FILE . $OUT $OUT_NOAUTO ${input;hide:"build/scripts/fetch_from.py"} ${output_include;hide:OUTPUT_INCLUDES} ${output;hide:OUT} ${output;noauto;hide:OUT_NOAUTO} ${requirements;hide:"network:full"} ${kv;hide:"p MD"} ${kv;hide:"pc yellow"} ${kv;hide:"show_out"}
    ADD_CHECK(check.mds $Key)
}

when ($MSVC == "yes") {
    C_AS_CXX_FLAGS=/std:c++17
}
otherwise {
    C_AS_CXX_FLAGS=-x c++ -std=c++17
}

### @usage: COMPILE_C_AS_CXX()
###
### Compile .c files ad .cpp ones within a module
macro COMPILE_C_AS_CXX() {
    SET(EXTRA_C_FLAGS $C_AS_CXX_FLAGS)
}

### @usage: NO_DEBUG_INFO()
###
### Compile files without debug info collection
macro NO_DEBUG_INFO() {
    SET(NO_DEBUGINFO yes)
}

### @usage: IMPORT_YMAPS_PROTO() # maps-specific
###
### Maps-specific .proto handling: base proto dicrectory setup
macro IMPORT_YMAPS_PROTO() {
     YMAPS_PROTO_ROOT=maps/doc/proto
     YMAPS_PROTOC_INCLUDE=-I=$ARCADIA_ROOT/$YMAPS_PROTO_ROOT
     SET_APPEND(PROTO_PATH $YMAPS_PROTOC_INCLUDE)
     ADDINCL($YMAPS_PROTO_ROOT)
     ADDINCL(GLOBAL ${ARCADIA_BUILD_ROOT}/$YMAPS_PROTO_ROOT)
}

### @usage: EXPORT_YMAPS_PROTO() # maps-specific
###
### Maps-specific .proto handling: IMPORT_YMAPS_PROTO() + maps protobuf namespace
macro EXPORT_YMAPS_PROTO() {
    SET(PROTO_NAMESPACE maps/doc/proto)
    IMPORT_YMAPS_PROTO()
}

macro _YMAPS_GENERATE_SPROTO_HEADER(File) {
    .CMD=${cwd;rootdir;input:File} ${tool:"maps/libs/sproto/sprotoc"} -I=./$PROTO_NAMESPACE -I=$ARCADIA_ROOT/$PROTO_NAMESPACE -I=$ARCADIA_BUILD_ROOT -I=$PROTO_PATH --sproto_out=$ARCADIA_BUILD_ROOT/$PROTO_NAMESPACE ${input;rootrel:File} ${output;hide;norel;nopath;noext:File.sproto.h} ${kv;hide:"p PB"} ${kv;hide:"pc yellow"}
    .PEERDIR=maps/libs/sproto
}

### @usage: YMAPS_SPROTO(ProtoFiles...) # maps-specific
###
### Maps-specific .proto handling: generate .sproto.h files using maps/libs/sproto/sprotoc
macro YMAPS_SPROTO(FILES...) {
    SET(PROTO_HEADER_EXTS .pb.h .sproto.h)
    foreach (FILE : $FILES) {
        [.proto]=$_YMAPS_GENERATE_SPROTO_HEADER($FILE)
    }
}

### @usage: CTEMPLATE_VARNAMES(File)
###
### Generate File.varnames.h using contrib/libs/ctemplate/make_tpl_varnames_h
### Documentation: https://a.yandex-team.ru/arc/trunk/arcadia/contrib/libs/ctemplate/README.md
macro CTEMPLATE_VARNAMES(File) {
    .CMD=${tool:"contrib/libs/ctemplate/make_tpl_varnames_h"} -f ${output;addincl;nopath;noallext:File.varnames.h} ${input:File}
}

LLVM_OPTS=
CLANG_ROOT=$CLANG5_RESOURCE_GLOBAL

### @usage: GENERATED_SRCS(srcs... PARSE_META_FROM cpp_srcs... [OUTPUT_INCLUDES output_includes...] [OPTIONS])
###
### srcs... - list of text files which will be generated during build time by templates. Each template must be
###     placed to the place in source tree where corresponding source file should be generated. Name of
###     template must be "<name_of_src_file>.template". For example if you want to generate file "example.cpp"
###     then template should be named "example.cpp.template".
### PARSE_META_FROM cpp_srcs... - list of C++ source files (.cpp, .h) which will be parsed using clang library
###     and metainformation extracted from the files will be made available for templates. Example of
###     template code fragment using metainformation: {{ meta.objects["@N@std@S@string"].name }}
### OUTPUT_INCLUDES output_includes... - in cases when build system parser fails to determine all headers
###     which generated files include, you can specify additional headers here. In a normal situation this should
###     not be needed and this feature could be removed in the future.
### OPTIONS - additional options for code_generator utility
###
### Jinja 2 template engine is used for template generation.
### Examples of templates can be found in directory market/tools/code_generator/templates.
### Metainformation does not contain entries for every object declared in C++ files specified in PARSE_META_FROM
### parameter. To include some object into consideration you need to mark it by attribute. Attributes can
### automatically add more attributes to dependent objects. This behavior depends on attribute definition.
###
### More information will be available (eventually:) here: https://wiki.yandex-team.ru/Users/denisk/codegenerator/
macro GENERATED_SRCS(PARSE_META_FROM{input}[], OUTPUT_INCLUDES[], OPTIONS[], TEMPLATES...) {
    .CMD=${tool:"market/tools/code_generator"} --cpp-file ${input:PARSE_META_FROM} --templates-dir / ${ARCADIA_ROOT} --templates ${input:TEMPLATES.template} --generated-files ${output:TEMPLATES} ${output_include;hide:OUTPUT_INCLUDES} ${output_include;hide:PARSE_META_FROM} --arcadia-root ${ARCADIA_ROOT} --arcadia-build-root ${ARCADIA_BUILD_ROOT} --clang-root $CLANG_ROOT ${OPTIONS} -- $C_FLAGS_PLATFORM $CXXFLAGS ${pre=-I:INCLUDE} -std=c++17 -Wno-unknown-warning-option -Wno-unused-parameter -Wno-undefined-inline -Wno-undefined-internal -Wno-unused-function $LLVM_OPTS -fno-lto
    PEERDIR(contrib/libs/clang)
}

### @usage: CLANG_EMIT_AST_CXX(Input Output Opts...)
###
### Emit Clang AST from .cpp file. CXXFLAGS and LLVM_OPTS are passed in, while CGFLAGS and C_FLAGS_PLATFORM are not.
### Note: Output name is used as is, no extension added
macro CLANG_EMIT_AST_CXX(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS $GCCFILTER $CLANG_ROOT/bin/clang++ ${pre=-I:INCLUDE} $CXXFLAGS -Wno-unknown-warning-option $LLVM_OPTS -fno-lto -emit-ast -c ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p ST"} ${kv;hide:"pc light-green"}
    PEERDIR(contrib/libs/clang)
}

### @usage: LLVM_COMPILE_CXX(Input Output Opts...)
###
### Emit LLVM bytecode from .cpp file. BC_CXXFLAGS, LLVM_OPTS and C_FLAGS_PLATFORM are passed in, while CGFLAGS are not.
### Note: Output name is used as is, no extension added
macro LLVM_COMPILE_CXX(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS $GCCFILTER $CLANG_ROOT/bin/clang++ ${pre=-I:INCLUDE} $BC_CXXFLAGS $C_FLAGS_PLATFORM -Wno-unknown-warning-option $LLVM_OPTS -fno-lto -emit-llvm -c ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p BC"} ${kv;hide:"pc light-green"}
    PEERDIR(contrib/libs/clang)
}

### @usage: LLVM_COMPILE_C(Input Output Opts...)
###
### Emit LLVM bytecode from .c file. BC_CFLAGS, LLVM_OPTS and C_FLAGS_PLATFORM are passed in, while CGFLAGS are not.
### Note: Output name is used as is, no extension added
macro LLVM_COMPILE_C(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/clang_wrapper.py"} $WINDOWS $GCCFILTER $CLANG_ROOT/bin/clang ${pre=-I:INCLUDE} $BC_CFLAGS $C_FLAGS_PLATFORM $LLVM_OPTS -fno-lto -emit-llvm -c ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p BC"} ${kv;hide:"pc light-green"}
    PEERDIR(contrib/libs/clang)
}

### @usage: LLVM_COMPILE_LL(Input Output Opts...)
###
### Compile LLVM bytecode to object representation
### Note: Output name is used as is, no extension added
macro LLVM_COMPILE_LL(Input, Output, Opts...) {
    .CMD=$CLANG_ROOT/bin/llvm-as ${input:Input} -o ${output;noauto:Output} ${kv;hide:"p BC"} ${kv;hide:"pc light-green"}
    PEERDIR(contrib/libs/clang)
}

### @usage: LLVM_LINK(Output Inputs...)
###
### Call llvm-link on set of Inputs to produce Output.
### Note: Unlike many other macros output argument goes first. Output name is used as is, no extension added.
macro LLVM_LINK(Output, Inputs...) {
    .CMD=$CLANG_ROOT/bin/llvm-link ${input:Inputs} -o ${output;noauto:Output} ${kv;hide:"p LD"} ${kv;hide:"pc light-red"}
    PEERDIR(contrib/libs/clang)
}

### @usage: LLVM_OPT(Input Output Opts...)
###
### Call llvm-opt with set of Opts on Input to produce Output
### Note: Output name is used as is, no extension added.
macro LLVM_OPT(Input, Output, Opts...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/llvm_opt_wrapper.py"} $CLANG_ROOT/bin/opt ${input:Input} -o ${output;noauto:Output} $Opts ${kv;hide:"p OP"} ${kv;hide:"pc yellow"}
    PEERDIR(contrib/libs/clang)
}

when ($NO_DEBUGINFO == "yes") {
    DEBUG_INFO_FLAGS=
}

when ($CLANG && $DEBUGINFO_LINES_ONLY == "yes" && $NO_DEBUGINFO != "yes") {
    DEBUG_INFO_FLAGS=-gline-tables-only
}

# TODO: configurable tar and touch
PACK_TGZ=${cwd:ARCADIA_BUILD_ROOT} tar -czf ${rootrel:OUTPUT} ${rootrel:INPUT} ${kv;hide:"p AR"} ${kv;hide:"pc light-red"}
#TODO: Use ${input:"build/scripts/touch.py"} instead ${ARCADIA_ROOT}/build/scripts/touch.py
### @usage TOUCH(Outputs...) # internal
### Just introduce outputs  
macro TOUCH(Outputs...) {
    .CMD=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${output:Outputs}
}
TOUCH_UNIT=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${kv;hide:"p UN"} ${kv;hide:"pc light-cyan"} $TARGET
TOUCH_PACKAGE=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${kv;hide:"p PK"} ${kv;hide:"pc light-red"} $TARGET && $YMAKE_PYTHON ${input:"build/scripts/copy_to_dir.py"} --dest-dir $BINDIR --build-root $ARCADIA_BUILD_ROOT $PACKED_PACKAGE_ARGS $SRCS_GLOBAL $PEERS
TOUCH_PACKAGE_MF=$GENERATE_MF && $TOUCH_PACKAGE
TOUCH_JAVA_UNIT=$YMAKE_PYTHON ${input:"build/scripts/touch.py"} ${kv;hide:"java $CURDIR"} $TARGET

NO_CHECK_IMPORTS_FOR_VALUE=None
when ($SANITIZER_TYPE && $SANITIZER_TYPE == "pg") {
    NO_CHECK_IMPORTS_FOR_VALUE=""
}

### @usage: NO_CHECK_IMPORTS([patterns])
###
### Do not run checks on imports of Python modules.
### Optional parameter mask patterns describes the names of the modules that do not need to check.
macro NO_CHECK_IMPORTS(Masks...) {
    SET(NO_CHECK_IMPORTS_FOR_VALUE $Masks)
}


### @usage: PY_CODENAV(Program) # deprecated
###
### Collect codenavigation information from Program (specified as Program's module directory) and write it as Program.xref file
### Most probably you'll never need this. If you think you need, please contact devtools@ for assistance.
macro PY_CODENAV(For) {
    .CMD=${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/py_codenav.py"} --tool ${tool:"devtools/codenav/python/pyxref"} --out ${output:For.xref} --binary ${tool:For} ${kv;hide:"p CN"} ${kv;hide:"pc yellow"}
}

YASM_FLAGS=
when ($ASM_PREFIX) {
    ASM_PREFIX_VALUE=--prefix=$ASM_PREFIX
}
otherwise {
    ASM_PREFIX_VALUE=
}
YASM_PREINCLUDES_VALUE=
PREINCLUDES_KEY=
when ($YASM_PREINCLUDES_VALUE) {
    PREINCLUDES_KEY=PREINCLUDES
}
macro _SRC_yasm(SRC, SRCFLAGS...) {
    .CMD=$_SRC_yasm_impl($SRC $SRCFLAGS $PREINCLUDES_KEY $YASM_PREINCLUDES_VALUE)
}

### @usage: ASM_PREINCLUDE(AsmFiles...)
###
### Supply additional .asm files to all assembler calls within a module
macro ASM_PREINCLUDE(PREINCLUDES...) {
    SET_APPEND(YASM_PREINCLUDES_VALUE $PREINCLUDES)
}

### @usage: RUN_PYTHON(Args...)
###
### Version of RUN() macro to invoke Python scripts
### @see: [RUN()](#macro_RUN)
macro RUN_PYTHON(Args...) {
    SETUP_RUN_PYTHON()
    RUN(${PYTHON_BIN} $Args)
}

MAPKIT_IDL_INCLUDES=
macro MAPKIT_ADDINCL(Dirs...) {
    ADDINCL($Dirs)
    SET_APPEND(MAPKIT_IDL_INCLUDES $Dirs)
}

### @usage: MAPSMOBI_SRCS(filenames...)
###
### Make all source files listed as GLOBAL or not (depending on the value of
### MAPSMOBI_USE_SRCS_GLOBAL). Be careful since the value of
### MAPSMOBI_USE_SRCS_GLOBAL matters! If the value of this variable is equal to
### GLOBAL then call to MAPSMOBI_SRCS() macro behaves like call to
### GLOBAL_SRCS() macro otherwise the value of MAPSMOBI_USE_SRCS_GLOBAL is
### treated as a file name and a call to MAPSMOBI_SRCS() macro behaves like a
### call to SRCS() macro with additional iargument which is the value of
### MAPSMOBI_USE_SRCS_GLOBAL variable
macro MAPSMOBI_SRCS(FILES...) {
    ALL_SRCS(${MAPSMOBI_USE_SRCS_GLOBAL} $FILES)
}

### @usage: EXPORT_MAPKIT_PROTO() # internal deprecated
### This macro is a temporary one and should be changed to EXPORT_YMAPS_PROTO
### when transition of mapsmobi to arcadia is finished
macro EXPORT_MAPKIT_PROTO() {
    __proto_root=maps/mapsmobi/external/proto
    SET(PROTO_NAMESPACE $__proto_root)
    ADDINCL(${__proto_root} GLOBAL ${ARCADIA_BUILD_ROOT}/${__proto_root})
}

START_WHOLE_ARCHIVE=
END_WHOLE_ARCHIVE=
when ($MAPKIT_WHOLE_ARCHIVE == "yes") {
    START_WHOLE_ARCHIVE=$START_WHOLE_ARCHIVE_VALUE
    END_WHOLE_ARCHIVE=$END_WHOLE_ARCHIVE_VALUE
}

### @usage: MAPKIT_ENABLE_WHOLE_ARCHIVE() # internal deprecated
### This macro is a temporary one. Its use is allowed in maps/mapsmobi dir only.
macro MAPKIT_ENABLE_WHOLE_ARCHIVE() {
    ENABLE(MAPKIT_WHOLE_ARCHIVE)
}

ANDROID_SDK_ROOT=${ANDROID_SDK_RESOURCE_GLOBAL}/android_sdk

macro TASKLET() {
    PEERDIR(tasklet/api)

    # CPP
    SET_APPEND(CPP_PROTO_OPTS $_PROTO_PLUGIN_ARGS_BASE(tasklet_cpp tasklet/gen/cpp))
    SET_APPEND(PROTO_HEADER_INCLUDE tasklet/runtime/cpp/execute.h)

    # Python
    SET_APPEND(PY_PROTO_OPTS $_PROTO_PLUGIN_ARGS_BASE(tasklet_py tasklet/gen/python))
    _ADD_PY_PROTO_OUT(_tasklet.py)
    # XXX fix variable expansion in plugins
    SET(PY_PROTO_DEPS $PY_PROTO_DEPS tasklet/runtime)
}

TASKLET_REG_INCLUDES= \
    ${output_include;hide:"tasklet/runtime/lib/cpp_wrapper.h"} \
    ${output_include;hide:"tasklet/runtime/lib/python_wrapper.h"} \
    ${output_include;hide:"tasklet/runtime/lib/registry.h"}

macro TASKLET_REG(Name, Lang, Impl, Includes...) {
    PEERDIR(tasklet/runtime/lib)

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_tasklet_reg.py"} $Name --$Lang $Impl ${output;noauto:Name.task.cpp} $Includes ${output_include;hide:Includes} $TASKLET_REG_INCLUDES ${kv;hide:"p TL"} ${kv;hide:"pc yellow"}
    SRCS(GLOBAL $Name.task.cpp)
}

### @usage: PROTO_LIBRARY()
###
### Definition of multimodule that builds various variants of libraries.
### The particular variant is selected based on where PEERDIR to PROTO_LIBRARY comes from.
### Now supported 5 variants: C++, Java, Python 2.x, Python 3.x and Go
### Python versions emit C++ code in addition to Python as optimization
### PROTO_LIBRARY also supports emission of GRPC code if GRPC() macro is specified.
### Documentation: https://wiki.yandex-team.ru/yatool/proto_library/
### See: [GRPC()](#macro_GRPC), [OPTIMIZE_PY_PROTOS()](#macro_OPTIMIZE_PY_PROTOS)
multimodule PROTO_LIBRARY {
    module CPP_PROTO : LIBRARY {
        SET(PEERDIR_TAGS CPP_PROTO)
    }

    module JAVA_PROTO: _JAVA_LIBRARY {
        .EXTS=.jsrc
        .ALLOWED=GRPC
        SET(PEERDIR_TAGS JAVA_PROTO)
        PEERDIR($JAVA_PROTOBUF)
        PEERDIR(contrib/java/javax/annotation/javax.annotation-api/1.3.1)
        when ($GRPC_FLAG == "yes") {
            PEERDIR+=$JAVA_GRPC_STUB $JAVA_GRPC_PROTOBUF
        }
        .IGNORED=GENERATE_ENUM_SERIALIZATION GENERATE_ENUM_SERIALIZATION_WITH_HEADER
    }

    module PY_PROTO: PY_LIBRARY {
        .ALIASES=SRCS=PY_SRCS
        SET(PEERDIR_TAGS PY2 PY_PROTO)
        OBJ_SUF=.py2
        NO_LINT()
    }

    module PY3_PROTO: PY3_LIBRARY {
        .ALIASES=SRCS=PY_SRCS
        SET(PEERDIR_TAGS PY3 PY3_PROTO)
        when ($MSVC == "yes" || $CYGWIN == "yes") {
            MODULE_PREFIX=py3
        }
        otherwise {
             MODULE_PREFIX=libpy3
        }
        OBJ_SUF=.py3
        NO_LINT()
    }

    module GO_PROTO: GO_LIBRARY {
        .INCLUDE_TAG=no
        SET(PEERDIR_TAGS GO GO_PROTO)
        ENABLE(GO_PROTO)
    }
}

GO_HOST_OS=unknown
when ($HOST_OS_LINUX) {
    GO_HOST_OS=linux
}
elsewhen ($HOST_OS_DARWIN) {
    GO_HOST_OS=darwin
}
elsewhen($HOST_OS_WINDOWS) {
    GO_HOST_OS=windows
}

GO_HOST_ARCH=unknown
when ($HOST_ARCH_X86_64) {
    GO_HOST_ARCH=amd64
}

GO_TARG_OS=unknown
when ($OS_LINUX) {
    GO_TARG_OS=linux
}
elsewhen ($OS_DARWIN) {
    GO_TARG_OS=darwin
}
elsewhen ($OS_WINDOWS) {
    GO_TARG_OS=windows
}

GO_TARG_ARCH=unknwon
when ($ARCH_X86_64) {
    GO_TARG_ARCH=amd64
}
elsewhen ($ARCH_I386) {
    GO_TARG_ARCH=x86
}

GO_HOST_TARG_PARAMS=++host-os $GO_HOST_OS ++host-arch $GO_HOST_ARCH ++targ-os $GO_TARG_OS ++targ-arch $GO_TARG_ARCH

GOSTD_VERSION=1.12.4
when ($GOSTD_VERSION == "1.12.1") {
    GOSTD=contrib/go/_std_1.12.1/src
}
elsewhen ($GOSTD_VERSION == "1.12.4") {
    GOSTD=contrib/go/_std_1.12.4/src
}
otherwise {
    GOSTD=__unsupported_go_std_library_version__
}
GO_TOOLS_ROOT_UNQUOTED=${GO_TOOLS_RESOURCE_GLOBAL}
GO_TOOLS_ROOT=${quo:GO_TOOLS_ROOT_UNQUOTED}
GO_TEST_MINER=${tool:"tools/go_test_miner"}
GO_TEST_IMPORT_PATH=

GO_STD_LIB_PREFIX=${GOSTD}/
GO_ARCADIA_PROJECT_PREFIX=a.yandex-team.ru/
GO_CONTRIB_PROJECT_PREFIX=vendor/
GO_SKIP_IMPORTS=unsafe C

GO_PROJECT_PREFIXES=++std-lib-prefix $GO_STD_LIB_PREFIX ++arc-project-prefix $GO_ARCADIA_PROJECT_PREFIX

GO_FAKEID=${FAKEID}

CGO2_LDFLAGS=

GO_ASM_FLAGS_VALUE=
### @usage: GO_ASM_FLAGS(flags)
### Add the specified flags to the go asm compile icommand line.
macro GO_ASM_FLAGS(Flags...) {
    SET_APPEND(GO_ASM_FLAGS_VALUE $Flags)
}

GO_CGO1_FLAGS_VALUE=
### @usage: GO_CGO1_FLAGS(flags)
### Add the specified flags to the go cgo compile command line.
macro GO_CGO1_FLAGS(Flags...) {
    SET_APPEND(GO_CGO1_FLAGS_VALUE $Flags)
}

GO_CGO2_FLAGS_VALUE=
### @usage: GO_CGO2_FLAGS(flags)
### Add the specified flags to the go cgo compile command line.
macro GO_CGO2_FLAGS(Flags...) {
    SET_APPEND(GO_CGO2_FLAGS_VALUE $Flags)
}

GO_COMPILE_FLAGS_VALUE=
### @usage: GO_COMPILE_FLAGS(flags)
### Add the specified flags to the go compile command line.
macro GO_COMPILE_FLAGS(Flags...) {
    SET_APPEND(GO_COMPILE_FLAGS_VALUE $Flags)
}

GO_LINK_FLAGS_VALUE=
### @usage: GO_LINK_FLAGS(flags)
### Add the specified flags to the go link command line.
macro GO_LINK_FLAGS(Flags...) {
    SET_APPEND(GO_LINK_FLAGS_VALUE $Flags)
}

GO_TOOL_COMMON_FLAGS=\
    $GO_PROJECT_PREFIXES \
    ++goversion $GOSTD_VERSION \
    ++build-root $ARCADIA_BUILD_ROOT \
    ++output-root $BINDIR \
    ++tools-root ${GO_TOOLS_ROOT} \
    $GO_HOST_TARG_PARAMS \
    ++output $TARGET \
    ++srcs $AUTO_INPUT ${input:GO_FILES} \
    ++asm-flags $GO_ASM_FLAGS_VALUE \
    ++compile-flags $GO_COMPILE_FLAGS_VALUE \
    ++link-flags $GO_LINK_FLAGS_VALUE \
    $GO_TOOLCHAIN_ENV

macro _GO_COMPILE_SYMABIS(ASM_FILES...) {
    .CMD=${hide:GO_FAKEID} $GO_TOOLS_ROOT/pkg/tool/${GO_HOST_OS}_${GO_HOST_ARCH}/asm -trimpath $ARCADIA_BUILD_ROOT ${hide;input:"build/scripts/go_fake_include/go_asm.h"} -I $ARCADIA_ROOT/build/scripts/go_fake_include -I $GO_TOOLS_ROOT/pkg/include -D GOOS_${GO_TARG_OS} -D GOARCH_${GO_TARG_ARCH} -gensymabis -o ${output:"gen.symabis"} ${input:ASM_FILES} ${kv;hide:"p go"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"}
}

macro _GO_COMPILE_CGO1(NAME, FLAGS[], FILES...) {
    .CMD=${hide:GO_FAKEID} ${GO_TOOLS_ROOT}/pkg/tool/${GO_HOST_OS}_${GO_HOST_ARCH}/cgo -objdir $BINDIR -importpath $NAME $GO_CGO1_FLAGS_VALUE $FLAGS -- $C_FLAGS_PLATFORM ${pre=-I:INCLUDE} ${CGO_CFLAGS_VALUE} ${input:FILES} ${output;hide:"_cgo_export.h"} ${output;hide:"_cgo_export.c"} ${output;hide:"_cgo_gotypes.go"} ${output;noauto;hide:"_cgo_main.c"} ${output;hide;rootrel;nopath;noext:FILES.cgo1.go} ${output;hide;rootrel;nopath;noext:FILES.cgo2.c} ${output;noauto;hide:"_cgo_flags"} $GO_TOOLCHAIN_ENV ${kv;hide:"p go"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"}
}

macro _GO_COMPILE_CGO2(NAME, C_FILES[], S_FILES[], FILES...) {
    .CMD=${hide:GO_FAKEID} $GCCFILTER $C_COMPILER $C_FLAGS_PLATFORM ${pre=-I:INCLUDE} $CGO_CFLAGS_VALUE ${input;tobindir:"_cgo_main.c"} -c -o ${tmp;noauto;suf=${OBJECT_SUF}:"_cgo_main.c"} && $GCCFILTER $C_COMPILER $C_FLAGS_PLATFORM ${pre=-I:INCLUDE} $CGO_CFLAGS_VALUE -o ${tmp;noauto;suf=${OBJECT_SUF}:"_cgo_"} $CGO2_LDFLAGS ${input;hide:"_cgo_export.h"} ${tmp;noauto;suf=${OBJECT_SUF}:"_cgo_main.c"} ${input;suf=${OBJECT_SUF}:"_cgo_export.c"} ${input;nopath;noext;suf=${OBJECT_SUF}:FILES.cgo2.c} ${input;suf=${OBJECT_SUF}:C_FILES} ${input;suf=.o:S_FILES} $CGO_LDFLAGS_VALUE && ${GO_TOOLS_ROOT}/pkg/tool/${GO_HOST_OS}_${GO_HOST_ARCH}/cgo -dynpackage $NAME -dynimport ${tmp;noauto;suf=${OBJECT_SUF}:"_cgo_"} -dynout ${output:"_cgo_import.go"} -dynlinker $GO_CGO2_FLAGS_VALUE $GO_TOOLCHAIN_ENV ${kv;hide:"p go"} ${kv;hide:"pc light-blue"} ${kv;hide:"show_out"}
}

macro _GO_LINK_LIB_IMPL(GO_FILES...) {
    .CMD=${hide:GO_FAKEID} $YMAKE_PYTHON ${input:"build/scripts/go_tool.py"} $GO_TOOL_COMMON_FLAGS ++mode lib ++peers ${rootrel;tags_in=local,GO|local,GO_PROTO:PEERS} ${kv;hide:"p GO"} ${kv;hide:"pc light-red"} ${kv;hide:"show_out"}
}

macro _GO_LINK_EXE_IMPL(GO_FILES...) {
    .CMD=${hide:GO_FAKEID} $YMAKE_PYTHON ${input:"build/scripts/go_tool.py"} $GO_TOOL_COMMON_FLAGS ++mode exe $GO_EXTLD ++peers ${rootrel;tags_in=GO|GO_PROTO:PEERS} ++cgo-peers ${rootrel;tags_out=GO|GO_PROTO:PEERS} ${kv;hide:"p LD"} ${kv;hide:"pc light-red"} ${kv;hide:"show_out"}
}

macro _GO_LINK_TEST_IMPL(GO_TEST_FILES[], GO_XTEST_FILES[], GO_FILES...) {
    .CMD=${hide:GO_FAKEID} $YMAKE_PYTHON ${input:"build/scripts/go_tool.py"} $GO_TOOL_COMMON_FLAGS ++mode test $GO_EXTLD ++test-miner $GO_TEST_MINER ++test-import-path $GO_TEST_IMPORT_PATH ++peers ${rootrel;tags_in=GO|GO_PROTO:PEERS} ++cgo-peers ${rootrel;tags_out=GO|GO_PROTO:PEERS} ++test_srcs ${input:GO_TEST_FILES} ++xtest_srcs ${input:GO_XTEST_FILES} ${kv;hide:"p GO"} ${kv;hide:"pc light-red"} ${kv;hide:"show_out"}
}

GO_LINK_LIB=$GENERATE_MF && $_GO_LINK_LIB_IMPL($GO_SRCS_VALUE)
GO_LINK_EXE=$GENERATE_MF && $_GO_LINK_EXE_IMPL($GO_SRCS_VALUE)
GO_LINK_TEST=$_GO_LINK_TEST_IMPL($GO_SRCS_VALUE GO_TEST_FILES $GO_TEST_SRCS_VALUE GO_XTEST_FILES $GO_XTEST_SRCS_VALUE)

CGO_ENABLED=yes

when ($OS_WINDOWS == "yes" || $SANITIZER_TYPE && $SANITIZER_TYPE != "no") {
    CGO_ENABLED=no
}

GO_PACKAGE_VALUE=
### @usage: GO_PACKAGE_NAME(Name)
### Override name of a Go package.
macro GO_PACKAGE_NAME(NAME) {
    SET(GO_PACKAGE_VALUE $NAME)
}

GO_SRCS_VALUE=
### @usage: GO_SRCS(Files...) # internal
### This macro shouldn't be used in ya.make files, use SRCS() instead.
### This is internal macro collecting .go sources for processing within Go modules (GO_PROGRAM and GO_LIBRARY)
macro GO_SRCS(FILES...) {
    GO_FAKE_OUTPUT($FILES)
    SET_APPEND(GO_SRCS_VALUE $FILES)
}

GO_TEST_SRCS_VALUE=
### @usage: GO_TEST_SRCS(Files...)
### .go sources for internal tests of a module
macro GO_TEST_SRCS(FILES...) {
    GO_FAKE_OUTPUT($FILES)
    SET_APPEND(GO_TEST_SRCS_VALUE $FILES)
}

GO_XTEST_SRCS_VALUE=
### @usage: GO_XTEST_SRCS(Files...)
### .go sources for external tests of a module
macro GO_XTEST_SRCS(FILES...) {
    GO_FAKE_OUTPUT($FILES)
    SET_APPEND(GO_XTEST_SRCS_VALUE $FILES)
}

macro _GO_UNUSED_SRCS(FLAGS...) {
    ENABLE(UNUSED_MACRO)
}

CGO_SRCS_VALUE=
### @usage: CGO_SRCS(Files...)
### .go sources to be built with CGO
macro CGO_SRCS(FILES...) {
    SET_APPEND(CGO_SRCS_VALUE $FILES)
    PEERDIR(${GOSTD}/syscall)
}

GO_LDFLAGS_GLOBAL=
### @usage: GO_LDFLAGS(Flags...)
### Link flags for GO_PROGRAM linking from .go sources
macro GO_LDFLAGS(FLAGS...) {
    SET_APPEND(GO_LDFLAGS_GLOBAL $FLAGS)
}

CGO_CFLAGS_VALUE=
### @usage: CGO_CFLAGS(Flags...)
### Compiler flags specific to CGO compilation
macro CGO_CFLAGS(FLAGS...) {
    SET_APPEND(CGO_CFLAGS_VALUE $FLAGS)
    CFLAGS($FLAGS)
}

CGO_LDFLAGS_VALUE=
### @usage: CGO_LDFLAGS(Files...)
### Linker flags specific to CGO linking
macro CGO_LDFLAGS(FLAGS...) {
    SET_APPEND(CGO_LDFLAGS_VALUE $FLAGS)
    GO_LDFLAGS($FLAGS)
}


GO_TOOLCHAIN_ENV=$TOOLCHAIN_ENV

macro _GO_GRPC() {
    SET(GO_PROTOC_GEN_PLUGINS Plugins plugins=grpc:)
    PEERDIR(${GOSTD}/context vendor/google.golang.org/grpc)
}

macro _GO_YDB_GRPC(Plugins...) {
    SET(GO_PROTOC_GEN_TOOL rtc/mediator/ydb-go/internal/cmd/protoc-gen)
    SET(GO_PROTOC_GEN_PLUGINS Plugins plugins=ydb+grpc:)
    PEERDIR(${GOSTD}/context vendor/google.golang.org/grpc)
}

module _GO_BASE_UNIT: _BASE_UNIT {
    .EXTS=.go .o .obj .a .symabis .mf
    .CMD=TOUCH_UNIT
    .NODE_TYPE=Bundle
    .GLOBAL=GO_LDFLAGS
    .PEERDIR_POLICY=as_build_from
    .ALIASES=SRCS=GO_SRCS GO_TEST_SRCS=_GO_UNUSED_SRCS GO_XTEST_SRCS=_GO_UNUSED_SRCS GRPC=_GO_GRPC YDB_GRPC=_GO_YDB_GRPC CFLAGS=CGO_CFLAGS

    NO_UTIL()
    NO_RUNTIME()

    SET(MODULE_TAG GO)
    PEERDIR_TAGS=GO GO_PROTO __EMPTY__

    DEFAULT(ALLOCATOR $DEFAULT_ALLOCATOR)

    PEERDIR(build/external_resources/go_tools)

    when ($COMPILER_PLATFORM && $NEED_PLATFORM_PEERDIRS == "yes") {
        PEERDIR+=$COMPILER_PLATFORM
    }

    GO_TOOLCHAIN_ENV += ${env:"GOARCH=amd64"}

    when ($OS_DARWIN) {
        GO_TOOLCHAIN_ENV += ${env:"GOOS=darwin"}
    }
    elsewhen ($OS_LINUX) {
        GO_TOOLCHAIN_ENV += ${env:"GOOS=linux"}
    }
    elsewhen ($OS_WINDOWS) {
        GO_TOOLCHAIN_ENV += ${env:"GOOS=windows"}
    }

    when ($CLANG == "yes" || $GCC == "yes") {
        CGO_CFLAGS_VALUE += -w -pthread -fpic
    }

    _GO_PROCESS_SRCS()

    when ($OS_DARWIN) {
        GO_TOOLCHAIN_ENV += ${env:"CC=clang"} ${env:"PATH=$(DEFAULT_DARWIN_X86_64)/bin:$MACOS_SDK_RESOURCE_GLOBAL/usr/bin:$CCTOOLS_ROOT_RESOURCE_GLOBAL/bin"}
        GO_EXTLD = ++extld clang ++extldflags $LD_SDK_VERSION -undefined dynamic_lookup $C_FLAGS_PLATFORM --sysroot=$MACOS_SDK_RESOURCE_GLOBAL $LDFLAGS $LDFLAGS_GLOBAL $GO_LDFLAGS_GLOBAL $C_LIBRARY_PATH $C_SYSTEM_LIBRARIES_INTERCEPT $C_SYSTEM_LIBRARIES
        CGO2_LDFLAGS += $LD_SDK_VERSION -undefined dynamic_lookup
    }
    elsewhen ($OS_LINUX) {
        GO_TOOLCHAIN_ENV += ${env:"CC=clang"} ${env:"PATH=$(DEFAULT_LINUX_X86_64)/bin:$OS_SDK_ROOT_RESOURCE_GLOBAL/usr/bin"}
        GO_EXTLD = ++extld clang ++extldflags $C_FLAGS_PLATFORM --sysroot=$OS_SDK_ROOT_RESOURCE_GLOBAL $LDFLAGS $LDFLAGS_GLOBAL $GO_LDFLAGS_GLOBAL $C_LIBRARY_PATH $C_SYSTEM_LIBRARIES_INTERCEPT $C_SYSTEM_LIBRARIES
        CGO2_LDFLAGS += -Wl,--unresolved-symbols=ignore-all
    }
    otherwise {
        GO_EXTLD = ++extld gcc
    }
}

### @usage: GO_LIBRARY([name])
###
### Go library module definition.
### Compile Go module as a library suitable for PEERDIR from other Go modules
### Will select Go implementation on PEERDIR to PROTO_LIBRARY
module GO_LIBRARY: _GO_BASE_UNIT {
    .CMD=GO_LINK_LIB
    .NODE_TYPE=Bundle
    .FINAL_TARGET=no
    SET(MODULE_TYPE LIBRARY)

    MODULE_SUFFIX=.a
}

### @usage: GO_PROGRAM([name])
###
### Go program module definition
### Compile and link Go module as an executable program
### Will select Go implementation on PEERDIR to PROTO_LIBRARY
module GO_PROGRAM: _GO_BASE_UNIT {
    .CMD=GO_LINK_EXE
    .NODE_TYPE=Bundle
    .SYMLINK_POLICY=EXE
    .FINAL_TARGET=yes
    SET(MODULE_TYPE PROGRAM)

    _USE_LINKER()

    when ($MUSL == "yes") {
        PEERDIR += contrib/libs/musl-1.1.20/full
    }

    when ($USE_ARCADIA_LIBM == "yes") {
        PEERDIR+=contrib/libs/libm
    }
    when ($USE_ARCADIA_LIBM == "no") {
        C_SYSTEM_LIBRARIES+=-lm
    }

    when ($MSVC == "yes" || $CYGWIN == "yes") {
        MODULE_SUFFIX=.exe
    }

    PEERDIR(${GOSTD}/runtime)
}

### @usage: GO_TEST([name])
###
### Go test module definition
### Compile and link Go module as a test suitable for running with Arcadia testing support
### All usual testing support macros like DATA, DEPENDS, SIZE, REQUIREMENTS etc. are supported
### Will select Go implementation on PEERDIR to PROTO_LIBRARY
module GO_TEST: GO_PROGRAM {
    .CMD=GO_LINK_TEST
    .ALIASES=GO_TEST_SRCS=GO_TEST_SRCS GO_XTEST_SRCS=GO_XTEST_SRCS
    .FINAL_TARGET=no
    SET(MODULE_TYPE PROGRAM)

    PEERDIR(${GOSTD}/testing/internal/testdeps)
    PEERDIR(${GOSTD}/testing)

    ADD_YTEST($REALPRJNAME go.test)
}

JAVA_IGNORE_CLASSPATH_CLASH_VALUE=
### @usage: JAVA_IGNORE_CLASSPATH_CLASH_FOR([classes])
### Ignore classpath clash test fails for classes
macro JAVA_IGNORE_CLASSPATH_CLASH_FOR(Args...) {
    SET_APPEND(JAVA_IGNORE_CLASSPATH_CLASH_VALUE $Args)
}


### @usage: PY_SRCS({| CYTHON_C} { | TOP_LEVEL | NAMESPACE ns} Files...)
###
### PY_SRCS() - is rule to build extended versions of Python interpreters and containing all application code in its executable file. It can be used to collect only the executables but not shared libraries, and, in particular, not to collect the modules that are imported using import directive.
### The main disadvantage is the lack of IDE support; There is also no readline yet.
### The application can be collect from any of the sources from which the C library, and with the help of PY_SRCS .py , .pyx,.proto and .swg files.
### At the same time extensions for Python on C language generating from .pyx and .swg, will be registered in Python's as built-in modules, and sources on .py are stored as static data: when the interpreter starts, the initialization code will add a custom loader of these modules to sys.meta_path.
### By default .pyx files are collected as C++-extensions. To collect them as C (similar to BUILDWITH_CYTHON_C, but with the ability to specify namespace), you must specify the Directive CYTHON_C.
### Building with pyx automatically registers modules, you do not need to call PY_REGISTER for them
### __init__.py never required, but if present (and specified in PY_SRCS), it will be imported when you import package modules with __init__.py Oh.
###
### Example of library declaration with PY_SRCS():
### ```
### PY_LIBRARY(mymodule)
### PY_SRCS(a.py sub/dir/b.py e.proto sub/dir/f.proto c.pyx sub/dir/d.pyx g.swg sub/dir/h.swg)
### END()
### ```
### PY_REGISTER honors Python2 and Python3 differences and adjusts itself to Python version of a current module
### Documentation: https://wiki.yandex-team.ru/arcadia/python/pysrcs/#modulipylibrarypy3libraryimakrospysrcs
macro PY_SRCS() {
    DEFAULT(MODULE_TAG PY2)
    DEFAULT(PYTHON2 yes)
    DEFAULT(PYTHON3 no)
}

### @usage: PY23_LIBRARY([name])
### Build PY_LIBRARY or PY3_LIBRARY depending on incoming PEERDIR
### Direct build or build by RECURSE creates both variants
### For more information read https://wiki.yandex-team.ru/arcadia/python/pysrcs
multimodule PY23_LIBRARY {
    module PY2: PY_LIBRARY {
        OBJ_SUF=.py2
    }
    module PY3: PY3_LIBRARY {
        when ($MSVC == "yes" || $CYGWIN == "yes") {
            MODULE_PREFIX=py3
        }
        otherwise {
             MODULE_PREFIX=libpy3
        }
        OBJ_SUF=.py3
    }
}

### @usage: PY23_NATIVE_LIBRARY([name])
###
### Build LIBRARY compatible with either Puthon 2.x or Python 3.x depending on incoming PEERDIR.
### This multimodule doesn't depend on Arcadia Python binary build. It is intended only for C++ code and cannot contain PY_SRCS and USE_PYTHON macros.
### This is needed to steer proper headers selection in PYMODULE builds.
### For more information read https://wiki.yandex-team.ru/arcadia/python/pysrcs/#pysrcssrcsipy23nativelibrary
multimodule PY23_NATIVE_LIBRARY {
    module PY2: LIBRARY {
        .RESTRICTED=PY_SRCS USE_PYTHON USE_PYTHON3
        OBJ_SUF=.py2
        PYTHON_ADDINCL()
    }
    module PY3: LIBRARY {
        .RESTRICTED=PY_SRCS USE_PYTHON USE_PYTHON3
        .ALIASES=PYTHON_ADDINCL=PYTHON3_ADDINCL
        PYTHON3_ADDINCL()
        when ($MSVC == "yes" || $CYGWIN == "yes") {
            MODULE_PREFIX=py3c
        }
        otherwise {
            MODULE_PREFIX=libpy3c
        }
        OBJ_SUF=.py3
    }
}

STORYBOARD_FLAGS=--errors --warnings --notices --auto-activate-custom-fonts --output-format human-readable-text
macro _SRC("storyboard", SRC, SRCFLAGS...) {
    .CMD=$XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/ibtool $STORYBOARD_FLAGS --module $REALPRJNAME --output-partial-info-plist ${output;suf=.partial_plist:SRC} --compilation-directory $BINDIR ${input:SRC} && $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"}  ${output;tobindir;suf=.compiled_storyboard_tar:SRC} $BINDIR/${nopath;suf=c:SRC} $BINDIR/${nopath;suf=c:SRC}
}

macro _SRC("xib", SRC, SRCFLAGS...) {
    .CMD=$XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/ibtool $STORYBOARD_FLAGS --module $REALPRJNAME --output-partial-info-plist ${output;suf=.partial_plist:SRC} --compile ${output;tobindir;nopath;noext;suf=.nib:SRC} ${input:SRC}
}

ASSETS_FLAGS=--output-format human-readable-text --notices --warnings
macro _IOS_ASSETS(AssetsDir, Content...) {
    .CMD=$FS_TOOLS md $BINDIR/$REALPRJNAME && $XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode/Contents/Developer/usr/bin/actool $ASSETS_FLAGS --export-dependency-info $BINDIR/assetcatalog_dependencies --output-partial-info-plist ${output:"assetcatalog_generated_info.partial_plist"} --product-type com.apple.product-type.application --compile $BINDIR/$REALPRJNAME $AssetsDir ${input;hide:Content} && ${cwd:BINDIR} $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"} ${output;suf=_assetes.resource_tar:REALPRJNAME} $REALPRJNAME $REALPRJNAME
}

macro IOS_APP_COMMON_FLAGS(Flags...) {
    SET_APPEND(STORYBOARD_FLAGS $Flags)
    SET_APPEND(ASSETS_FLAGS $Flags)
}

macro IOS_APP_ASSETS_FLAGS(Flags...) {
    SET_APPEND(ASSETS_FLAGS $Flags)
}

macro DARWIN_STRINGS_RESOURCE(Resource, Relpath) {
    .CMD=$COPY_CMD ${input:Resource} $BINDIR/$Relpath && $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"} ${output;tobindir;suf=.strings_tar:Relpath} $BINDIR/$Relpath $BINDIR
}

macro DARWIN_SIGNED_RESOURCE(Resource, Relpath) {
    .CMD=$COPY_CMD $Resource $BINDIR/$Relpath && $YMAKE_PYTHON ${input:"build/scripts/tar_directory.py"} ${output;tobindir;suf=.signed_resource_tar:Relpath} $BINDIR/$Relpath $BINDIR
}

DELIM=__DELIM__
PACK_IOS_ARCHIVE=$YMAKE_PYTHON ${input:"build/scripts/ios_wrapper.py"} $XCODE_TOOLS_ROOT_RESOURCE_GLOBAL/Xcode $TARGET $REALPRJNAME $BINDIR $DELIM $AUTO_INPUT $DELIM $PEERS $DELIM $STORYBOARD_FLAGS
### @usage: IOS_APP()
### iOS application module definition
module IOS_APP: _BASE_UNIT {
    .CMD=PACK_IOS_ARCHIVE
    .EXTS=.compiled_storyboard_tar .partial_plist .plist .xcent .nib .resource_tar .signed_resource_tar .strings_tar .plist_json
    .PEERDIR_POLICY=as_build_from
    .FINAL_TARGET=yes
    NO_PLATFORM()
    SET(NEED_PLATFORM_PEERDIRS no)
    SET(MODULE_SUFFIX .tar)

    PEERDIR+=build/platform/xcode/tools
}

JDK_VERSION=11
when ($JDK_VERSION == "10") {
    JDK10=yes # remove this later
}

ERROR_PRONE_VERSION=
when (!$ERROR_PRONE_VERSION) {
    when ($JDK_VERSION == "8" || $JDK_VERSION == "10") {
        ERROR_PRONE_VERSION=2.3.1
    }
    otherwise {
        ERROR_PRONE_VERSION=2.3.3
    }
}


# local jdk and tools
USE_SYSTEM_JDK=
USE_SYSTEM_UBERJAR=
USE_SYSTEM_ERROR_PRONE=

CPP_XCODE_TOOLCHAIN_VERSION=9.2
SWIFT_XCODE_TOOLCHAIN_VERSION=9.2
XCODE_TOOLS_VERSION=10.1
macro COMPILE_SWIFT_MODULE(SRCS{input}[], BRIDGE_HEADER{input}="", Flags...) {
    when ($BRIDGE_HEADER != "") {
        SWIFT_BRIDGE_HEADER=-import-objc-header ${input:BRIDGE_HEADER}
    }
    otherwise {
        SWIFT_BRIDGE_HEADER=
    }

    .PEERDIR+=build/platform/xcode/swift
    # swift core libraries
    LDFLAGS($SWIFT_LD_FLAGS)

    .CMD=$YMAKE_PYTHON ${input:"build/scripts/gen_swiftc_output_map.py"} $(SOURCE_ROOT) $(BUILD_ROOT) $BINDIR/swift_output_map.json ${input:SRCS} && $SWIFT_COMPILER -c $SWIFT_FLAGS_PLATFORM $Flags $SWIFT_BRIDGE_HEADER ${pre=-Xcc -I:INCLUDE} ${input:SRCS} -emit-objc-header -emit-objc-header-path ${output;suf=-Swift.h:REALPRJNAME} -emit-module -module-name $REALPRJNAME -output-file-map $BINDIR/swift_output_map.json ${output;hide;suf=.o:SRCS}
}

TEST_TOOL_HOST_LOCAL=
TEST_TOOL_TARGET_LOCAL=
