! Signatures for f2py wrappers of FORTRAN LAPACK functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! $Revision$ $Date$
!
! Additions by Travis Oliphant, Tiziano Zito, Collin RM Stocks, Fabian Pedregosa
!              Skipper Seabold, Ilhan Polat
!
! Shorthand Notations:
! --------------------
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
!

python module _flapack
    usercode '''
#define F_INT int
'''

interface

    ! Following classification is due to
    ! http://www.netlib.org/lapack/explore-html/

python module gees__user__routines 
    interface
        function sselect(arg1,arg2)
            real :: arg1,arg2
            logical :: sselect
        end function sselect

        function dselect(arg1,arg2)
            double precision :: arg1,arg2
            logical :: dselect
        end function dselect

        function cselect(arg)
            complex :: arg
            logical :: cselect
        end function cselect

        function zselect(arg)
            double complex :: arg
            logical :: zselect
        end function zselect


    end interface
end python module gees__user__routines

python module gges__user__routines 
    interface
        function cselect(alpha, beta)
            complex :: alpha, beta
            logical :: cselect
        end function cselect

        function zselect(alpha, beta)
            double complex :: alpha, beta
            logical :: zselect
        end function zselect


        function sselect(alphar, alphai, beta)
            real :: alphar, alphai, beta
            logical :: sselect
        end function sselect

        function dselect(alphar, alphai, beta)
            double precision :: alphar, alphai, beta
            logical :: dselect
        end function dselect


    end interface
end python module gges__user__routines
! Signatures for f2py-wrappers of FORTRAN LAPACK General Matrix functions.
!

subroutine sgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,F_INT*,float*,F_INT*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    real dimension(n),intent(out),depend(n) :: pivscale
    real dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info

end subroutine sgebal


subroutine dgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,F_INT*,double*,F_INT*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    double precision dimension(n),intent(out),depend(n) :: pivscale
    double precision dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info

end subroutine dgebal


subroutine cgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,float*,F_INT*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    real dimension(n),intent(out),depend(n) :: pivscale
    complex dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info

end subroutine cgebal


subroutine zgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,double*,F_INT*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    double precision dimension(n),intent(out),depend(n) :: pivscale
    double complex dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info

end subroutine zgebal



subroutine sgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    real dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    real dimension(n-1),intent(out),depend(n) :: tau
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info

end subroutine sgehrd


subroutine dgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double precision dimension(n-1),intent(out),depend(n) :: tau
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info

end subroutine dgehrd


subroutine cgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    complex dimension(n-1),intent(out),depend(n) :: tau
    complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info

end subroutine cgehrd


subroutine zgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double complex dimension(n-1),intent(out),depend(n) :: tau
    double complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info

end subroutine zgehrd



subroutine sgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname sgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*
    integer intent(in) :: n
    real intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine sgehrd_lwork


subroutine dgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname dgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*
    integer intent(in) :: n
    double precision intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine dgehrd_lwork


subroutine cgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname cgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*
    integer intent(in) :: n
    complex intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine cgehrd_lwork


subroutine zgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname zgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*
    integer intent(in) :: n
    double complex intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine zgehrd_lwork



subroutine sgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {F_INT i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    real dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine sgesv


subroutine dgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {F_INT i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    double precision dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine dgesv


subroutine cgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {F_INT i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    complex dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine cgesv


subroutine zgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {F_INT i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    double complex dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine zgesv



subroutine sgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, single and double reals (sgesvx and dgesvx)
    threadsafe
    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,char*,float*,float*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real optional,dimension(n,n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    real optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    real optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    real depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    real dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    real dimension(4*n),depend(n),intent(hide,cache):: work
    integer intent(hide,cache),dimension(n),depend(n) :: iwork
    integer intent(out):: info

end subroutine sgesvx


subroutine dgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, single and double reals (sgesvx and dgesvx)
    threadsafe
    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,char*,double*,double*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision optional,dimension(n,n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    double precision optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    double precision optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    double precision depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double precision dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double precision dimension(4*n),depend(n),intent(hide,cache):: work
    integer intent(hide,cache),dimension(n),depend(n) :: iwork
    integer intent(out):: info

end subroutine dgesvx



subroutine cgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, complex and double complex (cgesvx and zgesvx)
    threadsafe
    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,char*,float*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,float*,F_INT*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    complex optional,dimension(n,n),depend(n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    real optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    real optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    complex depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    complex dimension(2*n),depend(n),intent(hide,cache):: work
    real intent(hide,cache),dimension(2*n),depend(n) :: rwork
    integer intent(out):: info

end subroutine cgesvx


subroutine zgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, complex and double complex (cgesvx and zgesvx)
    threadsafe
    callstatement {F_INT i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,char*,double*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,double*,F_INT*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double complex optional,dimension(n,n),depend(n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    double precision optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    double precision optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    double complex depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double complex dimension(2*n),depend(n),intent(hide,cache):: work
    double precision intent(hide,cache),dimension(2*n),depend(n) :: rwork
    integer intent(out):: info

end subroutine zgesvx



subroutine sgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,float*,float*,float*,F_INT*,F_INT*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    real depend(n),dimension(4*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine sgecon


subroutine dgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,double*,double*,double*,F_INT*,F_INT*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double precision depend(n),dimension(4*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine dgecon


subroutine cgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,float*,float*,complex_float*,float*,F_INT*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    complex depend(n),dimension(2*n),intent(hide,cache):: work
    real depend(n),dimension(2*n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine cgecon


subroutine zgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,double*,double*,complex_double*,double*,F_INT*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double complex depend(n),dimension(2*n),intent(hide,cache):: work
    double precision depend(n),dimension(2*n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine zgecon



subroutine sgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine sgetrf


subroutine dgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine dgetrf


subroutine cgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine cgetrf


subroutine zgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine zgetrf



subroutine sgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    real dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine sgetrs


subroutine dgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    double precision dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine dgetrs


subroutine cgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine cgetrs


subroutine zgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    double complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine zgetrs



subroutine sgetc2(n,a,lda,ipiv,jpiv,info)
    ! lu,ipiv,jpiv,info = getc2(a,overwrite_a=0)
    ! Compute an LU factorization of with complete pivoting of a general n-by-n matrix.
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&n,a,&lda,ipiv,jpiv,&info);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),intent(in,out,copy,out=lu) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    integer dimension(n),depend(n),intent(out) :: ipiv
    integer dimension(n),depend(n),intent(out) :: jpiv
    integer intent(out):: info

end subroutine sgetc2


subroutine dgetc2(n,a,lda,ipiv,jpiv,info)
    ! lu,ipiv,jpiv,info = getc2(a,overwrite_a=0)
    ! Compute an LU factorization of with complete pivoting of a general n-by-n matrix.
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&n,a,&lda,ipiv,jpiv,&info);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),intent(in,out,copy,out=lu) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    integer dimension(n),depend(n),intent(out) :: ipiv
    integer dimension(n),depend(n),intent(out) :: jpiv
    integer intent(out):: info

end subroutine dgetc2


subroutine cgetc2(n,a,lda,ipiv,jpiv,info)
    ! lu,ipiv,jpiv,info = getc2(a,overwrite_a=0)
    ! Compute an LU factorization of with complete pivoting of a general n-by-n matrix.
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&n,a,&lda,ipiv,jpiv,&info);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),intent(in,out,copy,out=lu) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    integer dimension(n),depend(n),intent(out) :: ipiv
    integer dimension(n),depend(n),intent(out) :: jpiv
    integer intent(out):: info

end subroutine cgetc2


subroutine zgetc2(n,a,lda,ipiv,jpiv,info)
    ! lu,ipiv,jpiv,info = getc2(a,overwrite_a=0)
    ! Compute an LU factorization of with complete pivoting of a general n-by-n matrix.
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;(*f2py_func)(&n,a,&lda,ipiv,jpiv,&info);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),intent(in,out,copy,out=lu) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    integer dimension(n),depend(n),intent(out) :: ipiv
    integer dimension(n),depend(n),intent(out) :: jpiv
    integer intent(out):: info

end subroutine zgetc2



subroutine sgesc2(n,lu,lda,rhs,ipiv,jpiv,scale)
    ! x,scale = gesc2(lu,rhs,ipiv,jpiv,overwrite_rhs=0)
    ! Solve  A * X = scale * RHS
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i],++jpiv[i++]);(*f2py_func)(&n,lu,&lda,rhs,ipiv,jpiv,&scale);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,float*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    real dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer intent(hide),depend(lu):: lda = MAX(1,shape(lu,0))
    real dimension(n),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==len(rhs)) :: rhs
    integer dimension(n),intent(in),depend(n) :: ipiv
    integer dimension(n),intent(in),depend(n) :: jpiv
    real intent(out):: scale

end subroutine sgesc2


subroutine dgesc2(n,lu,lda,rhs,ipiv,jpiv,scale)
    ! x,scale = gesc2(lu,rhs,ipiv,jpiv,overwrite_rhs=0)
    ! Solve  A * X = scale * RHS
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i],++jpiv[i++]);(*f2py_func)(&n,lu,&lda,rhs,ipiv,jpiv,&scale);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,double*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    double precision dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer intent(hide),depend(lu):: lda = MAX(1,shape(lu,0))
    double precision dimension(n),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==len(rhs)) :: rhs
    integer dimension(n),intent(in),depend(n) :: ipiv
    integer dimension(n),intent(in),depend(n) :: jpiv
    double precision intent(out):: scale

end subroutine dgesc2


subroutine cgesc2(n,lu,lda,rhs,ipiv,jpiv,scale)
    ! x,scale = gesc2(lu,rhs,ipiv,jpiv,overwrite_rhs=0)
    ! Solve  A * X = scale * RHS
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i],++jpiv[i++]);(*f2py_func)(&n,lu,&lda,rhs,ipiv,jpiv,&scale);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,float*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    complex dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer intent(hide),depend(lu):: lda = MAX(1,shape(lu,0))
    complex dimension(n),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==len(rhs)) :: rhs
    integer dimension(n),intent(in),depend(n) :: ipiv
    integer dimension(n),intent(in),depend(n) :: jpiv
    real intent(out):: scale

end subroutine cgesc2


subroutine zgesc2(n,lu,lda,rhs,ipiv,jpiv,scale)
    ! x,scale = gesc2(lu,rhs,ipiv,jpiv,overwrite_rhs=0)
    ! Solve  A * X = scale * RHS
    ! A = P * L * U * Q
    threadsafe
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i],++jpiv[i++]);(*f2py_func)(&n,lu,&lda,rhs,ipiv,jpiv,&scale);for(i=0;i<n;--ipiv[i],--jpiv[i++]);}
    callprotoargument F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,double*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    double complex dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer intent(hide),depend(lu):: lda = MAX(1,shape(lu,0))
    double complex dimension(n),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==len(rhs)) :: rhs
    integer dimension(n),intent(in),depend(n) :: ipiv
    integer dimension(n),intent(in),depend(n) :: jpiv
    double precision intent(out):: scale

end subroutine zgesc2



subroutine sgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    real dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine sgetri


subroutine dgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    double precision dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine dgetri


subroutine cgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    complex dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine cgetri


subroutine zgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {F_INT i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    double complex dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine zgetri



subroutine sgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname sgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in):: n
    real intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    real intent(out) :: work
end subroutine sgetri_lwork


subroutine dgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname dgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in):: n
    double precision intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    double precision intent(out) :: work
end subroutine dgetri_lwork


subroutine cgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname cgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

    integer intent(in):: n
    complex intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    complex intent(out) :: work
end subroutine cgetri_lwork


subroutine zgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname zgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

    integer intent(in):: n
    double complex intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    double complex intent(out) :: work
end subroutine zgetri_lwork



subroutine sgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    real dimension(m,n),intent(in,copy,aligned8) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    real dimension(u0,u1),intent(out),depend(u0, u1) :: u
    real dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn,compute_uv) &
        :: lwork = max((compute_uv?4*minmn*minmn+MAX(m,n)+9*minmn:MAX(14*minmn+4,10*minmn+2+25*(25+8))+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine sgesdd


subroutine dgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double precision dimension(m,n),intent(in,copy,aligned8) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double precision dimension(u0,u1),intent(out),depend(u0, u1) :: u
    double precision dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn,compute_uv) &
        :: lwork = max((compute_uv?4*minmn*minmn+MAX(m,n)+9*minmn:MAX(14*minmn+4,10*minmn+2+25*(25+8))+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine dgesdd



subroutine sgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! LWORK computation for (S/D)GESDD

    fortranname sgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    real intent(hide) :: a
    real intent(hide) :: s
    real intent(hide) :: u
    real intent(hide) :: vt
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info

end subroutine sgesdd_lwork


subroutine dgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! LWORK computation for (S/D)GESDD

    fortranname dgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    double precision intent(hide) :: a
    double precision intent(hide) :: s
    double precision intent(hide) :: u
    double precision intent(hide) :: vt
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info

end subroutine dgesdd_lwork



subroutine cgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    complex dimension(m,n),intent(in,copy) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    real dimension((compute_uv?minmn*MAX(5*minmn+7, 2*MAX(m,n)+2*minmn+1):7*minmn)),intent(hide,cache),depend(minmn,compute_uv) :: rwork
    integer optional,intent(in),depend(minmn,compute_uv) &
         :: lwork = max((compute_uv?2*minmn*minmn+MAX(m,n)+2*minmn:2*minmn+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine cgesdd


subroutine zgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double complex dimension(m,n),intent(in,copy) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    double complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    double precision dimension((compute_uv?minmn*MAX(5*minmn+7, 2*MAX(m,n)+2*minmn+1):7*minmn)),intent(hide,cache),depend(minmn,compute_uv) :: rwork
    integer optional,intent(in),depend(minmn,compute_uv) &
         :: lwork = max((compute_uv?2*minmn*minmn+MAX(m,n)+2*minmn:2*minmn+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine zgesdd



subroutine cgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! (C/Z)GESDD call with LWORK=-1 -- copypaste of above gesdd with dummy arrays

    fortranname cgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    complex intent(hide) :: a
    real intent(hide) :: s
    complex intent(hide) :: u
    complex intent(hide) :: vt
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info

end subroutine cgesdd_lwork


subroutine zgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! (C/Z)GESDD call with LWORK=-1 -- copypaste of above gesdd with dummy arrays

    fortranname zgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&iwork,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    double complex intent(hide) :: a
    double precision intent(hide) :: s
    double complex intent(hide) :: u
    double complex intent(hide) :: vt
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info

end subroutine zgesdd_lwork



subroutine sgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    real dimension(m,n),intent(in,copy,aligned8) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    real dimension(u0,u1),intent(out),depend(u0, u1) :: u
    real dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn) :: lwork = max(MAX(3*minmn+MAX(m,n),5*minmn),1)
    integer intent(out) :: info

end subroutine sgesvd


subroutine dgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double precision dimension(m,n),intent(in,copy,aligned8) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double precision dimension(u0,u1),intent(out),depend(u0, u1) :: u
    double precision dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn) :: lwork = max(MAX(3*minmn+MAX(m,n),5*minmn),1)
    integer intent(out) :: info

end subroutine dgesvd



subroutine sgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! LWORK computation for (S/D)GESVD

    fortranname sgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    real intent(hide) :: a
    real intent(hide) :: s
    real intent(hide) :: u
    real intent(hide) :: vt
    integer intent(hide) :: lwork = -1
    real intent(out) :: work
    integer intent(out) :: info

end subroutine sgesvd_lwork


subroutine dgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! LWORK computation for (S/D)GESVD

    fortranname dgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    double precision intent(hide) :: a
    double precision intent(hide) :: s
    double precision intent(hide) :: u
    double precision intent(hide) :: vt
    integer intent(hide) :: lwork = -1
    double precision intent(out) :: work
    integer intent(out) :: info

end subroutine dgesvd_lwork



subroutine cgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    complex dimension(m,n),intent(in,copy) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    real dimension((MAX(1,5*minmn))),intent(hide,cache),depend(minmn) :: rwork
    integer optional,intent(in),depend(minmn) :: lwork = MAX(2*minmn+MAX(m,n),1)
    integer intent(out) :: info

end subroutine cgesvd


subroutine zgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double complex dimension(m,n),intent(in,copy) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    double complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    double precision dimension((MAX(1,5*minmn))),intent(hide,cache),depend(minmn) :: rwork
    integer optional,intent(in),depend(minmn) :: lwork = MAX(2*minmn+MAX(m,n),1)
    integer intent(out) :: info

end subroutine zgesvd



subroutine cgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! (C/Z)GESVD call with LWORK=-1 -- copypaste of above gesvd with dummy arrays

    fortranname cgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide) :: lwork = -1
    complex intent(hide) :: a
    real intent(hide) :: s
    complex intent(hide) :: u
    complex intent(hide) :: vt
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(out) :: info

end subroutine cgesvd_lwork


subroutine zgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! (C/Z)GESVD call with LWORK=-1 -- copypaste of above gesvd with dummy arrays

    fortranname zgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide) :: lwork = -1
    double complex intent(hide) :: a
    double precision intent(hide) :: s
    double complex intent(hide) :: u
    double complex intent(hide) :: vt
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(out) :: info

end subroutine zgesvd_lwork



subroutine sgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    real dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    real intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    real depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine sgels


subroutine dgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    double precision dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double precision intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    double precision depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine dgels


subroutine cgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    complex dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    complex intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    complex depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine cgels


subroutine zgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    double complex dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double complex intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    double complex depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine zgels



subroutine sgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname sgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs

    real intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    real intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1

    real intent(out):: work
    integer intent(out)::info

end subroutine sgels_lwork


subroutine dgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname dgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs

    double precision intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    double precision intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1

    double precision intent(out):: work
    integer intent(out)::info

end subroutine dgels_lwork


subroutine cgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname cgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs

    complex intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    complex intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1

    complex intent(out):: work
    integer intent(out)::info

end subroutine cgels_lwork


subroutine zgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname zgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs

    double complex intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    double complex intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1

    double complex intent(out):: work
    integer intent(out)::info

end subroutine zgels_lwork



subroutine sgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s

    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
       check(lwork>=1||lwork==-1) &
       :: lwork=max(3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)),1)
       !check(lwork>=3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)))
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out)::info

end subroutine sgelss


subroutine dgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s

    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
       check(lwork>=1||lwork==-1) &
       :: lwork=max(3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)),1)
       !check(lwork>=3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)))
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out)::info

end subroutine dgelss



subroutine sgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
   ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size
    fortranname sgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real intent(hide) :: a

    integer intent(in):: nrhs
    real intent(hide) :: b

    real intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    real intent(out) :: work
    integer intent(out)::info

end subroutine sgelss_lwork


subroutine dgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
   ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size
    fortranname dgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision intent(hide) :: a

    integer intent(in):: nrhs
    double precision intent(hide) :: b

    double precision intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    double precision intent(out) :: work
    integer intent(out)::info

end subroutine dgelss_lwork



subroutine cgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s

    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
        check(lwork>=1||lwork==-1) &
        :: lwork=max(2*minmn+MAX(maxmn,nrhs),1)
        ! check(lwork>=2*minmn+MAX(maxmn,nrhs))
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    real dimension(5*minmn),intent(hide),depend(lwork) :: rwork
    integer intent(out)::info

end subroutine cgelss


subroutine zgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s

    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
        check(lwork>=1||lwork==-1) &
        :: lwork=max(2*minmn+MAX(maxmn,nrhs),1)
        ! check(lwork>=2*minmn+MAX(maxmn,nrhs))
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    double precision dimension(5*minmn),intent(hide),depend(lwork) :: rwork
    integer intent(out)::info

end subroutine zgelss



subroutine cgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
    ! Query for optimal lwork size

    fortranname cgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex intent(hide) :: a

    integer intent(in):: nrhs
    complex intent(hide) :: b

    real intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(out)::info

end subroutine sgelss_lwork


subroutine zgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
    ! Query for optimal lwork size

    fortranname zgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex intent(hide) :: a

    integer intent(in):: nrhs
    double complex intent(hide) :: b

    double precision intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(out)::info

end subroutine dgelss_lwork



subroutine sgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! v,x,j,rank,info = dgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    real dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=MAX(minmn+3*n+1, 2*minmn+nrhs)) :: lwork
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out)::info

end subroutine sgelsy


subroutine dgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! v,x,j,rank,info = dgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    double precision dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=MAX(minmn+3*n+1, 2*minmn+nrhs)) :: lwork
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out)::info

end subroutine dgelsy



subroutine sgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! work,info = dgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname sgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real intent(hide) :: a

    integer intent(in):: nrhs
    real intent(hide):: b

    real intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide):: jptv

    integer intent(in),optional :: lwork = -1
    real intent(out) :: work
    integer intent(out)::info

end subroutine sgelsy_lwork


subroutine dgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! work,info = dgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname dgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision intent(hide) :: a

    integer intent(in):: nrhs
    double precision intent(hide):: b

    double precision intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide):: jptv

    integer intent(in),optional :: lwork = -1
    double precision intent(out) :: work
    integer intent(out)::info

end subroutine dgelsy_lwork



subroutine cgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! v,x,j,rank,info = zgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide), depend(m,n) :: minmn = MIN(m,n)
    complex dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=minmn+MAX(MAX(2*minmn, n+1), minmn+nrhs)) :: lwork
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    real dimension(2*n),intent(hide,cache),depend(n) :: rwork
    integer intent(out)::info

end subroutine cgelsy


subroutine zgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! v,x,j,rank,info = zgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide), depend(m,n) :: minmn = MIN(m,n)
    double complex dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=minmn+MAX(MAX(2*minmn, n+1), minmn+nrhs)) :: lwork
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    double precision dimension(2*n),intent(hide,cache),depend(n) :: rwork
    integer intent(out)::info

end subroutine zgelsy



subroutine cgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! work,info = zgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname cgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide) :: maxmn = MAX(m,n)
    complex intent(hide) :: a

    integer intent(in):: nrhs
    complex intent(hide) :: b

    real intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide) :: jptv

    integer intent(in),optional :: lwork = -1
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(out)::info

end subroutine cgelsy_lwork


subroutine zgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! work,info = zgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname zgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide) :: maxmn = MAX(m,n)
    double complex intent(hide) :: a

    integer intent(in):: nrhs
    double complex intent(hide) :: b

    double precision intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide) :: jptv

    integer intent(in),optional :: lwork = -1
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(out)::info

end subroutine zgelsy_lwork



subroutine sgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_iwork,iwork,info)
    ! x,s,rank,info = dgelsd(a,b,lwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_iwork
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine sgelsd


subroutine dgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_iwork,iwork,info)
    ! x,s,rank,info = dgelsd(a,b,lwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_iwork
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine dgelsd



subroutine sgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,iwork,info)
   ! work,iwork,info = dgelsd_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size

    fortranname sgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real intent(hide) :: a

    integer intent(in):: nrhs
    real intent(hide) :: b

    real intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    real intent(out) :: work

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine sgelsd_lwork


subroutine dgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,iwork,info)
   ! work,iwork,info = dgelsd_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size

    fortranname dgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision intent(hide) :: a

    integer intent(in):: nrhs
    double precision intent(hide) :: b

    double precision intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    double precision intent(out) :: work

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine dgelsd_lwork



subroutine cgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_rwork,rwork, size_iwork,iwork,info)
    ! x,s,rank,info = zgelsd(a,b,lwork,size_rwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork, rwork, iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*, complex_float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1||lwork==-1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_rwork, size_iwork
    complex dimension(MAX(lwork,1)),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_rwork
    real intent(cache,hide),dimension(MAX(1,size_rwork)),depend(size_rwork) :: rwork

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine cgelsd


subroutine zgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_rwork,rwork, size_iwork,iwork,info)
    ! x,s,rank,info = zgelsd(a,b,lwork,size_rwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork, rwork, iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*, complex_double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1||lwork==-1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_rwork, size_iwork
    double complex dimension(MAX(lwork,1)),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_rwork
    double precision intent(cache,hide),dimension(MAX(1,size_rwork)),depend(size_rwork) :: rwork

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine zgelsd



subroutine cgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,rwork,iwork,info)
    ! work,rwork,iwork,info = zgelsd_lwork(m,n,nrhs,lwork=-1.0,cond=-1.0)
    ! Query for optimal lwork size

    fortranname cgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork, &rwork, &iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*, complex_float*,F_INT*,float*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex intent(hide) :: a

    integer intent(in):: nrhs
    complex intent(hide) :: b

    real intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    complex intent(out) :: work
    real intent(out) :: rwork

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine cgelsd_lwork


subroutine zgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,rwork,iwork,info)
    ! work,rwork,iwork,info = zgelsd_lwork(m,n,nrhs,lwork=-1.0,cond=-1.0)
    ! Query for optimal lwork size

    fortranname zgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork, &rwork, &iwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*, complex_double*,F_INT*,double*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex intent(hide) :: a

    integer intent(in):: nrhs
    double complex intent(hide) :: b

    double precision intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    double complex intent(out) :: work
    double precision intent(out) :: rwork

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine zgelsd_lwork



subroutine sgeqp3(m,n,a,jpvt,tau,work,lwork,info)
   ! qr_a,jpvt,tau,work,info = geqp3(a,lwork=3*(n+1),overwrite_a=0)
   ! Compute a QR factorization of a real M-by-N matrix A with column pivoting:
   !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,float*,F_INT*,F_INT*
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    real dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info
end subroutine sgeqp3


subroutine dgeqp3(m,n,a,jpvt,tau,work,lwork,info)
   ! qr_a,jpvt,tau,work,info = geqp3(a,lwork=3*(n+1),overwrite_a=0)
   ! Compute a QR factorization of a real M-by-N matrix A with column pivoting:
   !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,double*,F_INT*,F_INT*
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    double precision dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info
end subroutine dgeqp3



subroutine cgeqp3(m,n,a,jpvt,tau,work,lwork,rwork,info)
    ! qr_a,jpvt,tau,work,info = geqp3(a,lwork,overwrite_a=0)
    ! Compute a QR factorization of a complex M-by-N matrix A with column pivoting:
    !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,rwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,complex_float*,F_INT*,float*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    real dimension(2*n),intent(hide),depend(n) :: rwork
    integer intent(out) :: info

end subroutine cgeqp3


subroutine zgeqp3(m,n,a,jpvt,tau,work,lwork,rwork,info)
    ! qr_a,jpvt,tau,work,info = geqp3(a,lwork,overwrite_a=0)
    ! Compute a QR factorization of a complex M-by-N matrix A with column pivoting:
    !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,rwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,complex_double*,F_INT*,double*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    double complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    double precision dimension(2*n),intent(hide),depend(n) :: rwork
    integer intent(out) :: info

end subroutine zgeqp3



subroutine sgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    real dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sgeqrf


subroutine dgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double precision dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dgeqrf


subroutine cgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cgeqrf


subroutine zgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zgeqrf



subroutine sgeqrf_lwork(m,n,a,tau,work,lwork,info)
    ! work, info = geqrf_lwork(m, n)
    ! Calculate the optimal size of the ?geqrf work array.

    fortranname sgeqrf
    callstatement (*f2py_func)(&m,&n,&a,&m,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    real intent(hide) :: a
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine sgeqrf_lwork


subroutine dgeqrf_lwork(m,n,a,tau,work,lwork,info)
    ! work, info = geqrf_lwork(m, n)
    ! Calculate the optimal size of the ?geqrf work array.

    fortranname dgeqrf
    callstatement (*f2py_func)(&m,&n,&a,&m,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    double precision intent(hide) :: a
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine dgeqrf_lwork


subroutine cgeqrf_lwork(m,n,a,tau,work,lwork,info)
    ! work, info = geqrf_lwork(m, n)
    ! Calculate the optimal size of the ?geqrf work array.

    fortranname cgeqrf
    callstatement (*f2py_func)(&m,&n,&a,&m,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    complex intent(hide) :: a
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine cgeqrf_lwork


subroutine zgeqrf_lwork(m,n,a,tau,work,lwork,info)
    ! work, info = geqrf_lwork(m, n)
    ! Calculate the optimal size of the ?geqrf work array.

    fortranname zgeqrf
    callstatement (*f2py_func)(&m,&n,&a,&m,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    double complex intent(hide) :: a
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine zgeqrf_lwork



subroutine sgeqrfp(m,n,a,lda,tau,work,lwork,info)
    ! qr,tau,work,info = geqrfp(a,lwork=3*n,overwrite_a=0)
    ! DGEQR2P computes a QR factorization of a real M-by-N matrix A:
    !
    !    A = Q * ( R ),
    !            ( 0 )
    !
    ! where:
    !
    !    Q is a M-by-M orthogonal matrix;
    !    R is an upper-triangular N-by-N matrix with nonnegative diagonal
    !    entries;
    !    0 is a (M-N)-by-N zero matrix, if M > N.

    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(hide), check(m > 0), depend(a) :: m = shape(a, 0)
    integer intent(hide), check(n > 0), depend(a) :: n = shape(a, 1)
    real intent(in,out,copy,out=qr), dimension(m,n) :: a
    integer intent(hide), depend(a) :: lda = max(1, shape(a, 0))
    real intent(out), depend(m,n), dimension(MIN(m,n)) :: tau
    real intent(hide), depend(lwork), dimension(lwork) :: work
    integer intent(in), check(lwork>=n||lwork==-1) :: lwork = MAX(1, n)
    integer intent(out) :: info

end subroutine sgeqrfp


subroutine dgeqrfp(m,n,a,lda,tau,work,lwork,info)
    ! qr,tau,work,info = geqrfp(a,lwork=3*n,overwrite_a=0)
    ! DGEQR2P computes a QR factorization of a real M-by-N matrix A:
    !
    !    A = Q * ( R ),
    !            ( 0 )
    !
    ! where:
    !
    !    Q is a M-by-M orthogonal matrix;
    !    R is an upper-triangular N-by-N matrix with nonnegative diagonal
    !    entries;
    !    0 is a (M-N)-by-N zero matrix, if M > N.

    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(hide), check(m > 0), depend(a) :: m = shape(a, 0)
    integer intent(hide), check(n > 0), depend(a) :: n = shape(a, 1)
    double precision intent(in,out,copy,out=qr), dimension(m,n) :: a
    integer intent(hide), depend(a) :: lda = max(1, shape(a, 0))
    double precision intent(out), depend(m,n), dimension(MIN(m,n)) :: tau
    double precision intent(hide), depend(lwork), dimension(lwork) :: work
    integer intent(in), check(lwork>=n||lwork==-1) :: lwork = MAX(1, n)
    integer intent(out) :: info

end subroutine dgeqrfp


subroutine cgeqrfp(m,n,a,lda,tau,work,lwork,info)
    ! qr,tau,work,info = geqrfp(a,lwork=3*n,overwrite_a=0)
    ! DGEQR2P computes a QR factorization of a real M-by-N matrix A:
    !
    !    A = Q * ( R ),
    !            ( 0 )
    !
    ! where:
    !
    !    Q is a M-by-M orthogonal matrix;
    !    R is an upper-triangular N-by-N matrix with nonnegative diagonal
    !    entries;
    !    0 is a (M-N)-by-N zero matrix, if M > N.

    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide), check(m > 0), depend(a) :: m = shape(a, 0)
    integer intent(hide), check(n > 0), depend(a) :: n = shape(a, 1)
    complex intent(in,out,copy,out=qr), dimension(m,n) :: a
    integer intent(hide), depend(a) :: lda = max(1, shape(a, 0))
    complex intent(out), depend(m,n), dimension(MIN(m,n)) :: tau
    complex intent(hide), depend(lwork), dimension(lwork) :: work
    integer intent(in), check(lwork>=n||lwork==-1) :: lwork = MAX(1, n)
    integer intent(out) :: info

end subroutine cgeqrfp


subroutine zgeqrfp(m,n,a,lda,tau,work,lwork,info)
    ! qr,tau,work,info = geqrfp(a,lwork=3*n,overwrite_a=0)
    ! DGEQR2P computes a QR factorization of a real M-by-N matrix A:
    !
    !    A = Q * ( R ),
    !            ( 0 )
    !
    ! where:
    !
    !    Q is a M-by-M orthogonal matrix;
    !    R is an upper-triangular N-by-N matrix with nonnegative diagonal
    !    entries;
    !    0 is a (M-N)-by-N zero matrix, if M > N.

    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide), check(m > 0), depend(a) :: m = shape(a, 0)
    integer intent(hide), check(n > 0), depend(a) :: n = shape(a, 1)
    double complex intent(in,out,copy,out=qr), dimension(m,n) :: a
    integer intent(hide), depend(a) :: lda = max(1, shape(a, 0))
    double complex intent(out), depend(m,n), dimension(MIN(m,n)) :: tau
    double complex intent(hide), depend(lwork), dimension(lwork) :: work
    integer intent(in), check(lwork>=n||lwork==-1) :: lwork = MAX(1, n)
    integer intent(out) :: info

end subroutine zgeqrfp



subroutine sgeqrfp_lwork(m,n,a,lda,tau,work,lwork,info)
    ! work, info = geqrfp_lwork(m, n)

    fortranname sgeqrfp
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    real intent(hide) :: a
    integer intent(hide), depend(m) :: lda = m
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine sgeqrfp_lwork


subroutine dgeqrfp_lwork(m,n,a,lda,tau,work,lwork,info)
    ! work, info = geqrfp_lwork(m, n)

    fortranname dgeqrfp
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    double precision intent(hide) :: a
    integer intent(hide), depend(m) :: lda = m
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine dgeqrfp_lwork


subroutine cgeqrfp_lwork(m,n,a,lda,tau,work,lwork,info)
    ! work, info = geqrfp_lwork(m, n)

    fortranname cgeqrfp
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    complex intent(hide) :: a
    integer intent(hide), depend(m) :: lda = m
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine cgeqrfp_lwork


subroutine zgeqrfp_lwork(m,n,a,lda,tau,work,lwork,info)
    ! work, info = geqrfp_lwork(m, n)

    fortranname zgeqrfp
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(in), check(m > 0) :: m
    integer intent(in), check(n > 0) :: n
    double complex intent(hide) :: a
    integer intent(hide), depend(m) :: lda = m
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine zgeqrfp_lwork



subroutine sgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    real dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sgerqf


subroutine dgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double precision dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dgerqf


subroutine cgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cgerqf


subroutine zgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zgerqf



subroutine sgeev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! wr,wi,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=4*n,overwrite_a=0)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    real  dimension(n,n),intent(in,copy,aligned8) :: a
    check(shape(a,0)==shape(a,1)) :: a

    real dimension(n),intent(out),depend(n) :: wr
    real dimension(n),intent(out),depend(n) :: wi

    real dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    real dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(4*n,1)
    check(lwork>=((compute_vl||compute_vr)?4*n:3*n)) :: lwork
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(out):: info

end subroutine sgeev


subroutine dgeev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! wr,wi,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=4*n,overwrite_a=0)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision  dimension(n,n),intent(in,copy,aligned8) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double precision dimension(n),intent(out),depend(n) :: wr
    double precision dimension(n),intent(out),depend(n) :: wi

    double precision dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double precision dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(4*n,1)
    check(lwork>=((compute_vl||compute_vr)?4*n:3*n)) :: lwork
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(out):: info

end subroutine dgeev



subroutine sgeev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! LWORK=-1 call for (S/D)GEEV --- keep in sync with above (S/D)GEEV definition

    fortranname sgeev
    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&wr,&wi,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&info);}
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    real intent(hide) :: a

    real intent(hide) :: wr
    real intent(hide) :: wi

    real intent(hide) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    real intent(hide) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    real intent(out) :: work

    integer intent(out):: info

end subroutine sgeev_lwork


subroutine dgeev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! LWORK=-1 call for (S/D)GEEV --- keep in sync with above (S/D)GEEV definition

    fortranname dgeev
    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&wr,&wi,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&info);}
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    double precision intent(hide) :: a

    double precision intent(hide) :: wr
    double precision intent(hide) :: wi

    double precision intent(hide) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double precision intent(hide) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    double precision intent(out) :: work

    integer intent(out):: info

end subroutine dgeev_lwork



subroutine cgeev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! w,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,w,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    complex  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    complex  dimension(n),intent(out),depend(n) :: w

    complex  dimension(ldvl,n),depend(ldvl),intent(out) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    complex  dimension(ldvr,n),depend(ldvr),intent(out) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(2*n,1)
    check(lwork>=2*n) :: lwork
    complex dimension(lwork),intent(hide),depend(lwork) :: work
    real dimension(2*n),intent(hide,cache),depend(n) :: rwork

    integer intent(out):: info

end subroutine cgeev


subroutine zgeev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! w,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,w,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double complex  dimension(n),intent(out),depend(n) :: w

    double complex  dimension(ldvl,n),depend(ldvl),intent(out) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    double complex  dimension(ldvr,n),depend(ldvr),intent(out) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(2*n,1)
    check(lwork>=2*n) :: lwork
    double complex dimension(lwork),intent(hide),depend(lwork) :: work
    double precision dimension(2*n),intent(hide,cache),depend(n) :: rwork

    integer intent(out):: info

end subroutine zgeev



subroutine cgeev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! LWORK=-1 call for (C/Z)GEEV --- keep in sync with above (C/Z)GEEV definition

    fortranname cgeev
    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&w,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    complex intent(hide) :: a

    complex intent(hide) :: w

    complex intent(hide) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    complex intent(hide) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    complex intent(out) :: work
    real intent(hide) :: rwork

    integer intent(out):: info

end subroutine cgeev_lwork


subroutine zgeev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! LWORK=-1 call for (C/Z)GEEV --- keep in sync with above (C/Z)GEEV definition

    fortranname zgeev
    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&w,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    double complex intent(hide) :: a

    double complex intent(hide) :: w

    double complex intent(hide) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    double complex intent(hide) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    double complex intent(out) :: work
    double precision intent(hide) :: rwork

    integer intent(out):: info

end subroutine zgeev_lwork




subroutine cgees(compute_v,sort_t,cselect,n,a,nrows,sdim,w,vs,ldvs,work,lwork,rwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a complex matrix is in Schur form if it is upper
    !  triangular

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_cselect_in_gees__user__routines,&n,a,&nrows,&sdim,w,vs,&ldvs,work,&lwork,rwork,bwork,&info,1,1)
    callprotoargument char*,char*,F_INT(*)(complex_float*),F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT,F_INT

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external cselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    complex intent(in,out,copy,out=t),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    complex intent(out),dimension(n) :: w
    complex intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    real optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine cgees



subroutine zgees(compute_v,sort_t,zselect,n,a,nrows,sdim,w,vs,ldvs,work,lwork,rwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a complex matrix is in Schur form if it is upper
    !  triangular

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_zselect_in_gees__user__routines,&n,a,&nrows,&sdim,w,vs,&ldvs,work,&lwork,rwork,bwork,&info,1,1)
    callprotoargument char*,char*,F_INT(*)(complex_double*),F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT,F_INT

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external zselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    double complex intent(in,out,copy,out=t),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    double complex intent(out),dimension(n) :: w
    double complex intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    double complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    double precision optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine zgees



subroutine sgees(compute_v,sort_t,sselect,n,a,nrows,sdim,wr,wi,vs,ldvs,work,lwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a real matrix is in Schur form if it is upper quasi-
    !  triangular with 1x1 and 2x2 blocks.

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_sselect_in_gees__user__routines,&n,a,&nrows,&sdim,wr,wi,vs,&ldvs,work,&lwork,bwork,&info,1,1)
    callprotoargument char*,char*,F_INT(*)(float*,float*),F_INT*,float*,F_INT*,F_INT*,float*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT,F_INT

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external sselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    real intent(in,out,copy,out=t,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    real intent(out),dimension(n) :: wr
    real intent(out),dimension(n) :: wi
    real intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    real intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    real optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine sgees


subroutine dgees(compute_v,sort_t,dselect,n,a,nrows,sdim,wr,wi,vs,ldvs,work,lwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a real matrix is in Schur form if it is upper quasi-
    !  triangular with 1x1 and 2x2 blocks.

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_dselect_in_gees__user__routines,&n,a,&nrows,&sdim,wr,wi,vs,&ldvs,work,&lwork,bwork,&info,1,1)
    callprotoargument char*,char*,F_INT(*)(double*,double*),F_INT*,double*,F_INT*,F_INT*,double*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT,F_INT

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external dselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    double precision intent(in,out,copy,out=t,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    double precision intent(out),dimension(n) :: wr
    double precision intent(out),dimension(n) :: wi
    double precision intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    double precision intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    double precision optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine dgees



subroutine sgges(jobvsl,jobvsr,sort_t,sselect,n,a,lda,b,ldb,sdim,alphar,alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
    ! For a pair of N-by-N real nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_sselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alphar,alphai,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,bwork,&info)
    callprotoargument char*,char*,char*,F_INT(*)(float*,float*,float*),F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,float*,float*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external sselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    real intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    real intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    real intent(out),dimension(n) :: alphar
    real intent(out),dimension(n) :: alphai
    real intent(out),dimension(n) :: beta
    real intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    real intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    real intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,MAX(8*n, 6*n+16))||lwork==-1):: lwork=max(8*n+16,1)
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine sgges


subroutine dgges(jobvsl,jobvsr,sort_t,dselect,n,a,lda,b,ldb,sdim,alphar,alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
    ! For a pair of N-by-N real nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_dselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alphar,alphai,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,bwork,&info)
    callprotoargument char*,char*,char*,F_INT(*)(double*,double*,double*),F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,double*,double*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external dselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    double precision intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    double precision intent(out),dimension(n) :: alphar
    double precision intent(out),dimension(n) :: alphai
    double precision intent(out),dimension(n) :: beta
    double precision intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    double precision intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    double precision intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,MAX(8*n, 6*n+16))||lwork==-1):: lwork=max(8*n+16,1)
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine dgges



subroutine cgges(jobvsl,jobvsr,sort_t,cselect,n,a,lda,b,ldb,sdim,alpha,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
    ! For a pair of N-by-N complex nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**H )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_cselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alpha,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,rwork,bwork,&info)
    callprotoargument char*,char*,char*,F_INT(*)(complex_float*,complex_float*),F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external cselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    complex intent(out),dimension(n) :: alpha
    complex intent(out),dimension(n) :: beta
    complex intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    complex intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,2*n)||lwork==-1):: lwork=max(2*n,1)
    real intent(hide),dimension(8*n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine cgges


subroutine zgges(jobvsl,jobvsr,sort_t,zselect,n,a,lda,b,ldb,sdim,alpha,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
    ! For a pair of N-by-N complex nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**H )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_zselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alpha,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,rwork,bwork,&info)
    callprotoargument char*,char*,char*,F_INT(*)(complex_double*,complex_double*),F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external zselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    double complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    double complex intent(out),dimension(n) :: alpha
    double complex intent(out),dimension(n) :: beta
    double complex intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    double complex intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    double complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,2*n)||lwork==-1):: lwork=max(2*n,1)
    double precision intent(hide),dimension(8*n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine zgges



subroutine sggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    real  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    real intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    real intent(out), dimension(n), depend(n) :: alphar
    real intent(out), dimension(n), depend(n) :: alphai
    real intent(out), dimension(n), depend(n) :: beta

    real  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    real  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(8*n,1)
    check((lwork==-1) || (lwork>=MAX(1,8*n))) :: lwork
    real intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work

    integer intent(out):: info

end subroutine sggev


subroutine dggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double precision intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    double precision intent(out), dimension(n), depend(n) :: alphar
    double precision intent(out), dimension(n), depend(n) :: alphai
    double precision intent(out), dimension(n), depend(n) :: beta

    double precision  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double precision  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(8*n,1)
    check((lwork==-1) || (lwork>=MAX(1,8*n))) :: lwork
    double precision intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work

    integer intent(out):: info

end subroutine dggev



subroutine cggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info);}
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    complex dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    complex intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    complex intent(out), dimension(n), depend(n) :: alpha
    complex intent(out), dimension(n), depend(n) :: beta

    complex  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    complex  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(2*n,1)
    check((lwork==-1) || (lwork>=MAX(1,2*n))) :: lwork
    complex intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work
    real intent(hide), dimension(8*n), depend(n) :: rwork

    integer intent(out):: info

end subroutine sggev


subroutine zggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info);}
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double complex intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    double complex intent(out), dimension(n), depend(n) :: alpha
    double complex intent(out), dimension(n), depend(n) :: beta

    double complex  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double complex  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(2*n,1)
    check((lwork==-1) || (lwork>=MAX(1,2*n))) :: lwork
    double complex intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work
    double precision intent(hide), dimension(8*n), depend(n) :: rwork

    integer intent(out):: info

end subroutine dggev



subroutine sgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,float*,float*,float*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    real intent(in), dimension(m,n) :: a
    real intent(out),dimension(m),depend(m) :: r
    real intent(out),dimension(n),depend(n) :: c
    real intent(out) :: rowcnd
    real intent(out) :: colcnd
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine sgeequ


subroutine dgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,double*,double*,double*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    double precision intent(in), dimension(m,n) :: a
    double precision intent(out),dimension(m),depend(m) :: r
    double precision intent(out),dimension(n),depend(n) :: c
    double precision intent(out) :: rowcnd
    double precision intent(out) :: colcnd
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine dgeequ


subroutine cgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,float*,float*,float*,float*,float*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    complex intent(in), dimension(m,n) :: a
    real intent(out),dimension(m),depend(m) :: r
    real intent(out),dimension(n),depend(n) :: c
    real intent(out) :: rowcnd
    real intent(out) :: colcnd
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine cgeequ


subroutine zgeequ(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,double*,double*,double*,double*,double*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    double complex intent(in), dimension(m,n) :: a
    double precision intent(out),dimension(m),depend(m) :: r
    double precision intent(out),dimension(n),depend(n) :: c
    double precision intent(out) :: rowcnd
    double precision intent(out) :: colcnd
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine zgeequ



subroutine sgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,float*,float*,float*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    real intent(in),dimension(m,n) :: a
    real intent(out),dimension(m),depend(m) :: r
    real intent(out),dimension(n),depend(n) :: c
    real intent(out) :: rowcnd
    real intent(out) :: colcnd
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine sgeequb


subroutine dgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,double*,double*,double*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    double precision intent(in),dimension(m,n) :: a
    double precision intent(out),dimension(m),depend(m) :: r
    double precision intent(out),dimension(n),depend(n) :: c
    double precision intent(out) :: rowcnd
    double precision intent(out) :: colcnd
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine dgeequb


subroutine cgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,float*,float*,float*,float*,float*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    complex intent(in),dimension(m,n) :: a
    real intent(out),dimension(m),depend(m) :: r
    real intent(out),dimension(n),depend(n) :: c
    real intent(out) :: rowcnd
    real intent(out) :: colcnd
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine cgeequb


subroutine zgeequb(m,n,a,lda,r,c,rowcnd,colcnd,amax,info)

    callstatement (*f2py_func)(&m,&n,a,&lda,r,c,&rowcnd,&colcnd,&amax,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,double*,double*,double*,double*,double*,F_INT*

    integer intent(hide),depend(a) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))

    double complex intent(in),dimension(m,n) :: a
    double precision intent(out),dimension(m),depend(m) :: r
    double precision intent(out),dimension(n),depend(n) :: c
    double precision intent(out) :: rowcnd
    double precision intent(out) :: colcnd
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine zgeequb


! Signatures for f2py-wrappers of FORTRAN LAPACK General Banded Matrix functions.
!

subroutine sgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {F_INT i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    real dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    real dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine sgbsv


subroutine dgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {F_INT i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    double precision dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    double precision dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine dgbsv


subroutine cgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {F_INT i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    complex dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    complex dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine cgbsv


subroutine zgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {F_INT i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    double complex dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    double complex dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine zgbsv


   
subroutine sgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {F_INT i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    real dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine sgbtrf

   
subroutine dgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {F_INT i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    double precision dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine dgbtrf

   
subroutine cgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {F_INT i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    complex dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine cgbtrf

   
subroutine zgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {F_INT i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    double complex dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine zgbtrf



subroutine sgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,F_INT*,F_INT *,F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    real dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    real dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine sgbtrs


subroutine dgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,F_INT*,F_INT *,F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    double precision dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    double precision dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine dgbtrs


subroutine cgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,F_INT*,F_INT *,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    complex dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine cgbtrs


subroutine zgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {F_INT i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,F_INT*,F_INT *,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    double complex dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    double complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine zgbtrs


! Signatures for f2py-wrappers of FORTRAN LAPACK General Tridiagonal Matrix functions.
!

subroutine sgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument F_INT*, F_INT*, float*, float*, float*, float*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    real dimension(n), intent(in,out,copy) :: d
    real dimension(n-1), intent(in,out,copy), depend(n) :: du
    real dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine sgtsv


subroutine dgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument F_INT*, F_INT*, double*, double*, double*, double*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    double precision dimension(n), intent(in,out,copy) :: d
    double precision dimension(n-1), intent(in,out,copy), depend(n) :: du
    double precision dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine dgtsv


subroutine cgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument F_INT*, F_INT*, complex_float*, complex_float*, complex_float*, complex_float*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    complex dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    complex dimension(n), intent(in,out,copy) :: d
    complex dimension(n-1), intent(in,out,copy), depend(n) :: du
    complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine cgtsv


subroutine zgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument F_INT*, F_INT*, complex_double*, complex_double*, complex_double*, complex_double*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double complex dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    double complex dimension(n), intent(in,out,copy) :: d
    double complex dimension(n-1), intent(in,out,copy), depend(n) :: du
    double complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine zgtsv




subroutine sgttrf(n, dl, d, du, du2, ipiv, info)
    ! dl, d, du, du2, ipiv, info  = gttrf(dl, d, du, [overwrite_dl=0, overwrite_d=0, overwrite_du=0])
    ! ?GTTRF computes an LU factorization of a tridiagonal matrix A
    ! using elimination with partial pivoting and row interchanges.
    !
    ! The factorization has the form
    !    A = L * U
    !
    ! where L is a product of permutation and unit lower bidiagonal
    ! matrices and U is upper triangular with nonzeros in only the main
    ! diagonal and first two superdiagonals.
    callstatement (*f2py_func)(&n, dl, d, du, du2, ipiv, &info)
    callprotoargument F_INT*, float*, float*, float*, float*, F_INT*, F_INT*

    integer intent(hide), depend(d) :: n = max(3, len(d))
    real intent(in,out,copy), depend(n), dimension(n-1) :: dl
    real intent(in,out,copy), dimension(n) :: d
    real intent(in,out,copy), depend(n), dimension(n-1) :: du
    real intent(out), depend(n), dimension(n-2) :: du2
    integer intent(out), depend(n), dimension(n) :: ipiv
    integer intent(out) :: info

end subroutine sgttrf



subroutine dgttrf(n, dl, d, du, du2, ipiv, info)
    ! dl, d, du, du2, ipiv, info  = gttrf(dl, d, du, [overwrite_dl=0, overwrite_d=0, overwrite_du=0])
    ! ?GTTRF computes an LU factorization of a tridiagonal matrix A
    ! using elimination with partial pivoting and row interchanges.
    !
    ! The factorization has the form
    !    A = L * U
    !
    ! where L is a product of permutation and unit lower bidiagonal
    ! matrices and U is upper triangular with nonzeros in only the main
    ! diagonal and first two superdiagonals.
    callstatement (*f2py_func)(&n, dl, d, du, du2, ipiv, &info)
    callprotoargument F_INT*, double*, double*, double*, double*, F_INT*, F_INT*

    integer intent(hide), depend(d) :: n = max(3, len(d))
    double precision intent(in,out,copy), depend(n), dimension(n-1) :: dl
    double precision intent(in,out,copy), dimension(n) :: d
    double precision intent(in,out,copy), depend(n), dimension(n-1) :: du
    double precision intent(out), depend(n), dimension(n-2) :: du2
    integer intent(out), depend(n), dimension(n) :: ipiv
    integer intent(out) :: info

end subroutine dgttrf



subroutine cgttrf(n, dl, d, du, du2, ipiv, info)
    ! dl, d, du, du2, ipiv, info  = gttrf(dl, d, du, [overwrite_dl=0, overwrite_d=0, overwrite_du=0])
    ! ?GTTRF computes an LU factorization of a tridiagonal matrix A
    ! using elimination with partial pivoting and row interchanges.
    !
    ! The factorization has the form
    !    A = L * U
    !
    ! where L is a product of permutation and unit lower bidiagonal
    ! matrices and U is upper triangular with nonzeros in only the main
    ! diagonal and first two superdiagonals.
    callstatement (*f2py_func)(&n, dl, d, du, du2, ipiv, &info)
    callprotoargument F_INT*, complex_float*, complex_float*, complex_float*, complex_float*, F_INT*, F_INT*

    integer intent(hide), depend(d) :: n = max(3, len(d))
    complex intent(in,out,copy), depend(n), dimension(n-1) :: dl
    complex intent(in,out,copy), dimension(n) :: d
    complex intent(in,out,copy), depend(n), dimension(n-1) :: du
    complex intent(out), depend(n), dimension(n-2) :: du2
    integer intent(out), depend(n), dimension(n) :: ipiv
    integer intent(out) :: info

end subroutine cgttrf



subroutine zgttrf(n, dl, d, du, du2, ipiv, info)
    ! dl, d, du, du2, ipiv, info  = gttrf(dl, d, du, [overwrite_dl=0, overwrite_d=0, overwrite_du=0])
    ! ?GTTRF computes an LU factorization of a tridiagonal matrix A
    ! using elimination with partial pivoting and row interchanges.
    !
    ! The factorization has the form
    !    A = L * U
    !
    ! where L is a product of permutation and unit lower bidiagonal
    ! matrices and U is upper triangular with nonzeros in only the main
    ! diagonal and first two superdiagonals.
    callstatement (*f2py_func)(&n, dl, d, du, du2, ipiv, &info)
    callprotoargument F_INT*, complex_double*, complex_double*, complex_double*, complex_double*, F_INT*, F_INT*

    integer intent(hide), depend(d) :: n = max(3, len(d))
    double complex intent(in,out,copy), depend(n), dimension(n-1) :: dl
    double complex intent(in,out,copy), dimension(n) :: d
    double complex intent(in,out,copy), depend(n), dimension(n-1) :: du
    double complex intent(out), depend(n), dimension(n-2) :: du2
    integer intent(out), depend(n), dimension(n) :: ipiv
    integer intent(out) :: info

end subroutine zgttrf




subroutine sgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
    ! x, info  = gttrs(dl, d, du, du2, ipiv, b, trans="N", overwrite_b=0)
    !
    ! ?GTTRS solves one of the systems of equations:
    ! A*X = B  or  A**T*X = B,
    ! with a tridiagonal matrix A using the LU factorization computed
    ! by ?GTTRF.
    callstatement (*f2py_func)(trans, &n, &nrhs, dl, d, du, du2, ipiv, b, &ldb, &info)
    callprotoargument char*, F_INT*, F_INT*, float*, float*, float*, float*, F_INT*, float*, F_INT*, F_INT*
    threadsafe

    character optional, intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = "N"
    integer intent(hide), depend(d) :: n = max(3, len(d))
    integer intent(hide), depend(b) :: nrhs = max(1, shape(b, 1))
    integer intent(hide), depend(n) :: ldb = max(1, n)
    real intent(in), depend(n), dimension(n - 1) :: dl
    real intent(in), dimension(n) :: d
    real intent(in), depend(n), dimension(n - 1) :: du
    real intent(in), depend(n), dimension(n - 2) :: du2
    integer intent(in), depend(n), dimension(n) :: ipiv
    real intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

end subroutine gttrs



subroutine dgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
    ! x, info  = gttrs(dl, d, du, du2, ipiv, b, trans="N", overwrite_b=0)
    !
    ! ?GTTRS solves one of the systems of equations:
    ! A*X = B  or  A**T*X = B,
    ! with a tridiagonal matrix A using the LU factorization computed
    ! by ?GTTRF.
    callstatement (*f2py_func)(trans, &n, &nrhs, dl, d, du, du2, ipiv, b, &ldb, &info)
    callprotoargument char*, F_INT*, F_INT*, double*, double*, double*, double*, F_INT*, double*, F_INT*, F_INT*
    threadsafe

    character optional, intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = "N"
    integer intent(hide), depend(d) :: n = max(3, len(d))
    integer intent(hide), depend(b) :: nrhs = max(1, shape(b, 1))
    integer intent(hide), depend(n) :: ldb = max(1, n)
    double precision intent(in), depend(n), dimension(n - 1) :: dl
    double precision intent(in), dimension(n) :: d
    double precision intent(in), depend(n), dimension(n - 1) :: du
    double precision intent(in), depend(n), dimension(n - 2) :: du2
    integer intent(in), depend(n), dimension(n) :: ipiv
    double precision intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

end subroutine gttrs



subroutine cgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
    ! x, info  = gttrs(dl, d, du, du2, ipiv, b, trans="N", overwrite_b=0)
    !
    ! ?GTTRS solves one of the systems of equations:
    ! A*X = B  or  A**T*X = B,
    ! with a tridiagonal matrix A using the LU factorization computed
    ! by ?GTTRF.
    callstatement (*f2py_func)(trans, &n, &nrhs, dl, d, du, du2, ipiv, b, &ldb, &info)
    callprotoargument char*, F_INT*, F_INT*, complex_float*, complex_float*, complex_float*, complex_float*, F_INT*, complex_float*, F_INT*, F_INT*
    threadsafe

    character optional, intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = "N"
    integer intent(hide), depend(d) :: n = max(3, len(d))
    integer intent(hide), depend(b) :: nrhs = max(1, shape(b, 1))
    integer intent(hide), depend(n) :: ldb = max(1, n)
    complex intent(in), depend(n), dimension(n - 1) :: dl
    complex intent(in), dimension(n) :: d
    complex intent(in), depend(n), dimension(n - 1) :: du
    complex intent(in), depend(n), dimension(n - 2) :: du2
    integer intent(in), depend(n), dimension(n) :: ipiv
    complex intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

end subroutine gttrs



subroutine zgttrs(trans, n, nrhs, dl, d, du, du2, ipiv, b, ldb, info)
    ! x, info  = gttrs(dl, d, du, du2, ipiv, b, trans="N", overwrite_b=0)
    !
    ! ?GTTRS solves one of the systems of equations:
    ! A*X = B  or  A**T*X = B,
    ! with a tridiagonal matrix A using the LU factorization computed
    ! by ?GTTRF.
    callstatement (*f2py_func)(trans, &n, &nrhs, dl, d, du, du2, ipiv, b, &ldb, &info)
    callprotoargument char*, F_INT*, F_INT*, complex_double*, complex_double*, complex_double*, complex_double*, F_INT*, complex_double*, F_INT*, F_INT*
    threadsafe

    character optional, intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = "N"
    integer intent(hide), depend(d) :: n = max(3, len(d))
    integer intent(hide), depend(b) :: nrhs = max(1, shape(b, 1))
    integer intent(hide), depend(n) :: ldb = max(1, n)
    double complex intent(in), depend(n), dimension(n - 1) :: dl
    double complex intent(in), dimension(n) :: d
    double complex intent(in), depend(n), dimension(n - 1) :: du
    double complex intent(in), depend(n), dimension(n - 2) :: du2
    integer intent(in), depend(n), dimension(n) :: ipiv
    double complex intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

end subroutine gttrs




subroutine sgtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! ?GTSVX uses the LU factorization to compute the solution to a real
    ! system of linear equations A * X = B or A**T * X = B,
    ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
    ! matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    !provided.
    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);
    callprotoargument char*,char*,F_INT*,F_INT*,float*,float*,float*,float*,float*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*

    character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
    character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real intent(in), depend(n), dimension(MAX(0, n-1)) :: dl
    real intnet(in), dimension(n) :: d
    real intent(in), depend(n), dimension(MAX(0, n-1)) :: du
    real optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: dlf
    real optional, intent(in,out), depend(n), dimension(n) :: df
    real optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: duf
    real optional, intent(in,out), depend(n), dimension(MAX(0,n-2)) :: du2
    integer optional, intent(in,out), depend(n), dimension(n) :: ipiv
    real intent(in), dimension(ldb, nrhs) :: b
    integer intent(hide), check(ldb >= n), depend(b) :: ldb = max(1, shape(b, 0))
    real intent(out), dimension(ldx,nrhs) :: x
    integer intent(hide) :: ldx = MAX(1, shape(b, 0))
    real intent(out) :: rcond
    real intent(out), dimension(nrhs),depend(nrhs) :: ferr
    real intent(out), dimension(nrhs),depend(nrhs) :: berr
    real intent(hide, cache), dimension(3*n),depend(n) :: work
    integer intent(hide, cache), dimension(n), depend(n) :: iwork
    integer intent(out) :: info

end subroutine sgtsvx



subroutine dgtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! ?GTSVX uses the LU factorization to compute the solution to a real
    ! system of linear equations A * X = B or A**T * X = B,
    ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
    ! matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    !provided.
    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);
    callprotoargument char*,char*,F_INT*,F_INT*,double*,double*,double*,double*,double*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*

    character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
    character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision intent(in), depend(n), dimension(MAX(0, n-1)) :: dl
    double precision intnet(in), dimension(n) :: d
    double precision intent(in), depend(n), dimension(MAX(0, n-1)) :: du
    double precision optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: dlf
    double precision optional, intent(in,out), depend(n), dimension(n) :: df
    double precision optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: duf
    double precision optional, intent(in,out), depend(n), dimension(MAX(0,n-2)) :: du2
    integer optional, intent(in,out), depend(n), dimension(n) :: ipiv
    double precision intent(in), dimension(ldb, nrhs) :: b
    integer intent(hide), check(ldb >= n), depend(b) :: ldb = max(1, shape(b, 0))
    double precision intent(out), dimension(ldx,nrhs) :: x
    integer intent(hide) :: ldx = MAX(1, shape(b, 0))
    double precision intent(out) :: rcond
    double precision intent(out), dimension(nrhs),depend(nrhs) :: ferr
    double precision intent(out), dimension(nrhs),depend(nrhs) :: berr
    double precision intent(hide, cache), dimension(3*n),depend(n) :: work
    integer intent(hide, cache), dimension(n), depend(n) :: iwork
    integer intent(out) :: info

end subroutine dgtsvx




subroutine cgtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! ?GTSVX uses the LU factorization to compute the solution to a
    ! complex system of linear equations A * X = B or A**T * X = B,
    ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
    ! matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    !provided.
    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,complex_float*,complex_float*,complex_float*,complex_float*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,float*,F_INT*

    character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
    character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    complex intent(in), depend(n), dimension(MAX(0, n-1)) :: dl
    complex intnet(in), dimension(n) :: d
    complex intent(in), depend(n), dimension(MAX(0, n-1)) :: du
    complex optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: dlf
    complex optional, intent(in,out), depend(n), dimension(n) :: df
    complex optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: duf
    complex optional, intent(in,out), depend(n), dimension(MAX(0,n-2)) :: du2
    integer optional, intent(in,out), depend(n), dimension(n) :: ipiv
    complex intent(in), dimension(ldb, nrhs) :: b
    integer intent(hide), check(ldb >= n), depend(b) :: ldb = max(1, shape(b, 0))
    complex intent(out), dimension(ldx,nrhs) :: x
    integer intent(hide) :: ldx = MAX(1, shape(b, 0))
    real intent(out) :: rcond
    real intent(out), dimension(nrhs),depend(nrhs) :: ferr
    real intent(out), dimension(nrhs),depend(nrhs) :: berr
    complex dimension(2*n),depend(n),intent(hide,cache) :: work
    real intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out) :: info

end subroutine cgtsvx



subroutine zgtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! ?GTSVX uses the LU factorization to compute the solution to a
    ! complex system of linear equations A * X = B or A**T * X = B,
    ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
    ! matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    !provided.
    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,complex_double*,complex_double*,complex_double*,complex_double*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,double*,F_INT*

    character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
    character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double complex intent(in), depend(n), dimension(MAX(0, n-1)) :: dl
    double complex intnet(in), dimension(n) :: d
    double complex intent(in), depend(n), dimension(MAX(0, n-1)) :: du
    double complex optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: dlf
    double complex optional, intent(in,out), depend(n), dimension(n) :: df
    double complex optional, intent(in,out), depend(n), dimension(MAX(0,n-1)) :: duf
    double complex optional, intent(in,out), depend(n), dimension(MAX(0,n-2)) :: du2
    integer optional, intent(in,out), depend(n), dimension(n) :: ipiv
    double complex intent(in), dimension(ldb, nrhs) :: b
    integer intent(hide), check(ldb >= n), depend(b) :: ldb = max(1, shape(b, 0))
    double complex intent(out), dimension(ldx,nrhs) :: x
    integer intent(hide) :: ldx = MAX(1, shape(b, 0))
    double precision intent(out) :: rcond
    double precision intent(out), dimension(nrhs),depend(nrhs) :: ferr
    double precision intent(out), dimension(nrhs),depend(nrhs) :: berr
    double complex dimension(2*n),depend(n),intent(hide,cache) :: work
    double precision intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out) :: info

end subroutine zgtsvx


! Signatures for f2py-wrappers of FORTRAN LAPACK Symmetric/Hermitian Matrix functions.
!

subroutine ssyev(compute_v,lower,n,w,a,lda,work,lwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    real dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(3*n-1,1)
    check(lwork>=3*n-1) :: lwork
    real dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out) :: info

end subroutine ssyev


subroutine dsyev(compute_v,lower,n,w,a,lda,work,lwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(3*n-1,1)
    check(lwork>=3*n-1) :: lwork
    double precision dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out) :: info

end subroutine dsyev



subroutine ssyev_lwork(lower,n,w,a,lda,work,lwork,info)
    ! LWORK routines for syev

    fortranname ssyev

    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*
    
     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     
     integer intent(hide),depend(n):: lda = MAX(1, n)
     real intent(hide):: a
     real intent(hide):: w
     integer intent(hide):: lwork = -1
    
     real intent(out):: work
     integer intent(out):: info
     
end subroutine ssyev_lwork


subroutine dsyev_lwork(lower,n,w,a,lda,work,lwork,info)
    ! LWORK routines for syev

    fortranname dsyev

    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*
    
     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     
     integer intent(hide),depend(n):: lda = MAX(1, n)
     double precision intent(hide):: a
     double precision intent(hide):: w
     integer intent(hide):: lwork = -1
    
     double precision intent(out):: work
     integer intent(out):: info
     
end subroutine dsyev_lwork



subroutine cheev(compute_v,lower,n,w,a,lda,work,lwork,rwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*

    integer optional,intent(in),check(compute_v==1||compute_v==0) :: compute_v = 1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(2*n-1,1)
    check(lwork>=2*n-1) :: lwork
    complex dimension(lwork),intent(hide),depend(lwork) :: work
    real dimension(3*n-1),intent(hide),depend(n) :: rwork

    integer intent(out) :: info

end subroutine cheev


subroutine zheev(compute_v,lower,n,w,a,lda,work,lwork,rwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*

    integer optional,intent(in),check(compute_v==1||compute_v==0) :: compute_v = 1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(2*n-1,1)
    check(lwork>=2*n-1) :: lwork
    double complex dimension(lwork),intent(hide),depend(lwork) :: work
    double precision dimension(3*n-1),intent(hide),depend(n) :: rwork

    integer intent(out) :: info

end subroutine zheev



subroutine cheev_lwork(lower,n,w,a,lda,work,lwork,rwork,info)
    ! LWORK routines for heev

    fortranname cheev
    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     
     integer intent(hide),depend(n):: lda = MAX(1, n)
     complex intent(hide):: a
     real intent(hide):: w
     real intent(hide):: rwork
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info
     
end subroutine cheev_lwork


subroutine zheev_lwork(lower,n,w,a,lda,work,lwork,rwork,info)
    ! LWORK routines for heev

    fortranname zheev
    callstatement (*f2py_func)("N",(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     
     integer intent(hide),depend(n):: lda = MAX(1, n)
     double complex intent(hide):: a
     double precision intent(hide):: w
     double precision intent(hide):: rwork
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info
     
end subroutine zheev_lwork



subroutine ssyevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info)
    ! w,v,info = syevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A using D&C.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(compute_v==1||compute_v==0) :: compute_v = 1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a
    integer intent(hide),depend(n) :: lda = MAX(1,n)
    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?1+6*n+2*n*n:2*n+1),1)
    check(lwork>=(compute_v?1+6*n+2*n*n:2*n+1)) :: lwork
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer optional,intent(in),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(out) :: info

end subroutine ssyevd


subroutine dsyevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info)
    ! w,v,info = syevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A using D&C.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(compute_v==1||compute_v==0) :: compute_v = 1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a
    integer intent(hide),depend(n) :: lda = MAX(1,n)
    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?1+6*n+2*n*n:2*n+1),1)
    check(lwork>=(compute_v?1+6*n+2*n*n:2*n+1)) :: lwork
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer optional,intent(in),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(out) :: info

end subroutine dsyevd



subroutine ssyevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info)
    ! LWORK routines for syevd

    fortranname ssyevd

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    
    integer intent(hide):: lda = MAX(1,n)
    real intent(hide):: a
    real intent(hide):: w
    integer intent(hide):: lwork = -1
    integer intent(hide):: liwork = -1
    
    real intent(out):: work
    integer intent(out):: iwork
    integer intent(out):: info

end subroutine ssyevd_lwork


subroutine dsyevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,info)
    ! LWORK routines for syevd

    fortranname dsyevd

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    
    integer intent(hide):: lda = MAX(1,n)
    double precision intent(hide):: a
    double precision intent(hide):: w
    integer intent(hide):: lwork = -1
    integer intent(hide):: liwork = -1
    
    double precision intent(out):: work
    integer intent(out):: iwork
    integer intent(out):: info

end subroutine dsyevd_lwork



subroutine cheevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! w,v,info = heevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A using D&C.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a
    integer intent(hide),depend(n) :: lda = MAX(1,n)
    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?2*n+n*n:n+1),1)
    check(lwork>=(compute_v?2*n+n*n:n+1)) :: lwork
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer optional,intent(in),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer optional,intent(in),depend(n,compute_v) :: lrwork = (compute_v?1+5*n+2*n*n:n)
    real dimension(lrwork),intent(hide,cache),depend(n,lrwork) :: rwork
    integer intent(out) :: info

end subroutine cheevd


subroutine zheevd(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! w,v,info = heevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A using D&C.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&lda,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a
    integer intent(hide),depend(n) :: lda = MAX(1,n)
    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?2*n+n*n:n+1),1)
    check(lwork>=(compute_v?2*n+n*n:n+1)) :: lwork
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer optional,intent(in),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer optional,intent(in),depend(n,compute_v) :: lrwork = (compute_v?1+5*n+2*n*n:n)
    double precision dimension(lrwork),intent(hide,cache),depend(n,lrwork) :: rwork
    integer intent(out) :: info

end subroutine zheevd



subroutine cheevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! LWORK routines for heevd
    
    fortranname cheevd
    
    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    
    integer intent(hide):: lda=MAX(1,n)
    complex intent(hide):: a
    real intent(hide):: w
    integer intent(hide):: lwork=-1
    integer intent(hide):: liwork=-1
    integer intent(hide):: lrwork=-1
    
    complex intent(out):: work
    real intent(out):: rwork
    integer intent(out):: iwork
    integer intent(out):: info

end subroutine cheevd_lwork


subroutine zheevd_lwork(compute_v,lower,n,w,a,lda,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! LWORK routines for heevd
    
    fortranname zheevd
    
    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&a,&lda,&w,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    
    integer intent(hide):: lda=MAX(1,n)
    double complex intent(hide):: a
    double precision intent(hide):: w
    integer intent(hide):: lwork=-1
    integer intent(hide):: liwork=-1
    integer intent(hide):: lrwork=-1
    
    double complex intent(out):: work
    double precision intent(out):: rwork
    integer intent(out):: iwork
    integer intent(out):: info

end subroutine zheevd_lwork



   subroutine ssytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     real dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinessytf2


   subroutine dsytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double precision dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinedsytf2


   subroutine csytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinecsytf2


   subroutine zsytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinezsytf2



  subroutine ssygst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = sygst(a,b)
    ! Transforms the generalized symmetric eigenvalue problem to standard.
    ! A = inv(U^T) * A * inv(U), if itype == 1
    ! A = U^T * A * U or L^T * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument F_INT*,char*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     real dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     real dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine ssygst


  subroutine dsygst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = sygst(a,b)
    ! Transforms the generalized symmetric eigenvalue problem to standard.
    ! A = inv(U^T) * A * inv(U), if itype == 1
    ! A = U^T * A * U or L^T * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument F_INT*,char*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double precision dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     double precision dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine dsygst



   subroutine ssytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     real dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     real depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine ssytrf


   subroutine dsytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double precision dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     double precision depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine dsytrf


   subroutine csytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine csytrf


   subroutine zsytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zsytrf




   subroutine ssytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname ssytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     real intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     real intent(out):: work
     integer intent(out):: info

   end subroutine ssytrf_lwork



   subroutine dsytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname dsytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     double precision intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     double precision intent(out):: work
     integer intent(out):: info

   end subroutine dsytrf_lwork



   subroutine csytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname csytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine csytrf_lwork



   subroutine zsytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname zsytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zsytrf_lwork




   subroutine ssysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     real dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     real depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine ssysv



   subroutine dsysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     double precision dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     double precision depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine dsysv



   subroutine csysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine csysv



   subroutine zsysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     double complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zsysv



   subroutine ssysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname ssysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     real intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     real intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     real intent(out):: work
     integer intent(out):: info

   end subroutine ssysv_lwork


   subroutine dsysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname dsysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     double precision intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     double precision intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     double precision intent(out):: work
     integer intent(out):: info

   end subroutine dsysv_lwork


   subroutine csysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname csysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine csysv_lwork


   subroutine zsysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname zsysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     double complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zsysv_lwork



   subroutine ssysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*,F_INT*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     real optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     real depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     real dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     real intent(out):: rcond
     real intent(out),dimension(nrhs),depend(nrhs):: ferr
     real intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=3*n||lwork==-1):: lwork = max(3*n,1)
     real dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     integer intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine ssysvx


   subroutine dsysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*,F_INT*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     double precision optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     double precision depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     double precision dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     double precision intent(out):: rcond
     double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
     double precision intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=3*n||lwork==-1):: lwork = max(3*n,1)
     double precision dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     integer intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine dsysvx


   subroutine csysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,F_INT*,float*,F_INT*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     complex optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     complex depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     complex dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     real intent(out):: rcond
     real intent(out),dimension(nrhs),depend(nrhs):: ferr
     real intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=2*n||lwork==-1):: lwork = max(3*n,1)
     complex dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     real intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine csysvx


   subroutine zsysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,F_INT*,double*,F_INT*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     double complex optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     double complex depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     double complex dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     double precision intent(out):: rcond
     double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
     double precision intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=2*n||lwork==-1):: lwork = max(3*n,1)
     double complex dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     double precision intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine zsysvx



   subroutine ssysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname ssysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     real intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     real intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     real intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     real intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     real intent(hide):: rcond
     real intent(hide):: ferr
     real intent(hide):: berr
     integer intent(hide):: lwork = -1
     integer intent(hide):: irwork

     real intent(out) :: work
     integer intent(out):: info

   end subroutine ssysvx_lwork


   subroutine dsysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname dsysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     double precision intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     double precision intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     double precision intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     double precision intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     double precision intent(hide):: rcond
     double precision intent(hide):: ferr
     double precision intent(hide):: berr
     integer intent(hide):: lwork = -1
     integer intent(hide):: irwork

     double precision intent(out) :: work
     integer intent(out):: info

   end subroutine dsysvx_lwork


   subroutine csysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname csysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,F_INT*,float*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     complex intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     complex intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     real intent(hide):: rcond
     real intent(hide):: ferr
     real intent(hide):: berr
     integer intent(hide):: lwork = -1
     real intent(hide):: irwork

     complex intent(out) :: work
     integer intent(out):: info

   end subroutine csysvx_lwork


   subroutine zsysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname zsysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,F_INT*,double*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     double complex intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     double complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     double complex intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     double precision intent(hide):: rcond
     double precision intent(hide):: ferr
     double precision intent(hide):: berr
     integer intent(hide):: lwork = -1
     double precision intent(hide):: irwork

     double complex intent(out) :: work
     integer intent(out):: info

   end subroutine zsysvx_lwork




  subroutine ssycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a real symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (S/D)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,float*,float*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(in) :: anorm
    real intent(out) :: rcond
    real intent(hide),dimension(2*n),depend(n) :: work
    integer intent(hide),dimension(n),depend(n) :: iwork
    integer intent(out) :: info

  end subroutine ssycon



  subroutine dsycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a real symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (S/D)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,double*,double*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(in) :: anorm
    double precision intent(out) :: rcond
    double precision intent(hide),dimension(2*n),depend(n) :: work
    integer intent(hide),dimension(n),depend(n) :: iwork
    integer intent(out) :: info

  end subroutine dsycon




  subroutine csycon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,float*,float*,complex_float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(in) :: anorm
    real intent(out) :: rcond
    complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine csycon



  subroutine zsycon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,double*,double*,complex_double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(in) :: anorm
    double precision intent(out) :: rcond
    double complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine zsycon



  subroutine checon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,float*,float*,complex_float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(in) :: anorm
    real intent(out) :: rcond
    complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine checon



  subroutine zhecon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,double*,double*,complex_double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(in) :: anorm
    double precision intent(out) :: rcond
    double complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine zhecon



  subroutine ssyconv(lower,way,n,a,lda,ipiv,e,info)
  ! ?SYCONV converts A given by ???TRF into L and D and vice-versa.
  ! Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.

    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(way==0||way==1) :: way = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=a):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(out),dimension(n),depend(n):: e
    integer intent(out) :: info

  end subroutine ssyconv


  subroutine dsyconv(lower,way,n,a,lda,ipiv,e,info)
  ! ?SYCONV converts A given by ???TRF into L and D and vice-versa.
  ! Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.

    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(way==0||way==1) :: way = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=a):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(out),dimension(n),depend(n):: e
    integer intent(out) :: info

  end subroutine dsyconv


  subroutine csyconv(lower,way,n,a,lda,ipiv,e,info)
  ! ?SYCONV converts A given by ???TRF into L and D and vice-versa.
  ! Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.

    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(way==0||way==1) :: way = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=a):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    complex intent(out),dimension(n),depend(n):: e
    integer intent(out) :: info

  end subroutine csyconv


  subroutine zsyconv(lower,way,n,a,lda,ipiv,e,info)
  ! ?SYCONV converts A given by ???TRF into L and D and vice-versa.
  ! Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.

    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(way==0||way==1) :: way = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=a):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double complex intent(out),dimension(n),depend(n):: e
    integer intent(out) :: info

  end subroutine zsyconv



  subroutine chegst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = hegst(a,b)
    ! Transforms the generalized Hermitian eigenvalue problem to standard.
    ! A = inv(U^H) * A * inv(U), if itype == 1
    ! A = U^H * A * U or L^H * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument F_INT*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     complex dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine chegst


  subroutine zhegst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = hegst(a,b)
    ! Transforms the generalized Hermitian eigenvalue problem to standard.
    ! A = inv(U^H) * A * inv(U), if itype == 1
    ! A = U^H * A * U or L^H * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument F_INT*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     double complex dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine zhegst



   subroutine chetrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a hermitian matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?HETF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine chetrf


   subroutine zhetrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a hermitian matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?HETF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zhetrf




   subroutine chetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?HETRF

     fortranname chetrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine chetrf_lwork



   subroutine zhetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?HETRF

     fortranname zhetrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zhetrf_lwork




   subroutine chesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solves A * X = B for X
   ! A is hermitian. For symmetric A see ?SYSV
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
     threadsafe
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=uduh):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine chesv



   subroutine zhesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solves A * X = B for X
   ! A is hermitian. For symmetric A see ?SYSV
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
     threadsafe
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=uduh):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     double complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zhesv



   subroutine chesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for C/ZHESV

     fortranname chesv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in):: n

     integer intent(hide):: nrhs = 1
     complex intent(hide):: a
     integer intent(hide),depend(n):: lda = n
     integer intent(hide):: ipiv
     complex intent(hide):: b
     integer intent(hide),depend(n):: ldb = n
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine chesv_lwork


   subroutine zhesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for C/ZHESV

     fortranname zhesv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in):: n

     integer intent(hide):: nrhs = 1
     double complex intent(hide):: a
     integer intent(hide),depend(n):: lda = n
     integer intent(hide):: ipiv
     double complex intent(hide):: b
     integer intent(hide),depend(n):: ldb = n
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zhesv_lwork



subroutine chesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
   ! Solves A * X = B for X
   ! Expert driver for ?HESV
   ! A is hermitian. For symmetric A see ?SYSVX
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
    threadsafe
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,F_INT*,float*,F_INT*

    integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    complex optional,dimension(n,n),depend(n),intent(in,out,out=uduh) :: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,depend(n),dimension(n),intent(in,out):: ipiv
    complex depend(n),dimension(n,nrhs),intent(in,copy) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    complex depend(n,nrhs),dimension(n,nrhs),intent(out) :: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    complex dimension(MAX(1,lwork)),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(2*n,1)
    real intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out):: info

end subroutine chesvx


subroutine zhesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
   ! Solves A * X = B for X
   ! Expert driver for ?HESV
   ! A is hermitian. For symmetric A see ?SYSVX
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
    threadsafe
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,F_INT*,double*,F_INT*

    integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double complex optional,dimension(n,n),depend(n),intent(in,out,out=uduh) :: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,depend(n),dimension(n),intent(in,out):: ipiv
    double complex depend(n),dimension(n,nrhs),intent(in,copy) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double complex depend(n,nrhs),dimension(n,nrhs),intent(out) :: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double complex dimension(MAX(1,lwork)),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(2*n,1)
    double precision intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out):: info

end subroutine zhesvx



subroutine chesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
    ! lwork computation for ?HESVX
    fortranname chesvx
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,F_INT*,float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in):: n

    integer intent(hide) :: factored = 0
    integer depend(b),intent(hide):: nrhs = 1
    complex intent(hide) :: a
    integer depend(n),intent(hide):: lda = n
    complex intent(hide) :: af
    integer depend(n),intent(hide):: ldaf = n
    integer intent(hide):: ipiv
    complex intent(hide) :: b
    integer depend(n),intent(hide):: ldb = n
    complex intent(hide) :: x
    integer depend(n),intent(hide):: ldx = n
    real intent(hide):: rcond
    real intent(hide):: ferr
    real intent(hide):: berr
    integer intent(hide):: lwork = -1
    real intent(hide):: rwork

    complex intent(out):: work
    integer intent(out):: info

end subroutine chesvx_lwork


subroutine zhesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
    ! lwork computation for ?HESVX
    fortranname zhesvx
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,F_INT*,double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in):: n

    integer intent(hide) :: factored = 0
    integer depend(b),intent(hide):: nrhs = 1
    double complex intent(hide) :: a
    integer depend(n),intent(hide):: lda = n
    double complex intent(hide) :: af
    integer depend(n),intent(hide):: ldaf = n
    integer intent(hide):: ipiv
    double complex intent(hide) :: b
    integer depend(n),intent(hide):: ldb = n
    double complex intent(hide) :: x
    integer depend(n),intent(hide):: ldx = n
    double precision intent(hide):: rcond
    double precision intent(hide):: ferr
    double precision intent(hide):: berr
    integer intent(hide):: lwork = -1
    double precision intent(hide):: rwork

    double complex intent(out):: work
    integer intent(out):: info

end subroutine zhesvx_lwork



subroutine ssytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a real symmetric matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**T * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    real dimension(n),intent(out),depend(n) :: d
    real dimension(n-1),intent(out),depend(n) :: e
    real dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine ssytrd


subroutine dsytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a real symmetric matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**T * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    double precision dimension(n),intent(out),depend(n) :: d
    double precision dimension(n-1),intent(out),depend(n) :: e
    double precision dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dsytrd



subroutine ssytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for sytrd
    fortranname ssytrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    real intent(hide) :: a
    real intent(hide) :: d
    real intent(hide) :: e
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine ssytrd_lwork


subroutine dsytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for sytrd
    fortranname dsytrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    double precision intent(hide) :: a
    double precision intent(hide) :: d
    double precision intent(hide) :: e
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine dsytrd_lwork



subroutine chetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a complex hermitian matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**H * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,F_INT*,complex_float*,F_INT*,float*,float*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    real dimension(n),intent(out),depend(n) :: d
    real dimension(n-1),intent(out),depend(n) :: e
    complex dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine chetrd


subroutine zhetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a complex hermitian matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**H * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,F_INT*,complex_double*,F_INT*,double*,double*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    double precision dimension(n),intent(out),depend(n) :: d
    double precision dimension(n-1),intent(out),depend(n) :: e
    double complex dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    double complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zhetrd



subroutine chetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for hetrd
    fortranname chetrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,F_INT*,complex_float*,F_INT*,float*,float*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    complex intent(hide) :: a
    real intent(hide) :: d
    real intent(hide) :: e
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine chetrd_lwork


subroutine zhetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for hetrd
    fortranname zhetrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,F_INT*,complex_double*,F_INT*,double*,double*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    double complex intent(hide) :: a
    double precision intent(hide) :: d
    double precision intent(hide) :: e
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine zhetrd_lwork



subroutine ssyevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! Standard Symmetric/HermitianEigenvalue Problem
    ! Real - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs hence 0x0 'z' returned
    ! if jobz = 'V' and range = 'A', z is (nxn)
    ! if jobz = 'V' and range = 'V', z is (nxn) since returned number of eigs is unknown beforehand
    ! if jobz = 'V' and range = 'I', z is (nx(iu-il+1))

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    real intent(in,copy,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    real optional,intent(in) :: vl=0.0
    real optional,intent(in),check(vu>=vl),depend(vl) :: vu=1.0
    real intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=max(1,26*n)||lwork==-1) :: lwork=max(26*n,1)
    integer optional,intent(in),depend(n),check(liwork>=max(1,10*n)||liwork==-1):: liwork= max(1,10*n)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    real  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    real intent(out),dimension(n),depend(n) :: w
    real intent(out),dimension((compute_v?MAX(0,n):0),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,compute_v,range,iu,il) :: z
    integer intent(out) :: m
    ! Only returned if range=='A' or range=='I' and il, iu = 1, n
    integer intent(out),dimension((compute_v?(2*((*range=='A')||((*range=='I') && (iu-il+1==n))?n:0)):0)),depend(n,iu,il,compute_v,range) :: isuppz
    integer intent(out) :: info

end subroutine ssyevr


subroutine dsyevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! Standard Symmetric/HermitianEigenvalue Problem
    ! Real - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs hence 0x0 'z' returned
    ! if jobz = 'V' and range = 'A', z is (nxn)
    ! if jobz = 'V' and range = 'V', z is (nxn) since returned number of eigs is unknown beforehand
    ! if jobz = 'V' and range = 'I', z is (nx(iu-il+1))

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    double precision intent(in,copy,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    double precision optional,intent(in) :: vl=0.0
    double precision optional,intent(in),check(vu>=vl),depend(vl) :: vu=1.0
    double precision intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=max(1,26*n)||lwork==-1) :: lwork=max(26*n,1)
    integer optional,intent(in),depend(n),check(liwork>=max(1,10*n)||liwork==-1):: liwork= max(1,10*n)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    double precision  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    double precision intent(out),dimension(n),depend(n) :: w
    double precision intent(out),dimension((compute_v?MAX(0,n):0),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,compute_v,range,iu,il) :: z
    integer intent(out) :: m
    ! Only returned if range=='A' or range=='I' and il, iu = 1, n
    integer intent(out),dimension((compute_v?(2*((*range=='A')||((*range=='I') && (iu-il+1==n))?n:0)):0)),depend(n,iu,il,compute_v,range) :: isuppz
    integer intent(out) :: info

end subroutine dsyevr



subroutine ssyevr_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! LWORK routines for (s/d)syevr
    fortranname ssyevr
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Inputs
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    ! Not referenced
    real intent(hide) :: a
    integer intent(hide),depend(n) :: lda = max(1,n)
    real intent(hide) :: vl=0.
    real intent(hide) :: vu=1.
    integer intent(hide) :: il=1
    integer intent(hide) :: iu=2
    real intent(hide) :: abstol=0.
    integer  intent(hide) :: m=1
    real intent(hide) :: w
    real intent(hide) :: z
    integer intent(hide),depend(n):: ldz = max(1,n)
    integer intent(hide) :: isuppz
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: liwork = -1
    ! Outputs
    real intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine ssyevr_lwork


subroutine dsyevr_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! LWORK routines for (s/d)syevr
    fortranname dsyevr
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Inputs
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    ! Not referenced
    double precision intent(hide) :: a
    integer intent(hide),depend(n) :: lda = max(1,n)
    double precision intent(hide) :: vl=0.
    double precision intent(hide) :: vu=1.
    integer intent(hide) :: il=1
    integer intent(hide) :: iu=2
    double precision intent(hide) :: abstol=0.
    integer  intent(hide) :: m=1
    double precision intent(hide) :: w
    double precision intent(hide) :: z
    integer intent(hide),depend(n):: ldz = max(1,n)
    integer intent(hide) :: isuppz
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: liwork = -1
    ! Outputs
    double precision intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine dsyevr_lwork



subroutine cheevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Standard Symmetric/HermitianEigenvalue Problem
    ! Complex - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs hence 0x0 'z' returned
    ! if jobz = 'V' and range = 'A', z is (nxn)
    ! if jobz = 'V' and range = 'V', z is (nxn) since returned number of eigs is unknown beforehand
    ! if jobz = 'V' and range = 'I', z is (nx(iu-il+1))

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    complex intent(in,copy,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    real optional,intent(in) :: vl=0.0
    real optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    real intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=max(2*n,1)||lwork==-1) :: lwork=max(2*n,1)
    integer optional,intent(in),depend(n),check(lrwork>=max(24*n,1)||lrwork==-1) :: lrwork=max(24*n,1)
    integer optional,intent(in),depend(n),check(liwork>=max(1,10*n)||liwork==-1):: liwork= max(1,10*n)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    complex  intent(hide),dimension(lwork),depend(lwork) :: work
    real intent(hide),dimension(lrwork),depend(lrwork) :: rwork
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    real intent(out),dimension(n),depend(n) :: w
    complex intent(out),dimension((compute_v?MAX(0,n):0),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,compute_v,range,iu,il) :: z
    integer intent(out) :: m
    ! MKL implementation has a bug that still accesses isuppz array even if
    ! range=='A' or range=='I' and il, iu = 1, n which is not the case for
    ! the reference implementation. Hence here isuppz is allocated regardless
    ! of the settings. It is wasteful but necessary. The bug is fixed in
    ! mkl 2020 update 2 and when time comes change this line with
    !
    ! integer intent(out),dimension((compute_v?(2*(*range=='A'||((*range=='I') && (iu-il+1==n))?n:0)):0)),depend(n,iu,il,range,compute_v) :: isuppz
    !
    integer intent(out),dimension(2*max(1,n)),depend(n) :: isuppz
    integer intent(out) :: info

end subroutine cheevr


subroutine zheevr(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Standard Symmetric/HermitianEigenvalue Problem
    ! Complex - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs hence 0x0 'z' returned
    ! if jobz = 'V' and range = 'A', z is (nxn)
    ! if jobz = 'V' and range = 'V', z is (nxn) since returned number of eigs is unknown beforehand
    ! if jobz = 'V' and range = 'I', z is (nx(iu-il+1))

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,isuppz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    double complex intent(in,copy,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    double precision optional,intent(in) :: vl=0.0
    double precision optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    double precision intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=max(2*n,1)||lwork==-1) :: lwork=max(2*n,1)
    integer optional,intent(in),depend(n),check(lrwork>=max(24*n,1)||lrwork==-1) :: lrwork=max(24*n,1)
    integer optional,intent(in),depend(n),check(liwork>=max(1,10*n)||liwork==-1):: liwork= max(1,10*n)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    double complex  intent(hide),dimension(lwork),depend(lwork) :: work
    double precision intent(hide),dimension(lrwork),depend(lrwork) :: rwork
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    double precision intent(out),dimension(n),depend(n) :: w
    double complex intent(out),dimension((compute_v?MAX(0,n):0),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,compute_v,range,iu,il) :: z
    integer intent(out) :: m
    ! MKL implementation has a bug that still accesses isuppz array even if
    ! range=='A' or range=='I' and il, iu = 1, n which is not the case for
    ! the reference implementation. Hence here isuppz is allocated regardless
    ! of the settings. It is wasteful but necessary. The bug is fixed in
    ! mkl 2020 update 2 and when time comes change this line with
    !
    ! integer intent(out),dimension((compute_v?(2*(*range=='A'||((*range=='I') && (iu-il+1==n))?n:0)):0)),depend(n,iu,il,range,compute_v) :: isuppz
    !
    integer intent(out),dimension(2*max(1,n)),depend(n) :: isuppz
    integer intent(out) :: info

end subroutine zheevr



subroutine cheevr_lwork(n,lower,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! LWORK routines for (c/z)heevr
    fortranname cheevr
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Inputs
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    ! Not referenced
    complex intent(hide) :: a
    integer intent(hide),depend(n) :: lda = max(1,n)
    real intent(hide) :: vl=0.
    real intent(hide) :: vu=1.
    integer intent(hide) :: il=1
    integer intent(hide) :: iu=2
    real intent(hide) :: abstol=0.
    integer  intent(hide) :: m=1
    real intent(hide) :: w
    complex intent(hide) :: z
    integer intent(hide),depend(n):: ldz = max(1,n)
    integer intent(hide) :: isuppz
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: lrwork = -1
    integer intent(hide) :: liwork = -1
    ! Outputs
    complex intent(out) :: work
    real intent(out) :: rwork
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine cheevr_work


subroutine zheevr_lwork(n,lower,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! LWORK routines for (c/z)heevr
    fortranname zheevr
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&isuppz,&work,&lwork,&rwork,&lrwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Inputs
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    ! Not referenced
    double complex intent(hide) :: a
    integer intent(hide),depend(n) :: lda = max(1,n)
    double precision intent(hide) :: vl=0.
    double precision intent(hide) :: vu=1.
    integer intent(hide) :: il=1
    integer intent(hide) :: iu=2
    double precision intent(hide) :: abstol=0.
    integer  intent(hide) :: m=1
    double precision intent(hide) :: w
    double complex intent(hide) :: z
    integer intent(hide),depend(n):: ldz = max(1,n)
    integer intent(hide) :: isuppz
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: lrwork = -1
    integer intent(hide) :: liwork = -1
    ! Outputs
    double complex intent(out) :: work
    double precision intent(out) :: rwork
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine zheevr_work



subroutine ssyevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info)
    ! DSYEVX computes selected eigenvalues and, optionally, eigenvectors
    ! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
    ! selected by specifying either a range of values or a range of indices
    ! for the desired eigenvalues.

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    real optional,intent(in) :: vl=0.0
    real optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    real optional,intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(8*n,1)

    real intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a,0))
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    real  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork

    real intent(out),dimension(n),depend(n) :: w
    real intent(out),dimension((compute_v?MAX(0,n):0),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,compute_v,range,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension((compute_v?n:0)),depend(compute_v,n):: ifail
    integer intent(out) :: info
    
end subroutine ssyevx


subroutine dsyevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info)
    ! DSYEVX computes selected eigenvalues and, optionally, eigenvectors
    ! of a real symmetric matrix A.  Eigenvalues and eigenvectors can be
    ! selected by specifying either a range of values or a range of indices
    ! for the desired eigenvalues.

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    double precision optional,intent(in) :: vl=0.0
    double precision optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    double precision optional,intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(8*n,1)

    double precision intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a,0))
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    double precision  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork

    double precision intent(out),dimension(n),depend(n) :: w
    double precision intent(out),dimension((compute_v?MAX(0,n):0),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,compute_v,range,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension((compute_v?n:0)),depend(compute_v,n):: ifail
    integer intent(out) :: info
    
end subroutine dsyevx



subroutine ssyevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! LWORK routines for (d/s)syevx

    fortranname ssyevx
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*
    
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    real intent(hide):: vl = 0.0
    real intent(hide):: vu = 1.0
    real intent(hide):: abstol = 0.0
    integer intent(hide):: m
    real intent(hide):: w
    real intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    integer intent(hide):: iwork
    integer intent(hide):: ifail
        
    real intent(out):: work
    integer intent(out):: info

end subroutine ssyevx_lwork


subroutine dsyevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! LWORK routines for (d/s)syevx

    fortranname dsyevx
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*
    
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    double precision intent(hide):: vl = 0.0
    double precision intent(hide):: vu = 1.0
    double precision intent(hide):: abstol = 0.0
    integer intent(hide):: m
    double precision intent(hide):: w
    double precision intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    integer intent(hide):: iwork
    integer intent(hide):: ifail
        
    double precision intent(out):: work
    integer intent(out):: info

end subroutine dsyevx_lwork



subroutine cheevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info)
    ! (C/Z)HEEVX computes selected eigenvalues and, optionally, eigenvectors
    ! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
    ! be selected by specifying either a range of values or a range of
    ! indices for the desired eigenvalues.

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    real optional,intent(in) :: vl=0.0
    real optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    real optional,intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(2*n,1)

    complex intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(a) :: lda=max(1,shape(a,0))
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    complex intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork
    real intent(hide),dimension(7*n),depend(n) :: rwork

    real intent(out),dimension(n),depend(n) :: w
    complex intent(out),dimension((compute_v*n),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(compute_v,range,n,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension(compute_v*n),depend(compute_v,n):: ifail
    integer intent(out) :: info
    
end subroutine cheevx


subroutine zheevx(compute_v,range,lower,n,a,lda,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info)
    ! (C/Z)HEEVX computes selected eigenvalues and, optionally, eigenvectors
    ! of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can
    ! be selected by specifying either a range of values or a range of
    ! indices for the desired eigenvalues.

    callstatement (*f2py_func)((compute_v?"V":"N"),range,(lower?"L":"U"),&n,a,&lda,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(compute_v==1||compute_v==0):: compute_v = 1
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(il>=1&&il<=n),depend(n) :: il=1
    integer optional,intent(in),check(n>=iu&&iu>=il),depend(n,il) :: iu=n
    double precision optional,intent(in) :: vl=0.0
    double precision optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    double precision optional,intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(2*n,1)

    double complex intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(a) :: lda=max(1,shape(a,0))
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    double complex intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork
    double precision intent(hide),dimension(7*n),depend(n) :: rwork

    double precision intent(out),dimension(n),depend(n) :: w
    double complex intent(out),dimension((compute_v*n),(compute_v?((*range=='I')?(iu-il+1):MAX(1,n)):0)),depend(compute_v,range,n,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension(compute_v*n),depend(compute_v,n):: ifail
    integer intent(out) :: info
    
end subroutine zheevx



subroutine cheevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! LWORK routines for (c/z)heevx

    fortranname cheevx
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*
    
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    real intent(hide):: vl = 0.0
    real intent(hide):: vu = 1.0
    real intent(hide):: abstol = 0.0
    integer intent(hide):: m
    real intent(hide):: w
    complex intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    real intent(hide):: rwork
    integer intent(hide):: iwork
    integer intent(hide):: ifail
        
    complex intent(out):: work
    integer intent(out):: info

end subroutine cheevx_lwork


subroutine zheevx_lwork(lower,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! LWORK routines for (c/z)heevx

    fortranname zheevx
    callstatement (*f2py_func)("N","A",(lower?"L":"U"),&n,&a,&lda,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*
    
    integer intent(in):: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    double precision intent(hide):: vl = 0.0
    double precision intent(hide):: vu = 1.0
    double precision intent(hide):: abstol = 0.0
    integer intent(hide):: m
    double precision intent(hide):: w
    double complex intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    double precision intent(hide):: rwork
    integer intent(hide):: iwork
    integer intent(hide):: ifail
        
    double complex intent(out):: work
    integer intent(out):: info

end subroutine zheevx_lwork



subroutine ssygv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,info)
    ! Generalized Symmetric Eigenvalue Problem
    ! Real - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs returned
    ! if jobz = 'V' 'a' contains eigvecs

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*
    !                itype,jobz ,uplo , n  ,    a    ,lda ,    b    , ldb,   w     , work   ,lwork, info

    real intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    real intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=max(3*n-1,1)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    real  intent(hide),dimension(lwork),depend(lwork) :: work

    real intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine ssygv


subroutine dsygv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,info)
    ! Generalized Symmetric Eigenvalue Problem
    ! Real - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs returned
    ! if jobz = 'V' 'a' contains eigvecs

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*
    !                itype,jobz ,uplo , n  ,    a    ,lda ,    b    , ldb,   w     , work   ,lwork, info

    double precision intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    double precision intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=max(3*n-1,1)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    double precision  intent(hide),dimension(lwork),depend(lwork) :: work

    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine dsygv



subroutine ssygv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
    ! LWORK routine for (S,D)SYGV

    fortranname ssygv
    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    ! Inputs
    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U' || *uplo=='L') :: uplo='L'
    ! Not referenced
    integer intent(hide) :: itype=1
    character intent(hide) :: jobz="N"
    real intent(hide) :: a
    real intent(hide) :: b
    integer intent(hide) :: lda=max(1,n)
    integer intent(hide) :: ldb=max(1,n)
    integer intent(hide) :: lwork=-1
    real intent(hide) :: w
    ! Outputs
    real intent(out) :: work
    integer intent(out) :: info

end subroutine ssygv_lwork


subroutine dsygv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
    ! LWORK routine for (S,D)SYGV

    fortranname dsygv
    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    ! Inputs
    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U' || *uplo=='L') :: uplo='L'
    ! Not referenced
    integer intent(hide) :: itype=1
    character intent(hide) :: jobz="N"
    double precision intent(hide) :: a
    double precision intent(hide) :: b
    integer intent(hide) :: lda=max(1,n)
    integer intent(hide) :: ldb=max(1,n)
    integer intent(hide) :: lwork=-1
    double precision intent(hide) :: w
    ! Outputs
    double precision intent(out) :: work
    integer intent(out) :: info

end subroutine dsygv_lwork



subroutine chegv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,info)
    ! Generalized Symmetric Eigenvalue Problem
    ! Complex - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs returned
    ! if jobz = 'V' 'a' contains eigvecs

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*
    !                itype,jobz ,uplo , n  ,    a     ,lda ,    b     , ldb,   w     , work     ,lwork,rwork   ,info

    complex intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    complex intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=max(2*n-1,1)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    complex intent(hide),dimension(lwork),depend(lwork) :: work
    real intent(hide),dimension(MAX(1,3*n-2)),depend(n) :: rwork

    real intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine chegv


subroutine zhegv(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,info)
    ! Generalized Symmetric Eigenvalue Problem
    ! Complex - Single precision / Double precision
    !
    ! if jobz = 'N' there are no eigvecs returned
    ! if jobz = 'V' 'a' contains eigvecs

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*
    !                itype,jobz ,uplo , n  ,    a     ,lda ,    b     , ldb,   w     , work     ,lwork,rwork   ,info

    double complex intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    double complex intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=max(2*n-1,1)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    double complex intent(hide),dimension(lwork),depend(lwork) :: work
    double precision intent(hide),dimension(MAX(1,3*n-2)),depend(n) :: rwork

    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine zhegv



subroutine chegv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info)
    ! LWORK Query routine for (c/z)hegv

    fortranname chegv
    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&rwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*

    ! Inputs
    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U' || *uplo=='L') :: uplo='L'
    ! Not referenced
    integer intent(hide) :: itype=1
    character intent(hide) :: jobz="N"
    complex intent(hide) :: a
    complex intent(hide) :: b
    integer intent(hide),depend(n) :: lda=MAX(1,n)
    integer intent(hide),depend(n) :: ldb=MAX(1,n)
    integer intent(hide) :: lwork=-1
    real intent(hide) :: w
    real intent(hide) :: rwork
    ! Outputs
    complex intent(out) :: work
    integer intent(out) :: info

end subroutine chegv_lwork


subroutine zhegv_lwork(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info)
    ! LWORK Query routine for (c/z)hegv

    fortranname zhegv
    callstatement (*f2py_func)(&itype,jobz,uplo,&n,&a,&lda,&b,&ldb,&w,&work,&lwork,&rwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*

    ! Inputs
    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U' || *uplo=='L') :: uplo='L'
    ! Not referenced
    integer intent(hide) :: itype=1
    character intent(hide) :: jobz="N"
    double complex intent(hide) :: a
    double complex intent(hide) :: b
    integer intent(hide),depend(n) :: lda=MAX(1,n)
    integer intent(hide),depend(n) :: ldb=MAX(1,n)
    integer intent(hide) :: lwork=-1
    double precision intent(hide) :: w
    double precision intent(hide) :: rwork
    ! Outputs
    double complex intent(out) :: work
    integer intent(out) :: info

end subroutine zhegv_lwork



!
! Divide and conquer routines for generalized eigenvalue problem
!
subroutine ssygvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,iwork,liwork,info)

    ! No call to ILAENV is performed. Hence no need for (d/s)sygvd_lwork. Default sizes are optimal.

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    real intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    real intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=(*jobz=='N'?2*n+1:1+6*n+2*n*n)
    integer optional,intent(in),depend(n),check(liwork>0||liwork==-1) :: liwork=(*jobz=='N'?1:5*n+3)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    real intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    real intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine ssygvd

subroutine dsygvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,iwork,liwork,info)

    ! No call to ILAENV is performed. Hence no need for (d/s)sygvd_lwork. Default sizes are optimal.

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    double precision intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    double precision intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=(*jobz=='N'?2*n+1:1+6*n+2*n*n)
    integer optional,intent(in),depend(n),check(liwork>0||liwork==-1) :: liwork=(*jobz=='N'?1:5*n+3)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    double precision intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine dsygvd



subroutine chegvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,lrwork,iwork,liwork,info)

    ! No call to ILAENV is performed. Hence no need for (c/z)hegvd_lwork. Default sizes are optimal.

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    complex intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    complex intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=(*jobz=='N'?n+1:n*(n+2))
    integer optional,intent(in),depend(n),check(lrwork>0||lrwork==-1) :: lrwork=max((*jobz=='N'?n:2*n*n+5*n+1),1)
    integer optional,intent(in),depend(n),check(liwork>0||liwork==-1) :: liwork=(*jobz=='N'?1:5*n+3)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    complex intent(hide),dimension(lwork),depend(lwork) :: work
    real intent(hide),dimension(lrwork),depend(lrwork) :: rwork
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    real intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine chegvd


subroutine zhegvd(itype,jobz,uplo,n,lda,ldb,w,a,b,work,lwork,rwork,lrwork,iwork,liwork,info)

    ! No call to ILAENV is performed. Hence no need for (c/z)hegvd_lwork. Default sizes are optimal.

    callstatement (*f2py_func)(&itype,jobz,uplo,&n,a,&lda,b,&ldb,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument F_INT*,char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    double complex intent(in,copy,aligned8,out,out=v),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    double complex intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer optional,intent(in),check(itype > 0 || itype < 4) :: itype = 1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    integer optional,intent(in),depend(n),check(lwork>0||lwork==-1) :: lwork=(*jobz=='N'?n+1:n*(n+2))
    integer optional,intent(in),depend(n),check(lrwork>0||lrwork==-1) :: lrwork=max((*jobz=='N'?n:2*n*n+5*n+1),1)
    integer optional,intent(in),depend(n),check(liwork>0||liwork==-1) :: liwork=(*jobz=='N'?1:5*n+3)

    integer intent(hide),depend(a) :: n=shape(a,0)
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(b) :: ldb=max(1,shape(b,0))
    double complex intent(hide),dimension(lwork),depend(lwork) :: work
    double precision intent(hide),dimension(lrwork),depend(lrwork) :: rwork
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: info

end subroutine zhegvd



!
! Expert routines for generalized eigenvalue problem
!
subroutine ssygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info)
    ! (S/D)SYGVX computes selected eigenvalues, and optionally, eigenvectors
    ! of a real generalized symmetric-definite eigenproblem, of the form
    ! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
    ! and B are assumed to be symmetric and B is also positive definite.
    ! Eigenvalues and eigenvectors can be selected by specifying either a
    ! range of values or a range of indices for the desired eigenvalues.

    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(itype>0||itype<4) :: itype=1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz="V"
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo="L"
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range="A"
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    real optional,intent(in) :: vl=0.0
    real optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    real intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(8*n,1)

    real intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    real intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    integer intent(hide),depend(b) :: ldb=MAX(1,shape(b,0))
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    real  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork

    real intent(out),dimension(n),depend(n) :: w
    real intent(out),dimension((jobz[0]=='V'?MAX(0,n):0),(jobz[0]=='V'?((range[0]=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,jobz,range,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension((jobz[0]=='N'?0:n)),depend(jobz,n):: ifail
    integer intent(out) :: info

end subroutine ssygvx

subroutine dsygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,iwork,ifail,info)
    ! (S/D)SYGVX computes selected eigenvalues, and optionally, eigenvectors
    ! of a real generalized symmetric-definite eigenproblem, of the form
    ! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A
    ! and B are assumed to be symmetric and B is also positive definite.
    ! Eigenvalues and eigenvectors can be selected by specifying either a
    ! range of values or a range of indices for the desired eigenvalues.

    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,iwork,ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(itype>0||itype<4) :: itype=1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz="V"
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo="L"
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range="A"
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    double precision optional,intent(in) :: vl=0.0
    double precision optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    double precision intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(8*n,1)

    double precision intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    double precision intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    integer intent(hide),depend(b) :: ldb=MAX(1,shape(b,0))
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    double precision  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork

    double precision intent(out),dimension(n),depend(n) :: w
    double precision intent(out),dimension((jobz[0]=='V'?MAX(0,n):0),(jobz[0]=='V'?((range[0]=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,jobz,range,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension((jobz[0]=='N'?0:n)),depend(jobz,n):: ifail
    integer intent(out) :: info

end subroutine dsygvx



subroutine ssygvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! LWORK Query routine for (s/d)sygvx
    fortranname ssygvx
    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'

    integer intent(hide):: itype = 1
    real intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    real intent(hide):: b
    integer intent(hide):: ldb = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    real intent(hide):: vl = 0.0
    real intent(hide):: vu = 1.0
    real intent(hide):: abstol = 0.0
    integer intent(hide):: m
    real intent(hide):: w
    real intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    integer intent(hide):: iwork
    integer intent(hide):: ifail

    real intent(out):: work
    integer intent(out):: info

end subroutine ssygvx_lwork


subroutine dsygvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! LWORK Query routine for (s/d)sygvx
    fortranname dsygvx
    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&iwork,&ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'

    integer intent(hide):: itype = 1
    double precision intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    double precision intent(hide):: b
    integer intent(hide):: ldb = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    double precision intent(hide):: vl = 0.0
    double precision intent(hide):: vu = 1.0
    double precision intent(hide):: abstol = 0.0
    integer intent(hide):: m
    double precision intent(hide):: w
    double precision intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    integer intent(hide):: iwork
    integer intent(hide):: ifail

    double precision intent(out):: work
    integer intent(out):: info

end subroutine dsygvx_lwork



subroutine chegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info)
    ! (C/Z)HEGVX computes selected eigenvalues, and optionally, eigenvectors
    ! of a complex generalized Hermitian-definite eigenproblem, of the form
    ! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
    ! B are assumed to be Hermitian and B is also positive definite.
    ! Eigenvalues and eigenvectors can be selected by specifying either a
    ! range of values or a range of indices for the desired eigenvalues.
    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(itype>0||itype<4) :: itype=1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    real optional,intent(in) :: vl=0.0
    real optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    real intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(2*n,1)

    complex intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    complex intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(n) :: ldb=max(1,n)
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    complex  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork
    real intent(hide),dimension(7*n),depend(n) :: rwork

    real intent(out),dimension(n),depend(n) :: w
    complex intent(out),dimension((jobz[0]=='V'?MAX(0,n):0),(jobz[0]=='V'?((range[0]=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,jobz,range,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension((jobz[0]=='N'?0:n)),depend(jobz,n):: ifail
    integer intent(out) :: info

end subroutine chegvx


subroutine zhegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,w,z,m,ldz,work,lwork,rwork,iwork,ifail,info)
    ! (C/Z)HEGVX computes selected eigenvalues, and optionally, eigenvectors
    ! of a complex generalized Hermitian-definite eigenproblem, of the form
    ! A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and
    ! B are assumed to be Hermitian and B is also positive definite.
    ! Eigenvalues and eigenvectors can be selected by specifying either a
    ! range of values or a range of indices for the desired eigenvalues.
    callstatement (*f2py_func)(&itype,jobz,range,uplo,&n,a,&lda,b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,&lwork,rwork,iwork,ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*
    
    integer optional,intent(in),check(itype>0||itype<4) :: itype=1
    character optional,intent(in),check(*jobz=='N'||*jobz=='V') :: jobz='V'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'
    character optional,intent(in),check(*range=='A'||*range=='V' ||*range=='I') :: range='A'
    integer intent(hide),depend(a) :: n=shape(a,0)
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    double precision optional,intent(in) :: vl=0.0
    double precision optional,intent(in),check(vu>vl),depend(vl) :: vu=1.0
    double precision intent(in) :: abstol=0.0
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1) :: lwork=max(2*n,1)

    double complex intent(in,copy),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    double complex intent(in,copy,aligned8),check(shape(b,0)==shape(b,1)),check(shape(b,0)==n),dimension(n,n),depend(n) :: b
    integer intent(hide),depend(n) :: lda=max(1,n)
    integer intent(hide),depend(n) :: ldb=max(1,n)
    integer intent(hide),depend(z) :: ldz=max(1,shape(z,0))
    double complex  intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(5*n),depend(n) :: iwork
    double precision intent(hide),dimension(7*n),depend(n) :: rwork

    double precision intent(out),dimension(n),depend(n) :: w
    double complex intent(out),dimension((jobz[0]=='V'?MAX(0,n):0),(jobz[0]=='V'?((range[0]=='I')?(iu-il+1):MAX(1,n)):0)),depend(n,jobz,range,iu,il) :: z
    integer intent(out) :: m
    integer intent(out),dimension((jobz[0]=='N'?0:n)),depend(jobz,n):: ifail
    integer intent(out) :: info

end subroutine zhegvx



subroutine chegvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! LWORK Query routine for (c/z)hegvx
    fortranname chegvx
    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'

    integer intent(hide):: itype = 1
    complex intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    complex intent(hide):: b
    integer intent(hide):: ldb = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    real intent(hide):: vl = 0.0
    real intent(hide):: vu = 1.0
    real intent(hide):: abstol = 0.0
    integer intent(hide):: m
    real intent(hide):: w
    complex intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    real intent(hide):: rwork
    integer intent(hide):: iwork
    integer intent(hide):: ifail

    complex intent(out):: work
    integer intent(out):: info

end subroutine chegvx_lwork


subroutine zhegvx_lwork(itype,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! LWORK Query routine for (c/z)hegvx
    fortranname zhegvx
    callstatement (*f2py_func)(&itype,"N","A",uplo,&n,&a,&lda,&b,&ldb,&vl,&vu,&il,&iu,&abstol,&m,&w,&z,&ldz,&work,&lwork,&rwork,&iwork,&ifail,&info)
    callprotoargument F_INT*,char*,char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in):: n
    character optional,intent(in),check(*uplo=='U'||*uplo=='L') :: uplo='L'

    integer intent(hide):: itype = 1
    double complex intent(hide):: a
    integer intent(hide),depend(n):: lda = MAX(1,n)
    double complex intent(hide):: b
    integer intent(hide):: ldb = MAX(1,n)
    integer intent(hide):: il = 1
    integer intent(hide):: iu = 0
    double precision intent(hide):: vl = 0.0
    double precision intent(hide):: vu = 1.0
    double precision intent(hide):: abstol = 0.0
    integer intent(hide):: m
    double precision intent(hide):: w
    double complex intent(hide):: z
    integer intent(hide),depend(n):: ldz = MAX(1,n)
    integer intent(hide):: lwork = -1
    double precision intent(hide):: rwork
    integer intent(hide):: iwork
    integer intent(hide):: ifail

    double complex intent(out):: work
    integer intent(out):: info

end subroutine zhegvx_lwork



subroutine ssyequb(lower,n,a,lda,s,scond,amax,work,info)

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*

    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
    ! See https://github.com/Reference-LAPACK/lapack/pull/61 for the reason for 3*n
    real intent(hide,cache),depend(n),dimension(3*n) :: work

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    real intent(in),dimension(lda,n),check(shape(a,0)==shape(a,1)) :: a
    real intent(out),dimension(n),depend(n) :: s
    real intent(out) :: scond
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine ssyequb


subroutine dsyequb(lower,n,a,lda,s,scond,amax,work,info)

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*

    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
    ! See https://github.com/Reference-LAPACK/lapack/pull/61 for the reason for 3*n
    double precision intent(hide,cache),depend(n),dimension(3*n) :: work

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    double precision intent(in),dimension(lda,n),check(shape(a,0)==shape(a,1)) :: a
    double precision intent(out),dimension(n),depend(n) :: s
    double precision intent(out) :: scond
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine dsyequb


subroutine csyequb(lower,n,a,lda,s,scond,amax,work,info)

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,F_INT*

    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
    ! See https://github.com/Reference-LAPACK/lapack/pull/61 for the reason for 3*n
    complex intent(hide,cache),depend(n),dimension(3*n) :: work

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    complex intent(in),dimension(lda,n),check(shape(a,0)==shape(a,1)) :: a
    real intent(out),dimension(n),depend(n) :: s
    real intent(out) :: scond
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine csyequb


subroutine zsyequb(lower,n,a,lda,s,scond,amax,work,info)

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,F_INT*

    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
    ! See https://github.com/Reference-LAPACK/lapack/pull/61 for the reason for 3*n
    double complex intent(hide,cache),depend(n),dimension(3*n) :: work

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    double complex intent(in),dimension(lda,n),check(shape(a,0)==shape(a,1)) :: a
    double precision intent(out),dimension(n),depend(n) :: s
    double precision intent(out) :: scond
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine zsyequb



subroutine cheequb(lower,n,a,lda,s,scond,amax,work,info)

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,F_INT*

    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
    ! See https://github.com/Reference-LAPACK/lapack/pull/61 for the reason for 3*n
    complex intent(hide,cache),depend(n),dimension(3*n) :: work

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    complex intent(in),dimension(lda,n),check(shape(a,0)==shape(a,1)) :: a
    real intent(out),dimension(n),depend(n) :: s
    real intent(out) :: scond
    real intent(out) :: amax
    integer intent(out) :: info

end subroutine cheequb


subroutine zheequb(lower,n,a,lda,s,scond,amax,work,info)

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,s,&scond,&amax,work,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,F_INT*

    integer intent(hide),depend(a) :: n = shape(a,1)
    integer intent(hide),depend(a) :: lda = MAX(1,shape(a,0))
    ! See https://github.com/Reference-LAPACK/lapack/pull/61 for the reason for 3*n
    double complex intent(hide,cache),depend(n),dimension(3*n) :: work

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    double complex intent(in),dimension(lda,n),check(shape(a,0)==shape(a,1)) :: a
    double precision intent(out),dimension(n),depend(n) :: s
    double precision intent(out) :: scond
    double precision intent(out) :: amax
    integer intent(out) :: info

end subroutine zheequb


! Signatures for f2py-wrappers of FORTRAN LAPACK Positive Definite Matrix functions.
!

subroutine spstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstrf(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric/hermitian positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,F_INT*,float*,float*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    real optional, intent(in) :: tol = -1.0
    real intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine spstrf


subroutine dpstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstrf(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric/hermitian positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,F_INT*,double*,double*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    double precision optional, intent(in) :: tol = -1.0
    double precision intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine dpstrf


subroutine cpstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstrf(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric/hermitian positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,float*,float*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    real optional, intent(in) :: tol = -1.0
    real intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine cpstrf


subroutine zpstrf(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstrf(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric/hermitian positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,double*,double*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    double precision optional, intent(in) :: tol = -1.0
    double precision intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine zpstrf




subroutine spstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstf2(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*,F_INT*,float*,float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    real optional,intent(in) :: tol = -1.0
    real intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine spstf2



subroutine dpstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstf2(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*,F_INT*,double*,double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    double precision optional,intent(in) :: tol = -1.0
    double precision intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine dpstf2



subroutine cpstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstf2(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,float*,float*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    real optional,intent(in) :: tol = -1.0
    real intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine cpstf2



subroutine zpstf2(n,a,lda,piv,rank_c,tol,work,info,lower)
    ! c,x,info = pstf2(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive semidefinite
    ! P**T * A * P = U**T * U ,  if UPLO = 'U',
    ! P**T * A * P = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular, and
    ! P is stored as vector PIV.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,piv,&rank_c,&tol,work,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,double*,double*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer intent(hide),depend(a) :: lda=max(1,shape(a, 0))
    integer intent(out),dimension(n),depend(n) :: piv
    integer intent(out) :: rank_c
    double precision optional,intent(in) :: tol = -1.0
    double precision intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info
end subroutine zpstf2




subroutine sposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    real dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine sposv



subroutine dposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    double precision dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine dposv



subroutine cposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine cposv



subroutine zposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    double complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine zposv



subroutine sposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,char*,float*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    real optional,dimension(n),depend(n),intent(in,out):: s
    real dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    real dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    real intent(hide),dimension(3*n),depend(n):: work
    integer intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine sposvx


subroutine dposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,char*,double*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    double precision optional,dimension(n),depend(n),intent(in,out):: s
    double precision dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double precision dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double precision intent(hide),dimension(3*n),depend(n):: work
    integer intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine dposvx


subroutine cposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,char*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,float*,complex_float*,float*,F_INT*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    complex optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    real optional,dimension(n),depend(n),intent(in,out):: s
    complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    complex intent(hide),dimension(2*n),depend(n):: work
    real intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine cposvx


subroutine zposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,char*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,double*,complex_double*,double*,F_INT*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double complex optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    double precision optional,dimension(n),depend(n),intent(in,out):: s
    double complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double complex intent(hide),dimension(2*n),depend(n):: work
    double precision intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine zposvx



subroutine spocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,float*,float*,float*,F_INT*,F_INT*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    real depend(n),dimension(3*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine spocon


subroutine dpocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,double*,double*,double*,F_INT*,F_INT*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double precision depend(n),dimension(3*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine dpocon


subroutine cpocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,float*,float*,complex_float*,float*,F_INT*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    complex depend(n),dimension(2*n),intent(hide,cache):: work
    real depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine cpocon


subroutine zpocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,double*,double*,complex_double*,double*,F_INT*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double complex depend(n),dimension(2*n),intent(hide,cache):: work
    double precision depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine zpocon


 
subroutine spotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){F_INT i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;}}
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide) :: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine spotrf

 
subroutine dpotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){F_INT i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;}}
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide) :: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine dpotrf


 
subroutine cpotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){F_INT i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}}}
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine cpotrf

 
subroutine zpotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){F_INT i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}}}
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine zpotrf


 
subroutine spotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    real dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine spotrs

 
subroutine dpotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    double precision dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine dpotrs

 
subroutine cpotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine cpotrs

 
subroutine zpotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    double complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine zpotrs


 
subroutine spotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    real dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine spotri

 
subroutine dpotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    double precision dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine dpotri

 
subroutine cpotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    complex dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine cpotri

 
subroutine zpotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    double complex dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine zpotri


! Signatures for f2py-wrappers of FORTRAN LAPACK Positive Definite Tridiagonal Matrix functions.
!

subroutine sptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument F_INT*, F_INT*, float*, float*, float*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real dimension(n), intent(in,out,copy) :: d
    real dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    real dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine sptsv


subroutine dptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument F_INT*, F_INT*, double*, double*, double*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision dimension(n), intent(in,out,copy) :: d
    double precision dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    double precision dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine dptsv


subroutine cptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument F_INT*, F_INT*, float*, complex_float*, complex_float*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real dimension(n), intent(in,out,copy) :: d
    complex dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine cptsv


subroutine zptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument F_INT*, F_INT*, double*, complex_double*, complex_double*, F_INT*, F_INT*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision dimension(n), intent(in,out,copy) :: d
    double complex dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    double complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine zptsv




subroutine spttrf(n, d, e, info)
    ! d, e, info  = pttrf(d, e, overwrite_d=0, overwrite_e=0)
    !
    ! ?PTTRF computes the L*D*L**T factorization of a symmetric positive
    ! definite tridiagonal matrix A.  The factorization may also be regarded
    ! as ! having the form A = U**T*D*U.

    callstatement (*f2py_func)(&n, d, e, &info)
    callprotoargument F_INT*, float*, float*, F_INT*

    integer intent(hide), depend(d) :: n = len(d)
    real intent(in, out, copy), dimension(n) :: d
    real intent(in, out, copy), dimension((n>0?n-1:0)), depend(n) :: e
    integer intent(out) :: info

end subroutine spttrf



subroutine dpttrf(n, d, e, info)
    ! d, e, info  = pttrf(d, e, overwrite_d=0, overwrite_e=0)
    !
    ! ?PTTRF computes the L*D*L**T factorization of a symmetric positive
    ! definite tridiagonal matrix A.  The factorization may also be regarded
    ! as ! having the form A = U**T*D*U.

    callstatement (*f2py_func)(&n, d, e, &info)
    callprotoargument F_INT*, double*, double*, F_INT*

    integer intent(hide), depend(d) :: n = len(d)
    double precision intent(in, out, copy), dimension(n) :: d
    double precision intent(in, out, copy), dimension((n>0?n-1:0)), depend(n) :: e
    integer intent(out) :: info

end subroutine dpttrf



subroutine cpttrf(n, d, e, info)
    ! d, e, info  = pttrf(d, e, overwrite_d=0, overwrite_e=0)
    !
    ! ?PTTRF computes the L*D*L**T factorization of a symmetric positive
    ! definite tridiagonal matrix A.  The factorization may also be regarded
    ! as ! having the form A = U**T*D*U.

    callstatement (*f2py_func)(&n, d, e, &info)
    callprotoargument F_INT*, float*, complex_float*, F_INT*

    integer intent(hide), depend(d) :: n = len(d)
    real intent(in, out, copy), dimension(n) :: d
    complex intent(in, out, copy), dimension((n>0?n-1:0)), depend(n) :: e
    integer intent(out) :: info

end subroutine cpttrf



subroutine zpttrf(n, d, e, info)
    ! d, e, info  = pttrf(d, e, overwrite_d=0, overwrite_e=0)
    !
    ! ?PTTRF computes the L*D*L**T factorization of a symmetric positive
    ! definite tridiagonal matrix A.  The factorization may also be regarded
    ! as ! having the form A = U**T*D*U.

    callstatement (*f2py_func)(&n, d, e, &info)
    callprotoargument F_INT*, double*, complex_double*, F_INT*

    integer intent(hide), depend(d) :: n = len(d)
    double precision intent(in, out, copy), dimension(n) :: d
    double complex intent(in, out, copy), dimension((n>0?n-1:0)), depend(n) :: e
    integer intent(out) :: info

end subroutine zpttrf




subroutine spttrs(n, nrhs, d, e, b, ldb, info)
    ! x, info  = pttrs(d, e, b, overwrite_b=0)
    !
    ! DPTTRS solves a tridiagonal system of the form
    !
    !     A * X = B
    !
    ! using the L*D*L**T factorization of A computed by DPTTRF.  D is a
    ! diagonal matrix specified in the vector D, L is a unit bidiagonal
    ! matrix whose subdiagonal is specified in the vector E, and X and B
    ! are N by NRHS matrices.

    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &ldb, &info)
    callprotoargument F_INT*, F_INT*, float*, float*, float*, F_INT*, F_INT*

    integer intent(hide), depend(d) :: n = len(d)
    real intent(in), dimension(n) :: d
    real intent(in), dimension((n>0?n-1:0)), depend(n) :: e
    real intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(hide), depend(b) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b)  :: nrhs = shape(b, 1)
    integer intent(out) :: info

end subroutinespttrs



subroutine dpttrs(n, nrhs, d, e, b, ldb, info)
    ! x, info  = pttrs(d, e, b, overwrite_b=0)
    !
    ! DPTTRS solves a tridiagonal system of the form
    !
    !     A * X = B
    !
    ! using the L*D*L**T factorization of A computed by DPTTRF.  D is a
    ! diagonal matrix specified in the vector D, L is a unit bidiagonal
    ! matrix whose subdiagonal is specified in the vector E, and X and B
    ! are N by NRHS matrices.

    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &ldb, &info)
    callprotoargument F_INT*, F_INT*, double*, double*, double*, F_INT*, F_INT*

    integer intent(hide), depend(d) :: n = len(d)
    double precision intent(in), dimension(n) :: d
    double precision intent(in), dimension((n>0?n-1:0)), depend(n) :: e
    double precision intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(hide), depend(b) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b)  :: nrhs = shape(b, 1)
    integer intent(out) :: info

end subroutinedpttrs




subroutine cpttrs(lower, n, nrhs, d, e, b, ldb, info)
    ! x, info  = pttrs(d, e, b, lower=0, overwrite_b=0)
    !
    ! ?PTTRS solves a tridiagonal system of the form
    !
    !     A * X = B
    !
    ! using the L*D*L**T factorization of A computed by DPTTRF.  D is a
    ! diagonal matrix specified in the vector D, L is a unit bidiagonal
    ! matrix whose subdiagonal is specified in the vector E, and X and B
    ! are N by NRHS matrices.

    callstatement (*f2py_func)((lower?"L":"U"), &n, &nrhs, d, e, b, &ldb, &info)
    callprotoargument char*, F_INT*, F_INT*, float*, complex_float*, complex_float*, F_INT*, F_INT*

    integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
    integer intent(hide), depend(d) :: n = len(d)
    real intent(in), dimension(n) :: d
    complex intent(in), dimension((n>0?n-1:0)), depend(n) :: e
    complex intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(hide), depend(b) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b)  :: nrhs = shape(b, 1)
    integer intent(out) :: info

end subroutinecpttrs



subroutine zpttrs(lower, n, nrhs, d, e, b, ldb, info)
    ! x, info  = pttrs(d, e, b, lower=0, overwrite_b=0)
    !
    ! ?PTTRS solves a tridiagonal system of the form
    !
    !     A * X = B
    !
    ! using the L*D*L**T factorization of A computed by DPTTRF.  D is a
    ! diagonal matrix specified in the vector D, L is a unit bidiagonal
    ! matrix whose subdiagonal is specified in the vector E, and X and B
    ! are N by NRHS matrices.

    callstatement (*f2py_func)((lower?"L":"U"), &n, &nrhs, d, e, b, &ldb, &info)
    callprotoargument char*, F_INT*, F_INT*, double*, complex_double*, complex_double*, F_INT*, F_INT*

    integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
    integer intent(hide), depend(d) :: n = len(d)
    double precision intent(in), dimension(n) :: d
    double complex intent(in), dimension((n>0?n-1:0)), depend(n) :: e
    double complex intent(in, out, copy, out=x), dimension(ldb, nrhs) :: b
    integer intent(hide), depend(b) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b)  :: nrhs = shape(b, 1)
    integer intent(out) :: info

end subroutinezpttrs




subroutine spteqr(compute_z, n, d, e, z, ldz, work, info)
    ! d, e, z, work, info  = pteqr(d, e, z, compute_z=0, overwrite_d=0, overwrite_e=0, overwrite_z=0)
    ! ?PTEQR computes all eigenvalues and, optionally, eigenvectors of a
    ! symmetric positive definite tridiagonal matrix.
    !
    ! This routine computes the eigenvalues of the positive definite
    ! tridiagonal matrix to high relative accuracy.  This means that if the
    ! eigenvalues range over many orders of magnitude in size, then the
    ! small eigenvalues and corresponding eigenvectors will be computed
    ! more accurately than, for example, with the standard QR method.
    !
    ! The eigenvectors of a full or band positive definite Hermitian matrix
    ! can also be found if ?HETRD, ?HPTRD, or ?HBTRD has been used to
    ! reduce this matrix to tridiagonal form.  (The reduction to
    ! tridiagonal form, however, may preclude the possibility of obtaining
    ! high relative accuracy in the small eigenvalues of the original
    ! matrix, if these eigenvalues range over many orders of magnitude.)
    callstatement (*f2py_func)((compute_z?(compute_z==2?"I":"V"):"N"), &n, d, e, z, &ldz, work, &info)
    callprotoargument char*, F_INT*, float*, float*, float*, F_INT*, float*, F_INT*
    integer intent(in, optional), check((compute_z>=0) && (compute_z<=2)) :: compute_z = 0
    integer intent(hide), depend(d) :: n = len(d)
    real intent(in,out,copy), dimension(n) :: d
    real intent(in,out,copy), depend(n), dimension((n>0?n-1:0)) :: e
    real intent(in,out,copy), depend(n), dimension((compute_z==0?shape(z, 0):max(1,n)),(compute_z==0?shape(z, 1):n)) :: z
    integer intent(hide), depend(z,n,compute_z) :: ldz = (compute_z==0)?1:max(1, shape(z, 0))
    real intent(hide), dimension(4*n) :: work
    integer intent(out) :: info

end subroutine spteqr



subroutine dpteqr(compute_z, n, d, e, z, ldz, work, info)
    ! d, e, z, work, info  = pteqr(d, e, z, compute_z=0, overwrite_d=0, overwrite_e=0, overwrite_z=0)
    ! ?PTEQR computes all eigenvalues and, optionally, eigenvectors of a
    ! symmetric positive definite tridiagonal matrix.
    !
    ! This routine computes the eigenvalues of the positive definite
    ! tridiagonal matrix to high relative accuracy.  This means that if the
    ! eigenvalues range over many orders of magnitude in size, then the
    ! small eigenvalues and corresponding eigenvectors will be computed
    ! more accurately than, for example, with the standard QR method.
    !
    ! The eigenvectors of a full or band positive definite Hermitian matrix
    ! can also be found if ?HETRD, ?HPTRD, or ?HBTRD has been used to
    ! reduce this matrix to tridiagonal form.  (The reduction to
    ! tridiagonal form, however, may preclude the possibility of obtaining
    ! high relative accuracy in the small eigenvalues of the original
    ! matrix, if these eigenvalues range over many orders of magnitude.)
    callstatement (*f2py_func)((compute_z?(compute_z==2?"I":"V"):"N"), &n, d, e, z, &ldz, work, &info)
    callprotoargument char*, F_INT*, double*, double*, double*, F_INT*, double*, F_INT*
    integer intent(in, optional), check((compute_z>=0) && (compute_z<=2)) :: compute_z = 0
    integer intent(hide), depend(d) :: n = len(d)
    double precision intent(in,out,copy), dimension(n) :: d
    double precision intent(in,out,copy), depend(n), dimension((n>0?n-1:0)) :: e
    double precision intent(in,out,copy), depend(n), dimension((compute_z==0?shape(z, 0):max(1,n)),(compute_z==0?shape(z, 1):n)) :: z
    integer intent(hide), depend(z,n,compute_z) :: ldz = (compute_z==0)?1:max(1, shape(z, 0))
    double precision intent(hide), dimension(4*n) :: work
    integer intent(out) :: info

end subroutine dpteqr



subroutine cpteqr(compute_z, n, d, e, z, ldz, work, info)
    ! d, e, z, work, info  = pteqr(d, e, z, compute_z=0, overwrite_d=0, overwrite_e=0, overwrite_z=0)
    ! ?PTEQR computes all eigenvalues and, optionally, eigenvectors of a
    ! symmetric positive definite tridiagonal matrix.
    !
    ! This routine computes the eigenvalues of the positive definite
    ! tridiagonal matrix to high relative accuracy.  This means that if the
    ! eigenvalues range over many orders of magnitude in size, then the
    ! small eigenvalues and corresponding eigenvectors will be computed
    ! more accurately than, for example, with the standard QR method.
    !
    ! The eigenvectors of a full or band positive definite Hermitian matrix
    ! can also be found if ?HETRD, ?HPTRD, or ?HBTRD has been used to
    ! reduce this matrix to tridiagonal form.  (The reduction to
    ! tridiagonal form, however, may preclude the possibility of obtaining
    ! high relative accuracy in the small eigenvalues of the original
    ! matrix, if these eigenvalues range over many orders of magnitude.)
    callstatement (*f2py_func)((compute_z?(compute_z==2?"I":"V"):"N"), &n, d, e, z, &ldz, work, &info)
    callprotoargument char*, F_INT*, float*, float*, complex_float*, F_INT*, float*, F_INT*
    integer intent(in, optional), check((compute_z>=0) && (compute_z<=2)) :: compute_z = 0
    integer intent(hide), depend(d) :: n = len(d)
    real intent(in,out,copy), dimension(n) :: d
    real intent(in,out,copy), depend(n), dimension((n>0?n-1:0)) :: e
    complex intent(in,out,copy), depend(n), dimension((compute_z==0?shape(z, 0):max(1,n)),(compute_z==0?shape(z, 1):n)) :: z
    integer intent(hide), depend(z,n,compute_z) :: ldz = (compute_z==0)?1:max(1, shape(z, 0))
    real intent(hide), dimension(4*n) :: work
    integer intent(out) :: info

end subroutine cpteqr



subroutine zpteqr(compute_z, n, d, e, z, ldz, work, info)
    ! d, e, z, work, info  = pteqr(d, e, z, compute_z=0, overwrite_d=0, overwrite_e=0, overwrite_z=0)
    ! ?PTEQR computes all eigenvalues and, optionally, eigenvectors of a
    ! symmetric positive definite tridiagonal matrix.
    !
    ! This routine computes the eigenvalues of the positive definite
    ! tridiagonal matrix to high relative accuracy.  This means that if the
    ! eigenvalues range over many orders of magnitude in size, then the
    ! small eigenvalues and corresponding eigenvectors will be computed
    ! more accurately than, for example, with the standard QR method.
    !
    ! The eigenvectors of a full or band positive definite Hermitian matrix
    ! can also be found if ?HETRD, ?HPTRD, or ?HBTRD has been used to
    ! reduce this matrix to tridiagonal form.  (The reduction to
    ! tridiagonal form, however, may preclude the possibility of obtaining
    ! high relative accuracy in the small eigenvalues of the original
    ! matrix, if these eigenvalues range over many orders of magnitude.)
    callstatement (*f2py_func)((compute_z?(compute_z==2?"I":"V"):"N"), &n, d, e, z, &ldz, work, &info)
    callprotoargument char*, F_INT*, double*, double*, complex_double*, F_INT*, double*, F_INT*
    integer intent(in, optional), check((compute_z>=0) && (compute_z<=2)) :: compute_z = 0
    integer intent(hide), depend(d) :: n = len(d)
    double precision intent(in,out,copy), dimension(n) :: d
    double precision intent(in,out,copy), depend(n), dimension((n>0?n-1:0)) :: e
    double complex intent(in,out,copy), depend(n), dimension((compute_z==0?shape(z, 0):max(1,n)),(compute_z==0?shape(z, 1):n)) :: z
    integer intent(hide), depend(z,n,compute_z) :: ldz = (compute_z==0)?1:max(1, shape(z, 0))
    double precision intent(hide), dimension(4*n) :: work
    integer intent(out) :: info

end subroutine zpteqr




subroutine sptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, info)
    ! DPTSVX uses the factorization A = L*D*L**T to compute the solution
    ! to a real system of linear equations A*X = B, where A is an N-by-N
    ! symmetric positive definite tridiagonal matrix and X and B are
    !N-by-NRHS matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    ! provided.
    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, &info)
    callprotoargument char*, F_INT*, F_INT*, float*, float*, float*, float*, float*, F_INT*, float*, F_INT*,  float*, float*, float*, float*, F_INT*

    character optional, intent(in) :: fact = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real intent(in), dimension(n) :: d
    real intent(in), depend(n), dimension(max(0, n-1)) :: e
    real optional, intent(in,out), depend(n), dimension(n) :: df
    real optional, intent(in,out), depend(n), dimension(max(0, n-1)) :: ef
    real intent(in), depend(n), dimension(ldb, nrhs), check(shape(b, 0) >= n):: b
    integer intent(hide), depend(b) :: ldb = max(1, shape(b, 0))
    real intent(out), dimension(ldx, nrhs) :: x
    integer intent(hide), depend(n) :: ldx = n
    real intent(out) :: rcond
    real intent(out), depend(nrhs), dimension(nrhs) :: ferr
    real intent(out), depend(nrhs), dimension(nrhs) :: berr
    real intent(hide,cache), depend(n), dimension(2*n) :: work
    integer intent(out) :: info

end subroutine sptsvx



subroutine dptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, info)
    ! DPTSVX uses the factorization A = L*D*L**T to compute the solution
    ! to a real system of linear equations A*X = B, where A is an N-by-N
    ! symmetric positive definite tridiagonal matrix and X and B are
    !N-by-NRHS matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    ! provided.
    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, &info)
    callprotoargument char*, F_INT*, F_INT*, double*, double*, double*, double*, double*, F_INT*, double*, F_INT*,  double*, double*, double*, double*, F_INT*

    character optional, intent(in) :: fact = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision intent(in), dimension(n) :: d
    double precision intent(in), depend(n), dimension(max(0, n-1)) :: e
    double precision optional, intent(in,out), depend(n), dimension(n) :: df
    double precision optional, intent(in,out), depend(n), dimension(max(0, n-1)) :: ef
    double precision intent(in), depend(n), dimension(ldb, nrhs), check(shape(b, 0) >= n):: b
    integer intent(hide), depend(b) :: ldb = max(1, shape(b, 0))
    double precision intent(out), dimension(ldx, nrhs) :: x
    integer intent(hide), depend(n) :: ldx = n
    double precision intent(out) :: rcond
    double precision intent(out), depend(nrhs), dimension(nrhs) :: ferr
    double precision intent(out), depend(nrhs), dimension(nrhs) :: berr
    double precision intent(hide,cache), depend(n), dimension(2*n) :: work
    integer intent(out) :: info

end subroutine dptsvx




subroutine cptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
    ! DPTSVX uses the factorization A = L*D*L**T to compute the solution
    ! to a real system of linear equations A*X = B, where A is an N-by-N
    ! symmetric positive definite tridiagonal matrix and X and B are
    !N-by-NRHS matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    ! provided.
    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, rwork, &info)
    callprotoargument char*, F_INT*, F_INT*, float*, complex_float*, float*, complex_float*, complex_float*, F_INT*, complex_float*, F_INT*,  float*, float*, float*, complex_float*, float*, F_INT*

    character optional, intent(in) :: fact = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real intent(in), dimension(n) :: d
    complex intent(in), depend(n), dimension(max(0, n-1)) :: e
    real optional, intent(in,out), depend(n), dimension(n) :: df
    complex optional, intent(in,out), depend(n), dimension(max(0, n-1)) :: ef
    complex intent(in), depend(n), dimension(ldb, nrhs), check(shape(b,0) >= n) :: b
    integer intent(hide), depend(b) :: ldb = max(1, shape(b, 0))
    complex intent(out), dimension(ldx, nrhs) :: x
    integer intent(hide), depend(n) :: ldx = n
    real intent(out) :: rcond
    real intent(out), depend(nrhs), dimension(nrhs) :: ferr
    real intent(out), depend(nrhs), dimension(nrhs) :: berr
    complex intent(hide,cache), depend(n), dimension(n) :: work
    real intent(hide,cache), depend(n), dimension(n) :: rwork
    integer intent(out) :: info

end subroutine cptsvx



subroutine zptsvx(fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx, rcond, ferr, berr, work, rwork, info)
    ! DPTSVX uses the factorization A = L*D*L**T to compute the solution
    ! to a real system of linear equations A*X = B, where A is an N-by-N
    ! symmetric positive definite tridiagonal matrix and X and B are
    !N-by-NRHS matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    ! provided.
    callstatement (*f2py_func)(fact, &n, &nrhs, d, e, df, ef, b, &ldb, x, &ldx, &rcond, ferr, berr, work, rwork, &info)
    callprotoargument char*, F_INT*, F_INT*, double*, complex_double*, double*, complex_double*, complex_double*, F_INT*, complex_double*, F_INT*,  double*, double*, double*, complex_double*, double*, F_INT*

    character optional, intent(in) :: fact = 'N'
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision intent(in), dimension(n) :: d
    double complex intent(in), depend(n), dimension(max(0, n-1)) :: e
    double precision optional, intent(in,out), depend(n), dimension(n) :: df
    double complex optional, intent(in,out), depend(n), dimension(max(0, n-1)) :: ef
    double complex intent(in), depend(n), dimension(ldb, nrhs), check(shape(b,0) >= n) :: b
    integer intent(hide), depend(b) :: ldb = max(1, shape(b, 0))
    double complex intent(out), dimension(ldx, nrhs) :: x
    integer intent(hide), depend(n) :: ldx = n
    double precision intent(out) :: rcond
    double precision intent(out), depend(nrhs), dimension(nrhs) :: ferr
    double precision intent(out), depend(nrhs), dimension(nrhs) :: berr
    double complex intent(hide,cache), depend(n), dimension(n) :: work
    double precision intent(hide,cache), depend(n), dimension(n) :: rwork
    integer intent(out) :: info

end subroutine zptsvx


! Signatures for f2py-wrappers of FORTRAN LAPACK Other Auxillary and Computational functions.
!

subroutine sgejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u,ldu,v,ldv,work,workout,lwork,iwork,iworkout,info)
    ! ?GEJSV computes the singular value decomposition (SVD) of a complex
    ! M-by-N matrix [A], where M >= N. The SVD of [A] is written as
    !
    !              [A] = [U] * [SIGMA] * [V]^*,
    !
    ! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
    ! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
    ! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
    ! the singular values of [A]. The columns of [U] and [V] are the left and
    ! the right singular vectors of [A], respectively. The matrices [U] and [V]
    ! are computed and stored in the arrays U and V, respectively. The diagonal
    ! of [SIGMA] is computed and stored in the array SVA.
    callstatement {F_INT i;(*f2py_func)(&"CEFGAR"[joba],&"UFWN"[jobu],&"VJWN"[jobv],(jobr?"R":"N"),(jobt?"T":"N"),(jobp?"P":"N"),&m,&n,a,&lda,sva,u,&ldu,v,&ldv,work,&lwork,iwork,&info);for(i=0;i<7;i++){workout[i] = work[i];}for(i=0;i<3;i++){iworkout[i] = iwork[i];}}
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in, optional), check((0 <= joba) && (joba < 6)) :: joba = 4
    integer intent(in, optional), check((0 <= jobu) && (jobu < 4)) :: jobu = 0
    integer intent(in, optional), check((0 <= jobv) && (jobv < 4) && ((jobv < 1) || (1 < jobv) || ((jobv == 1) && (jobu < 2)))), depend(jobu) :: jobv = 0
    integer intent(in, optional), check((jobr == 0) || (jobr == 1)) :: jobr = 1
    integer intent(in, optional), check((jobt == 0) || (jobt == 1)) :: jobt = 0
    integer intent(in, optional), check((jobp == 0) || (jobp == 1)) :: jobp = 1

    integer intent(hide), depend(a), check(m>=n), depend(n) :: m = shape(a, 0)
    integer intent(hide), depend(a) :: n = shape(a, 1)
    real intent(in,copy), dimension(lda, n) :: a
    integer intent(hide), depend(a) :: lda = max(1, shape(a, 0))
    real intent(out), depend(n), dimension(n) :: sva
    real intent(out), depend(ldu, n, jobt, jobu, m), dimension(((jobt == 0)&&(jobu == 3)?0:m), ((jobt == 0)&&(jobu == 3)?0:(jobu == 1?m:n))) :: u
    integer intent(hide), depend(m, jobu) :: ldu = max(1, (jobu < 3?m:1))
    real intent(out), depend(ldv, n, jobt, jobv), dimension(((jobt == 0)&&(jobv == 3)?0:ldv),((jobt == 0)&&(jobv == 3)?0:n)) :: v
    integer intent(hide), depend(n, jobv) :: ldv = max(1, (jobv < 3?n:1))
    real intent(hide), depend(lwork), dimension(lwork) :: work
    real intent(out), dimension(7) :: workout
    integer intent(in, optional), depend(m, n), check(lwork>=7) :: lwork = max(6*n+2*n*n, max(2*m+n, max(4*n+n*n, max(2*n+n*n+6, 7))))
    integer intent(hide), depend(m ,n), dimension(MAX(3, m+3*n)) :: iwork
    integer intent(out), dimension(3) :: iworkout
    integer intent(out) :: info

end subroutine sgejsv


subroutine dgejsv(joba,jobu,jobv,jobr,jobt,jobp,m,n,a,lda,sva,u,ldu,v,ldv,work,workout,lwork,iwork,iworkout,info)
    ! ?GEJSV computes the singular value decomposition (SVD) of a complex
    ! M-by-N matrix [A], where M >= N. The SVD of [A] is written as
    !
    !              [A] = [U] * [SIGMA] * [V]^*,
    !
    ! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
    ! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
    ! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
    ! the singular values of [A]. The columns of [U] and [V] are the left and
    ! the right singular vectors of [A], respectively. The matrices [U] and [V]
    ! are computed and stored in the arrays U and V, respectively. The diagonal
    ! of [SIGMA] is computed and stored in the array SVA.
    callstatement {F_INT i;(*f2py_func)(&"CEFGAR"[joba],&"UFWN"[jobu],&"VJWN"[jobv],(jobr?"R":"N"),(jobt?"T":"N"),(jobp?"P":"N"),&m,&n,a,&lda,sva,u,&ldu,v,&ldv,work,&lwork,iwork,&info);for(i=0;i<7;i++){workout[i] = work[i];}for(i=0;i<3;i++){iworkout[i] = iwork[i];}}
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in, optional), check((0 <= joba) && (joba < 6)) :: joba = 4
    integer intent(in, optional), check((0 <= jobu) && (jobu < 4)) :: jobu = 0
    integer intent(in, optional), check((0 <= jobv) && (jobv < 4) && ((jobv < 1) || (1 < jobv) || ((jobv == 1) && (jobu < 2)))), depend(jobu) :: jobv = 0
    integer intent(in, optional), check((jobr == 0) || (jobr == 1)) :: jobr = 1
    integer intent(in, optional), check((jobt == 0) || (jobt == 1)) :: jobt = 0
    integer intent(in, optional), check((jobp == 0) || (jobp == 1)) :: jobp = 1

    integer intent(hide), depend(a), check(m>=n), depend(n) :: m = shape(a, 0)
    integer intent(hide), depend(a) :: n = shape(a, 1)
    double precision intent(in,copy), dimension(lda, n) :: a
    integer intent(hide), depend(a) :: lda = max(1, shape(a, 0))
    double precision intent(out), depend(n), dimension(n) :: sva
    double precision intent(out), depend(ldu, n, jobt, jobu, m), dimension(((jobt == 0)&&(jobu == 3)?0:m), ((jobt == 0)&&(jobu == 3)?0:(jobu == 1?m:n))) :: u
    integer intent(hide), depend(m, jobu) :: ldu = max(1, (jobu < 3?m:1))
    double precision intent(out), depend(ldv, n, jobt, jobv), dimension(((jobt == 0)&&(jobv == 3)?0:ldv),((jobt == 0)&&(jobv == 3)?0:n)) :: v
    integer intent(hide), depend(n, jobv) :: ldv = max(1, (jobv < 3?n:1))
    double precision intent(hide), depend(lwork), dimension(lwork) :: work
    double precision intent(out), dimension(7) :: workout
    integer intent(in, optional), depend(m, n), check(lwork>=7) :: lwork = max(6*n+2*n*n, max(2*m+n, max(4*n+n*n, max(2*n+n*n+6, 7))))
    integer intent(hide), depend(m ,n), dimension(MAX(3, m+3*n)) :: iwork
    integer intent(out), dimension(3) :: iworkout
    integer intent(out) :: info

end subroutine dgejsv



subroutine strexc(wantq,n,a,lda,q,ldq,ifst,ilst,work,info)
    ! Reorder the Schur decomposition of a real matrix
    ! using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,work,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,float*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    real intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    real intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    real intent(hide),depend(n),dimension(n) :: work
    integer intent(out) :: info

end subroutine strexc


subroutine dtrexc(wantq,n,a,lda,q,ldq,ifst,ilst,work,info)
    ! Reorder the Schur decomposition of a real matrix
    ! using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,work,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,double*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    double precision intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    double precision intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    double precision intent(hide),depend(n),dimension(n) :: work
    integer intent(out) :: info

end subroutine dtrexc



subroutine ctrexc(wantq,n,a,lda,q,ldq,ifst,ilst,info)
    ! Reorder the Schur decomposition of a complex matrix
    ! using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    complex intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    integer intent(out) :: info

end subroutine ctrexc


subroutine ztrexc(wantq,n,a,lda,q,ldq,ifst,ilst,info)
    ! Reorder the Schur decomposition of a complex matrix
    ! using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)((wantq?"V":"N"),&n,a,&lda,q,&ldq,&ifst,&ilst,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    double complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    double complex intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    integer intent(out) :: info

end subroutine ztrexc



subroutine stgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst,work,lwork,info)
    ! Reorder the generalized Schur decomposition of a real matrix
    ! pair using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)(&wantq,&wantz,&n,a,&lda,b,&ldb,q,&ldq,z,&ldz,&ifst,&ilst,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer optional,intent(in),check(wantz==0||wantz==1) :: wantz=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    real intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    real intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=MAX(1,shape(b,0))
    real intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    real intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    real intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 4*n+16) :: lwork=max(4*n+16,1)
    integer intent(out) :: info

end subroutine stgexc


subroutine dtgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst,work,lwork,info)
    ! Reorder the generalized Schur decomposition of a real matrix
    ! pair using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)(&wantq,&wantz,&n,a,&lda,b,&ldb,q,&ldq,z,&ldz,&ifst,&ilst,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer optional,intent(in),check(wantz==0||wantz==1) :: wantz=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    double precision intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    double precision intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=MAX(1,shape(b,0))
    double precision intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    double precision intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    double precision intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 4*n+16) :: lwork=max(4*n+16,1)
    integer intent(out) :: info

end subroutine dtgexc



subroutine ctgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst,info)
    ! Reorder the generalized Schur decomposition of a complex matrix
    ! pair using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)(&wantq,&wantz,&n,a,&lda,b,&ldb,q,&ldq,z,&ldz,&ifst,&ilst,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer optional,intent(in),check(wantz==0||wantz==1) :: wantz=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=MAX(1,shape(b,0))
    complex intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    complex intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    integer intent(out) :: info

end subroutine ctgexc


subroutine ztgexc(wantq,wantz,n,a,lda,b,ldb,q,ldq,z,ldz,ifst,ilst,info)
    ! Reorder the generalized Schur decomposition of a complex matrix
    ! pair using an orthogonal or unitary equivalence transformation.

    callstatement (*f2py_func)(&wantq,&wantz,&n,a,&lda,b,&ldb,q,&ldq,z,&ldz,&ifst,&ilst,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(wantq==0||wantq==1) :: wantq=1
    integer optional,intent(in),check(wantz==0||wantz==1) :: wantz=1
    integer intent(hide),depend(a) :: n=shape(a,1)
    double complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    double complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=MAX(1,shape(b,0))
    double complex intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    double complex intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(in) :: ifst
    integer intent(in) :: ilst
    integer intent(out) :: info

end subroutine ztgexc



subroutine strsen(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info)

    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,wr,wi,&m,&s,&sep,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(t) :: n=shape(t,0)
    real intent(in,out,copy,out=ts),dimension(n,n) :: t
    integer intent(hide),depend(t) :: ldt=MAX(1,shape(t,0))
    real intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    real intent(out),dimension(n),depend(n) :: wr
    real intent(out),dimension(n),depend(n) :: wi
    integer intent(out) :: m
    real intent(out) :: s
    real intent(out) :: sep
    real intent(hide),dimension(MAX(lwork,1)) :: work
    ! These lwork and liwork values are bare minimum estiamates only for the case job == "N".
    ! A separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste.
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=MAX(1,n)
    integer intent(hide),dimension(MAX(1,liwork)) :: iwork
    integer optional,intent(in),check(liwork == -1 || liwork >= 1) :: liwork=1
    integer intent(out) :: info

end subroutine strsen


subroutine dtrsen(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info)

    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,wr,wi,&m,&s,&sep,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(t) :: n=shape(t,0)
    double precision intent(in,out,copy,out=ts),dimension(n,n) :: t
    integer intent(hide),depend(t) :: ldt=MAX(1,shape(t,0))
    double precision intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    double precision intent(out),dimension(n),depend(n) :: wr
    double precision intent(out),dimension(n),depend(n) :: wi
    integer intent(out) :: m
    double precision intent(out) :: s
    double precision intent(out) :: sep
    double precision intent(hide),dimension(MAX(lwork,1)) :: work
    ! These lwork and liwork values are bare minimum estiamates only for the case job == "N".
    ! A separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste.
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=MAX(1,n)
    integer intent(hide),dimension(MAX(1,liwork)) :: iwork
    integer optional,intent(in),check(liwork == -1 || liwork >= 1) :: liwork=1
    integer intent(out) :: info

end subroutine dtrsen



subroutine strsen_lwork(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info)

    fortranname strsen
    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&wr,&wi,&m,&s,&sep,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical intent(in),dimension(n),depend(n) :: select
    real intent(in),dimension(n,n) :: t

    logical intent(hide) :: wantq = 0
    integer intent(hide),depend(t) :: n = shape(t,0)
    integer intent(hide),depend(n) :: ldt = MAX(1, n)
    real intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    real intent(hide) :: wr
    real intent(hide) :: wi
    integer intent(hide) :: m
    real intent(hide) :: s
    real intent(hide) :: sep
    integer intent(hide):: lwork=-1
    integer intent(hide) :: liwork=-1

    real intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine strsen_lwork


subroutine dtrsen_lwork(job,wantq,select,n,t,ldt,q,ldq,wr,wi,m,s,sep,work,lwork,iwork,liwork,info)

    fortranname dtrsen
    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&wr,&wi,&m,&s,&sep,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical intent(in),dimension(n),depend(n) :: select
    double precision intent(in),dimension(n,n) :: t

    logical intent(hide) :: wantq = 0
    integer intent(hide),depend(t) :: n = shape(t,0)
    integer intent(hide),depend(n) :: ldt = MAX(1, n)
    double precision intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    double precision intent(hide) :: wr
    double precision intent(hide) :: wi
    integer intent(hide) :: m
    double precision intent(hide) :: s
    double precision intent(hide) :: sep
    integer intent(hide):: lwork=-1
    integer intent(hide) :: liwork=-1

    double precision intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine dtrsen_lwork



subroutine ctrsen(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info)

    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,w,&m,&s,&sep,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(t) :: n=shape(t,0)
    complex intent(in,out,copy,out=ts),dimension(n,n) :: t
    integer intent(hide),depend(t) :: ldt=MAX(1,shape(t,0))
    complex intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    complex intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: m
    real intent(out) :: s
    real intent(out) :: sep
    complex intent(hide),dimension(MAX(lwork,1)) :: work
    ! This lwork values is a bare minimum estiamate only for the case job == "N".
    ! A separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste.
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=MAX(1,n)
    integer intent(out) :: info

end subroutine ctrsen


subroutine ztrsen(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info)

    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,q,&ldq,w,&m,&s,&sep,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(t) :: n=shape(t,0)
    double complex intent(in,out,copy,out=ts),dimension(n,n) :: t
    integer intent(hide),depend(t) :: ldt=MAX(1,shape(t,0))
    double complex intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    double complex intent(out),dimension(n),depend(n) :: w
    integer intent(out) :: m
    double precision intent(out) :: s
    double precision intent(out) :: sep
    double complex intent(hide),dimension(MAX(lwork,1)) :: work
    ! This lwork values is a bare minimum estiamate only for the case job == "N".
    ! A separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste.
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=MAX(1,n)
    integer intent(out) :: info

end subroutine ztrsen



subroutine ctrsen_lwork(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info)

    fortranname ctrsen
    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&w,&m,&s,&sep,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical intent(in),dimension(n),depend(n) :: select
    complex intent(in),dimension(n,n) :: t

    logical intent(hide) :: wantq = 0
    integer intent(hide),depend(t) :: n = shape(t,0)
    integer intent(hide),depend(n) :: ldt = MAX(1, n)
    complex intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    complex intent(hide) :: w
    integer intent(hide) :: m
    real intent(hide) :: s
    real intent(hide) :: sep
    integer intent(hide):: lwork=-1

    complex intent(out) :: work
    integer intent(out) :: info

end subroutine ctrsen_lwork


subroutine ztrsen_lwork(job,wantq,select,n,t,ldt,q,ldq,w,m,s,sep,work,lwork,info)

    fortranname ztrsen
    callstatement (*f2py_func)(job,(wantq?"V":"N"),select,&n,t,&ldt,&q,&ldq,&w,&m,&s,&sep,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*job=='N'||*job=='E'||*job=='V'||*job=='B'):: job = 'B'
    logical intent(in),dimension(n),depend(n) :: select
    double complex intent(in),dimension(n,n) :: t

    logical intent(hide) :: wantq = 0
    integer intent(hide),depend(t) :: n = shape(t,0)
    integer intent(hide),depend(n) :: ldt = MAX(1, n)
    double complex intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    double complex intent(hide) :: w
    integer intent(hide) :: m
    double precision intent(hide) :: s
    double precision intent(hide) :: sep
    integer intent(hide):: lwork=-1

    double complex intent(out) :: work
    integer intent(out) :: info

end subroutine ztrsen_lwork



subroutine stgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alphar,alphai,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,float*,F_INT*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob=4
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical optional, intent(in),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,0)
    real intent(in,out,copy,out=as),dimension(n,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    real intent(in,out,copy,out=bs),dimension(n,n) :: b
    integer intent(hide),depend(b) :: ldb = MAX(1, shape(b,0))
    real intent(out),dimension(n),depend(n) :: alphar
    real intent(out),dimension(n),depend(n) :: alphai
    real intent(out),dimension(n),depend(n) :: beta
    real intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    real intent(in,out,copy,out=zs),dimension(n,n),depend(n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(out) :: m
    real intent(out) :: pl
    real intent(out) :: pr
    real intent(out),dimension(2) :: dif
    real intent(hide),dimension(MAX(lwork,1)) :: work
    ! these lwork and liwork values are bare minimum estiamates only for cases ijob == 1,2,4
    ! a separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=4*n+16
    integer intent(hide),dimension(MAX(1,liwork)) :: iwork
    integer optional,intent(in),depend(n),check(liwork == -1 || liwork >= 1) :: liwork=n+6
    integer intent(out) :: info

end subroutine stgsen


subroutine dtgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alphar,alphai,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,double*,F_INT*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob=4
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical optional, intent(in),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,0)
    double precision intent(in,out,copy,out=as),dimension(n,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    double precision intent(in,out,copy,out=bs),dimension(n,n) :: b
    integer intent(hide),depend(b) :: ldb = MAX(1, shape(b,0))
    double precision intent(out),dimension(n),depend(n) :: alphar
    double precision intent(out),dimension(n),depend(n) :: alphai
    double precision intent(out),dimension(n),depend(n) :: beta
    double precision intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    double precision intent(in,out,copy,out=zs),dimension(n,n),depend(n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(out) :: m
    double precision intent(out) :: pl
    double precision intent(out) :: pr
    double precision intent(out),dimension(2) :: dif
    double precision intent(hide),dimension(MAX(lwork,1)) :: work
    ! these lwork and liwork values are bare minimum estiamates only for cases ijob == 1,2,4
    ! a separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste
    integer optional,intent(in),depend(n),check(lwork == -1 || lwork >= 1) :: lwork=4*n+16
    integer intent(hide),dimension(MAX(1,liwork)) :: iwork
    integer optional,intent(in),depend(n),check(liwork == -1 || liwork >= 1) :: liwork=n+6
    integer intent(out) :: info

end subroutine dtgsen



subroutine stgsen_lwork(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    fortranname stgsen
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,&b,&ldb,&alphar,&alphai,&beta,&q,&ldq,&z,&ldz,&m,&pl,&pr,&dif,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,float*,F_INT*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob = 4
    logical intent(in),dimension(n),depend(n) :: select
    real intent(in),dimension(n,n) :: a

    logical intent(hide) :: wantq = 0
    logical intent(hide) :: wantz = 0
    integer intent(hide),depend(a) :: n = shape(a,0)
    integer intent(hide),depend(n) :: lda = MAX(1, n)
    real intent(hide) :: b
    integer intent(hide),depend(n) :: ldb = MAX(1, n)
    real intent(hide) :: alphar
    real intent(hide) :: alphai
    real intent(hide) :: beta
    real intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    real intent(hide) :: z
    integer intent(hide),depend(n) :: ldz = MAX(1, n)
    integer intent(hide) :: m
    real intent(hide) :: pl
    real intent(hide) :: pr
    real intent(hide) :: dif
    integer intent(hide):: lwork=-1
    integer intent(hide) :: liwork=-1

    real intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine stgsen_lwork


subroutine dtgsen_lwork(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    fortranname dtgsen
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,&b,&ldb,&alphar,&alphai,&beta,&q,&ldq,&z,&ldz,&m,&pl,&pr,&dif,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,double*,F_INT*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob = 4
    logical intent(in),dimension(n),depend(n) :: select
    double precision intent(in),dimension(n,n) :: a

    logical intent(hide) :: wantq = 0
    logical intent(hide) :: wantz = 0
    integer intent(hide),depend(a) :: n = shape(a,0)
    integer intent(hide),depend(n) :: lda = MAX(1, n)
    double precision intent(hide) :: b
    integer intent(hide),depend(n) :: ldb = MAX(1, n)
    double precision intent(hide) :: alphar
    double precision intent(hide) :: alphai
    double precision intent(hide) :: beta
    double precision intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    double precision intent(hide) :: z
    integer intent(hide),depend(n) :: ldz = MAX(1, n)
    integer intent(hide) :: m
    double precision intent(hide) :: pl
    double precision intent(hide) :: pr
    double precision intent(hide) :: dif
    integer intent(hide):: lwork=-1
    integer intent(hide) :: liwork=-1

    double precision intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine dtgsen_lwork



subroutine ctgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alpha,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,float*,float*,float*,complex_float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob=4
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical optional, intent(in),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,0)
    complex intent(in,out,copy,out=as),dimension(n,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    complex intent(in,out,copy,out=bs),dimension(n,n) :: b
    integer intent(hide),depend(b) :: ldb = MAX(1, shape(b,0))
    complex intent(out),dimension(n),depend(n) :: alpha
    complex intent(out),dimension(n),depend(n) :: beta
    complex intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    complex intent(in,out,copy,out=zs),dimension(n,n),depend(n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(out) :: m
    real intent(out) :: pl
    real intent(out) :: pr
    real intent(out),dimension(2) :: dif
    complex intent(hide),dimension(MAX(lwork,1)) :: work
    ! these lwork and liwork values are bare minimum estiamates only for cases ijob ==0,1,2,4
    ! a separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste
    integer optional,intent(in),depend(n,ijob),check(lwork == -1 || lwork >= 1) :: lwork=(ijob==0?1:n+2)
    integer intent(hide),dimension(liwork):: iwork
    integer optional,intent(in),depend(n,ijob),check(liwork == -1 || liwork>=1) :: liwork=(ijob==0?1:n+2)
    integer intent(out) :: info

end subroutine ctgsen


subroutine ztgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alpha,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,double*,double*,double*,complex_double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob=4
    logical optional, intent(in),check(wantq==0||wantq==1) :: wantq=1
    logical optional, intent(in),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n),depend(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,0)
    double complex intent(in,out,copy,out=as),dimension(n,n) :: a
    integer intent(hide),depend(a) :: lda=MAX(1,shape(a,0))
    double complex intent(in,out,copy,out=bs),dimension(n,n) :: b
    integer intent(hide),depend(b) :: ldb = MAX(1, shape(b,0))
    double complex intent(out),dimension(n),depend(n) :: alpha
    double complex intent(out),dimension(n),depend(n) :: beta
    double complex intent(in,out,copy,out=qs),dimension(n,n),depend(n) :: q
    integer intent(hide),depend(q) :: ldq=MAX(1,shape(q,0))
    double complex intent(in,out,copy,out=zs),dimension(n,n),depend(n) :: z
    integer intent(hide),depend(z) :: ldz=MAX(1,shape(z,0))
    integer intent(out) :: m
    double precision intent(out) :: pl
    double precision intent(out) :: pr
    double precision intent(out),dimension(2) :: dif
    double complex intent(hide),dimension(MAX(lwork,1)) :: work
    ! these lwork and liwork values are bare minimum estiamates only for cases ijob ==0,1,2,4
    ! a separate lwork query is a prerequisite due to m dependence.
    ! Depending on the m value lwork can go up to n**2 / 2 for n = 2m hence it is not
    ! possible to give a minimal value without a potential excessive memory waste
    integer optional,intent(in),depend(n,ijob),check(lwork == -1 || lwork >= 1) :: lwork=(ijob==0?1:n+2)
    integer intent(hide),dimension(liwork):: iwork
    integer optional,intent(in),depend(n,ijob),check(liwork == -1 || liwork>=1) :: liwork=(ijob==0?1:n+2)
    integer intent(out) :: info

end subroutine ztgsen



subroutine ctgsen_lwork(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    fortranname ctgsen
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alpha,beta,&q,&ldq,&z,&ldz,&m,&pl,&pr,&dif,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*,float*,float*,float*,complex_float*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob = 4
    logical intent(in),dimension(n),depend(n) :: select
    complex intent(in),dimension(n,n) :: a
    complex intent(in),dimension(n,n) :: b

    logical intent(hide) :: wantq = 0
    logical intent(hide) :: wantz = 0
    integer intent(hide),depend(a) :: n = shape(a,0)
    integer intent(hide),depend(n) :: lda = MAX(1, n)
    integer intent(hide),depend(n) :: ldb = MAX(1, n)
    complex intent(hide),dimension(n) :: alpha
    complex intent(hide),dimension(n) :: beta
    complex intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    complex intent(hide) :: z
    integer intent(hide),depend(n) :: ldz = MAX(1, n)
    integer intent(hide) :: m
    real intent(hide) :: pl
    real intent(hide) :: pr
    real intent(hide) :: dif
    integer intent(hide):: lwork=-1
    integer intent(hide) :: liwork=-1

    complex intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine ctgsen_lwork


subroutine ztgsen_lwork(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    fortranname ztgsen
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alpha,beta,&q,&ldq,&z,&ldz,&m,&pl,&pr,&dif,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*,double*,double*,double*,complex_double*,F_INT*,F_INT*,F_INT*,F_INT*

    integer optional, intent(in),check(ijob>=0&&ijob<=5) :: ijob = 4
    logical intent(in),dimension(n),depend(n) :: select
    double complex intent(in),dimension(n,n) :: a
    double complex intent(in),dimension(n,n) :: b

    logical intent(hide) :: wantq = 0
    logical intent(hide) :: wantz = 0
    integer intent(hide),depend(a) :: n = shape(a,0)
    integer intent(hide),depend(n) :: lda = MAX(1, n)
    integer intent(hide),depend(n) :: ldb = MAX(1, n)
    double complex intent(hide),dimension(n) :: alpha
    double complex intent(hide),dimension(n) :: beta
    double complex intent(hide) :: q
    integer intent(hide),depend(n) :: ldq = MAX(1, n)
    double complex intent(hide) :: z
    integer intent(hide),depend(n) :: ldz = MAX(1, n)
    integer intent(hide) :: m
    double precision intent(hide) :: pl
    double precision intent(hide) :: pr
    double precision intent(hide) :: dif
    integer intent(hide):: lwork=-1
    integer intent(hide) :: liwork=-1

    double complex intent(out) :: work
    integer intent(out) :: iwork
    integer intent(out) :: info

end subroutine ztgsen_lwork



subroutine spbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine spbtrf


subroutine dpbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine dpbtrf



subroutine cpbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,F_INT*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine cpbtrf


subroutine zpbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,F_INT*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine zpbtrf



subroutine spbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    real dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine spbtrs


subroutine dpbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double precision dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine dpbtrs



subroutine cpbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    complex dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine cpbtrs


subroutine zpbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double complex dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine zpbtrs



subroutine strtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    real dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    real dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine strtrs


subroutine dtrtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    double precision dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double precision dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine dtrtrs


subroutine ctrtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    complex dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine ctrtrs


subroutine ztrtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    double complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double complex dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine ztrtrs




subroutine stbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! x, info  = tbtrs(ab, b, uplo="U", trans="N", diag="N", overwrite_b=0)
    ! ?TBTRS solves a triangular system of the form
    !
    !     A * X = B  or  A**T * X = B,
    !
    ! where:
    !   * A is a triangular band matrix of order N,
    !   * B is an N-by NRHS matrix.
    ! A check is made to verify that A is nonsingular.

    callstatement (*f2py_func)(uplo,trans,diag,&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    real intent(in), dimension(ldab, n) :: ab
    real intent(in,out,copy,out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

    character optional intent(in), check(*uplo=='U'||*uplo=='L') :: uplo = 'U'
    character optional intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = 'N'
    character optional intent(in), check(*diag=='N'||*diag=='U') :: diag = 'N'

    integer intent(hide), depend(ab) :: ldab = MAX(1, shape(ab, 0))
    integer intent(hide), depend(ab) :: n = MAX(1, shape(ab, 1))
    integer intent(hide), depend(ldab) :: kd = ldab - 1
    integer intent(hide), depend(b, n), check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b) :: nrhs = MAX(1, shape(b, 1))

end subroutine stbtrs



subroutine dtbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! x, info  = tbtrs(ab, b, uplo="U", trans="N", diag="N", overwrite_b=0)
    ! ?TBTRS solves a triangular system of the form
    !
    !     A * X = B  or  A**T * X = B,
    !
    ! where:
    !   * A is a triangular band matrix of order N,
    !   * B is an N-by NRHS matrix.
    ! A check is made to verify that A is nonsingular.

    callstatement (*f2py_func)(uplo,trans,diag,&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    double precision intent(in), dimension(ldab, n) :: ab
    double precision intent(in,out,copy,out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

    character optional intent(in), check(*uplo=='U'||*uplo=='L') :: uplo = 'U'
    character optional intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = 'N'
    character optional intent(in), check(*diag=='N'||*diag=='U') :: diag = 'N'

    integer intent(hide), depend(ab) :: ldab = MAX(1, shape(ab, 0))
    integer intent(hide), depend(ab) :: n = MAX(1, shape(ab, 1))
    integer intent(hide), depend(ldab) :: kd = ldab - 1
    integer intent(hide), depend(b, n), check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b) :: nrhs = MAX(1, shape(b, 1))

end subroutine dtbtrs



subroutine ctbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! x, info  = tbtrs(ab, b, uplo="U", trans="N", diag="N", overwrite_b=0)
    ! ?TBTRS solves a triangular system of the form
    !
    !     A * X = B  or  A**T * X = B,
    !
    ! where:
    !   * A is a triangular band matrix of order N,
    !   * B is an N-by NRHS matrix.
    ! A check is made to verify that A is nonsingular.

    callstatement (*f2py_func)(uplo,trans,diag,&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    complex intent(in), dimension(ldab, n) :: ab
    complex intent(in,out,copy,out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

    character optional intent(in), check(*uplo=='U'||*uplo=='L') :: uplo = 'U'
    character optional intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = 'N'
    character optional intent(in), check(*diag=='N'||*diag=='U') :: diag = 'N'

    integer intent(hide), depend(ab) :: ldab = MAX(1, shape(ab, 0))
    integer intent(hide), depend(ab) :: n = MAX(1, shape(ab, 1))
    integer intent(hide), depend(ldab) :: kd = ldab - 1
    integer intent(hide), depend(b, n), check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b) :: nrhs = MAX(1, shape(b, 1))

end subroutine ctbtrs



subroutine ztbtrs(uplo,trans,diag,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! x, info  = tbtrs(ab, b, uplo="U", trans="N", diag="N", overwrite_b=0)
    ! ?TBTRS solves a triangular system of the form
    !
    !     A * X = B  or  A**T * X = B,
    !
    ! where:
    !   * A is a triangular band matrix of order N,
    !   * B is an N-by NRHS matrix.
    ! A check is made to verify that A is nonsingular.

    callstatement (*f2py_func)(uplo,trans,diag,&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    double complex intent(in), dimension(ldab, n) :: ab
    double complex intent(in,out,copy,out=x), dimension(ldb, nrhs) :: b
    integer intent(out) :: info

    character optional intent(in), check(*uplo=='U'||*uplo=='L') :: uplo = 'U'
    character optional intent(in), check(*trans=='N'||*trans=='T'||*trans=='C') :: trans = 'N'
    character optional intent(in), check(*diag=='N'||*diag=='U') :: diag = 'N'

    integer intent(hide), depend(ab) :: ldab = MAX(1, shape(ab, 0))
    integer intent(hide), depend(ab) :: n = MAX(1, shape(ab, 1))
    integer intent(hide), depend(ldab) :: kd = ldab - 1
    integer intent(hide), depend(b, n), check(ldb >= n) :: ldb = MAX(1, shape(b, 0))
    integer intent(hide), depend(b) :: nrhs = MAX(1, shape(b, 1))

end subroutine ztbtrs



subroutine spbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    !
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N symmetric positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**T * U,  if lower=1, or
    !     A = L * L**T,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    real dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine spbsv


subroutine dpbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    !
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N symmetric positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**T * U,  if lower=1, or
    !     A = L * L**T,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double precision dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine dpbsv



subroutine cpbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N Hermitian positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**H * U,  if lower=1, or
    !     A = L * L**H,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine cpbsv


subroutine zpbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N Hermitian positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**H * U,  if lower=1, or
    !     A = L * L**H,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine zpbsv



subroutine sorcsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq)
    ! DORCSD computes the CS decomposition of an M-by-M partitioned
    ! unitary matrix X:
    !
    !                             [  I11 0  0  |  0    0  0   ]
    !                             [  0   C  0  |  0   -S  0   ]
    ! [ X11 | X12 ]   [ U1 |    ] [  0   0  0  |  0    0 -I12 ] [ V1 |    ]**T
    ! [-----------] = [---------] [---------------------------] [---------]   .
    ! [ X21 | X22 ]   [    | U2 ] [  0  0  0   |  I22  0  0   ] [    | V2 ]
    !                             [  0  S  0   |  0    C  0   ]
    !                             [  0  0  I21 |  0    0  0   ]
    !
    ! U1, U2, V1, V2 are square orthogonal matrices of
    ! dimensions (p,p), (m-p,m-p), (q,q), (m-q,m-q), respectively,
    !  and C and S are (r, r) nonnegative diagonal matrices satisfying
    ! C^2 + S^2 = I where r = min(p, m-p, q, m-q).
    !
    !  Moreover, the rank of the identity matrices are min(p, q) - r,
    !  min(p, m - q) - r, min(m - p, q) - r, and min(m - p, m - q) - r
    !  respectively.

    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(compute_u1==0||compute_u1==1) :: compute_u1 = 1
    integer optional,intent(in),check(compute_u2==0||compute_u2==1) :: compute_u2 = 1
    integer optional,intent(in),check(compute_v1t==0||compute_v1t==1) :: compute_v1t = 1
    integer optional,intent(in),check(compute_v2t==0||compute_v2t==1) :: compute_v2t = 1
    integer optional,intent(in),check(trans==0||trans==1) :: trans = 0
    integer optional,intent(in),check(signs==0||signs==1) :: signs = 0

    integer intent(hide),check(p+mmp==q+mmq),depend(p,q,mmp,mmq) :: m = p + mmp

    real intent(in,out,copy,out=cs11),dimension(p,q) :: x11
    real intent(in,out,copy,out=cs22),dimension(mmp,mmq) :: x22
    real intent(in,out,copy,out=cs12),dimension(p,mmq),check(mmq==shape(x12,1)||p==shape(x12,0)),depend(p,mmq) :: x12
    real intent(in,out,copy,out=cs21),dimension(mmp,q),check(mmp==shape(x21,0)||q==shape(x21,1)),depend(mmp,q) :: x21

    integer intent(hide),depend(x11) :: p = shape(x11,0)
    integer intent(hide),depend(x11) :: q = shape(x11,1)
    integer intent(hide),depend(x22) :: mmp = shape(x22,0)
    integer intent(hide),depend(x22) :: mmq = shape(x22,1)

    integer intent(hide),depend(x11) :: ldx11 = MAX(1,shape(x11,0))
    integer intent(hide),depend(x12) :: ldx12 = MAX(1,shape(x12,0))
    integer intent(hide),depend(x21) :: ldx21 = MAX(1,shape(x21,0))
    integer intent(hide),depend(x22) :: ldx22 = MAX(1,shape(x22,0))

    real intent(out),dimension(min(min(p,mmp),min(q,mmq))),depend(p,q,mmp,mmq) :: theta
    real intent(out),dimension((compute_u1?p:0),(compute_u1?p:0)),depend(p) :: u1
    real intent(out),dimension((compute_u2?mmp:0),(compute_u2?mmp:0)),depend(mmp) :: u2
    real intent(out),dimension((compute_v1t?q:0),(compute_v1t?q:0)),depend(q) :: v1t
    real intent(out),dimension((compute_v2t?mmq:0),(compute_v2t?mmq:0)),depend(mmq) :: v2t

    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)

    real intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(p+mmp-MIN(MIN(p,mmp),MIN(q,mmq))),depend(p,q,mmp,mmq) :: iwork

    integer optional,intent(in),check(lwork==-1||lwork>0),depend(m,mmp,mmq) :: lwork = 2 + 2*m + 5*MAX(1,q-1) + 4*MAX(1,q) + 8*q
    integer intent(out) :: info

end subroutine sorcsd


subroutine dorcsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq)
    ! DORCSD computes the CS decomposition of an M-by-M partitioned
    ! unitary matrix X:
    !
    !                             [  I11 0  0  |  0    0  0   ]
    !                             [  0   C  0  |  0   -S  0   ]
    ! [ X11 | X12 ]   [ U1 |    ] [  0   0  0  |  0    0 -I12 ] [ V1 |    ]**T
    ! [-----------] = [---------] [---------------------------] [---------]   .
    ! [ X21 | X22 ]   [    | U2 ] [  0  0  0   |  I22  0  0   ] [    | V2 ]
    !                             [  0  S  0   |  0    C  0   ]
    !                             [  0  0  I21 |  0    0  0   ]
    !
    ! U1, U2, V1, V2 are square orthogonal matrices of
    ! dimensions (p,p), (m-p,m-p), (q,q), (m-q,m-q), respectively,
    !  and C and S are (r, r) nonnegative diagonal matrices satisfying
    ! C^2 + S^2 = I where r = min(p, m-p, q, m-q).
    !
    !  Moreover, the rank of the identity matrices are min(p, q) - r,
    !  min(p, m - q) - r, min(m - p, q) - r, and min(m - p, m - q) - r
    !  respectively.

    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(compute_u1==0||compute_u1==1) :: compute_u1 = 1
    integer optional,intent(in),check(compute_u2==0||compute_u2==1) :: compute_u2 = 1
    integer optional,intent(in),check(compute_v1t==0||compute_v1t==1) :: compute_v1t = 1
    integer optional,intent(in),check(compute_v2t==0||compute_v2t==1) :: compute_v2t = 1
    integer optional,intent(in),check(trans==0||trans==1) :: trans = 0
    integer optional,intent(in),check(signs==0||signs==1) :: signs = 0

    integer intent(hide),check(p+mmp==q+mmq),depend(p,q,mmp,mmq) :: m = p + mmp

    double precision intent(in,out,copy,out=cs11),dimension(p,q) :: x11
    double precision intent(in,out,copy,out=cs22),dimension(mmp,mmq) :: x22
    double precision intent(in,out,copy,out=cs12),dimension(p,mmq),check(mmq==shape(x12,1)||p==shape(x12,0)),depend(p,mmq) :: x12
    double precision intent(in,out,copy,out=cs21),dimension(mmp,q),check(mmp==shape(x21,0)||q==shape(x21,1)),depend(mmp,q) :: x21

    integer intent(hide),depend(x11) :: p = shape(x11,0)
    integer intent(hide),depend(x11) :: q = shape(x11,1)
    integer intent(hide),depend(x22) :: mmp = shape(x22,0)
    integer intent(hide),depend(x22) :: mmq = shape(x22,1)

    integer intent(hide),depend(x11) :: ldx11 = MAX(1,shape(x11,0))
    integer intent(hide),depend(x12) :: ldx12 = MAX(1,shape(x12,0))
    integer intent(hide),depend(x21) :: ldx21 = MAX(1,shape(x21,0))
    integer intent(hide),depend(x22) :: ldx22 = MAX(1,shape(x22,0))

    double precision intent(out),dimension(min(min(p,mmp),min(q,mmq))),depend(p,q,mmp,mmq) :: theta
    double precision intent(out),dimension((compute_u1?p:0),(compute_u1?p:0)),depend(p) :: u1
    double precision intent(out),dimension((compute_u2?mmp:0),(compute_u2?mmp:0)),depend(mmp) :: u2
    double precision intent(out),dimension((compute_v1t?q:0),(compute_v1t?q:0)),depend(q) :: v1t
    double precision intent(out),dimension((compute_v2t?mmq:0),(compute_v2t?mmq:0)),depend(mmq) :: v2t

    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)

    double precision intent(hide),dimension(lwork),depend(lwork) :: work
    integer intent(hide),dimension(p+mmp-MIN(MIN(p,mmp),MIN(q,mmq))),depend(p,q,mmp,mmq) :: iwork

    integer optional,intent(in),check(lwork==-1||lwork>0),depend(m,mmp,mmq) :: lwork = 2 + 2*m + 5*MAX(1,q-1) + 4*MAX(1,q) + 8*q
    integer intent(out) :: info

end subroutine dorcsd



subroutine sorcsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq)
    ! LWORK computation for (S/D)ORCSD

    fortranname sorcsd
    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: p
    integer intent(in) :: q

    real intent(hide) :: x11
    real intent(hide) :: x22
    real intent(hide) :: x12
    real intent(hide) :: x21
    integer intent(hide),depend(m,p) :: mmp = m - p
    integer intent(hide),depend(m,q) :: mmq = m - q
    integer intent(hide),depend(p) :: ldx11 = MAX(1,p)
    integer intent(hide),depend(p) :: ldx12 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldx21 = MAX(1,mmp)
    integer intent(hide),depend(mmp) :: ldx22 = MAX(1,mmp)
    real intent(hide) :: theta
    real intent(hide) :: u1
    real intent(hide) :: u2
    real intent(hide) :: v1t
    real intent(hide) :: v2t
    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)
    integer intent(hide) :: iwork
    integer intent(hide) :: lwork = -1

    real intent(out) :: work
    integer intent(out) :: info

end subroutine sorcsd_lwork


subroutine dorcsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,iwork,info,mmp,mmq)
    ! LWORK computation for (S/D)ORCSD

    fortranname dorcsd
    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: p
    integer intent(in) :: q

    double precision intent(hide) :: x11
    double precision intent(hide) :: x22
    double precision intent(hide) :: x12
    double precision intent(hide) :: x21
    integer intent(hide),depend(m,p) :: mmp = m - p
    integer intent(hide),depend(m,q) :: mmq = m - q
    integer intent(hide),depend(p) :: ldx11 = MAX(1,p)
    integer intent(hide),depend(p) :: ldx12 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldx21 = MAX(1,mmp)
    integer intent(hide),depend(mmp) :: ldx22 = MAX(1,mmp)
    double precision intent(hide) :: theta
    double precision intent(hide) :: u1
    double precision intent(hide) :: u2
    double precision intent(hide) :: v1t
    double precision intent(hide) :: v2t
    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)
    integer intent(hide) :: iwork
    integer intent(hide) :: lwork = -1

    double precision intent(out) :: work
    integer intent(out) :: info

end subroutine dorcsd_lwork



subroutine cuncsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq)
    ! ZUNCSD computes the CS decomposition of an M-by-M partitioned
    ! unitary matrix X:
    !
    !                             [  I11 0  0  |  0    0  0   ]
    !                             [  0   C  0  |  0   -S  0   ]
    ! [ X11 | X12 ]   [ U1 |    ] [  0   0  0  |  0    0 -I12 ] [ V1 |    ]*
    ! [-----------] = [---------] [---------------------------] [---------]   .
    ! [ X21 | X22 ]   [    | U2 ] [  0  0  0   |  I22  0  0   ] [    | V2 ]
    !                             [  0  S  0   |  0    C  0   ]
    !                             [  0  0  I21 |  0    0  0   ]
    !
    ! U1, U2, V1, V2 are square orthogonal matrices of
    ! dimensions (p,p), (m-p,m-p), (q,q), (m-q,m-q), respectively,
    !  and C and S are (r, r) nonnegative diagonal matrices satisfying
    ! C^2 + S^2 = I where r = min(p, m-p, q, m-q).
    !
    !  Moreover, the rank of the identity matrices are min(p, q) - r,
    !  min(p, m - q) - r, min(m - p, q) - r, and min(m - p, m - q) - r
    !  respectively.
    

    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,rwork,&lrwork,iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(compute_u1==0||compute_u1==1) :: compute_u1 = 1
    integer optional,intent(in),check(compute_u2==0||compute_u2==1) :: compute_u2 = 1
    integer optional,intent(in),check(compute_v1t==0||compute_v1t==1) :: compute_v1t = 1
    integer optional,intent(in),check(compute_v2t==0||compute_v2t==1) :: compute_v2t = 1
    integer optional,intent(in),check(trans==0||trans==1) :: trans = 0
    integer optional,intent(in),check(signs==0||signs==1) :: signs = 0

    integer intent(hide),check(p+mmp==q+mmq),depend(p,q,mmp,mmq) :: m = p + mmp

    complex intent(in,out,copy,out=cs11),dimension(p,q) :: x11
    complex intent(in,out,copy,out=cs22),dimension(mmp,mmq) :: x22
    complex intent(in,out,copy,out=cs12),dimension(p,mmq),check(mmq==shape(x12,1)||p==shape(x12,0)),depend(p,mmq) :: x12
    complex intent(in,out,copy,out=cs21),dimension(mmp,q),check(mmp==shape(x21,0)||q==shape(x21,1)),depend(mmp,q) :: x21

    integer intent(hide),depend(x11) :: p = shape(x11,0)
    integer intent(hide),depend(x11) :: q = shape(x11,1)
    integer intent(hide),depend(x22) :: mmp = shape(x22,0)
    integer intent(hide),depend(x22) :: mmq = shape(x22,1)

    integer intent(hide),depend(x11) :: ldx11 = MAX(1,shape(x11,0))
    integer intent(hide),depend(x12) :: ldx12 = MAX(1,shape(x12,0))
    integer intent(hide),depend(x21) :: ldx21 = MAX(1,shape(x21,0))
    integer intent(hide),depend(x22) :: ldx22 = MAX(1,shape(x22,0))

    real intent(out),dimension(min(min(p,mmp),min(q,mmq))),depend(p,q,mmp,mmq) :: theta
    complex intent(out),dimension((compute_u1?p:0),(compute_u1?p:0)),depend(p) :: u1
    complex intent(out),dimension((compute_u2?mmp:0),(compute_u2?mmp:0)),depend(mmp) :: u2
    complex intent(out),dimension((compute_v1t?q:0),(compute_v1t?q:0)),depend(q) :: v1t
    complex intent(out),dimension((compute_v2t?mmq:0),(compute_v2t?mmq:0)),depend(mmq) :: v2t

    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)

    complex intent(hide),dimension(lwork),depend(lwork) :: work
    real intent(hide),dimension(lrwork),depend(lrwork) :: rwork
    integer intent(hide),dimension(p+mmp-MIN(MIN(p,mmp),MIN(q,mmq))),depend(p,q,mmp,mmq) :: iwork

    integer optional,intent(in),check(lwork==-1||lwork>0),depend(m,mmp,mmq) :: lwork = 2*m + MAX(1,MAX(mmp,mmq)) + 1
    integer optional,intent(in),check(lrwork==-1||lrwork>0),depend(q) :: lrwork = 5*MAX(1,q-1) + 4*MAX(1,q) + 8*q + 1
    integer intent(out) :: info

end subroutine cuncsd


subroutine zuncsd(compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq)
    ! ZUNCSD computes the CS decomposition of an M-by-M partitioned
    ! unitary matrix X:
    !
    !                             [  I11 0  0  |  0    0  0   ]
    !                             [  0   C  0  |  0   -S  0   ]
    ! [ X11 | X12 ]   [ U1 |    ] [  0   0  0  |  0    0 -I12 ] [ V1 |    ]*
    ! [-----------] = [---------] [---------------------------] [---------]   .
    ! [ X21 | X22 ]   [    | U2 ] [  0  0  0   |  I22  0  0   ] [    | V2 ]
    !                             [  0  S  0   |  0    C  0   ]
    !                             [  0  0  I21 |  0    0  0   ]
    !
    ! U1, U2, V1, V2 are square orthogonal matrices of
    ! dimensions (p,p), (m-p,m-p), (q,q), (m-q,m-q), respectively,
    !  and C and S are (r, r) nonnegative diagonal matrices satisfying
    ! C^2 + S^2 = I where r = min(p, m-p, q, m-q).
    !
    !  Moreover, the rank of the identity matrices are min(p, q) - r,
    !  min(p, m - q) - r, min(m - p, q) - r, and min(m - p, m - q) - r
    !  respectively.
    

    callstatement (*f2py_func)((compute_u1?"Y":"N"),(compute_u2?"Y":"N"),(compute_v1t?"Y":"N"),(compute_v2t?"Y":"N"),(trans?"T":"N"),(signs?"O":"D"),&m,&p,&q,x11,&ldx11,x12,&ldx12,x21,&ldx21,x22,&ldx22,theta,u1,&ldu1,u2,&ldu2,v1t,&ldv1t,v2t,&ldv2t,work,&lwork,rwork,&lrwork,iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in),check(compute_u1==0||compute_u1==1) :: compute_u1 = 1
    integer optional,intent(in),check(compute_u2==0||compute_u2==1) :: compute_u2 = 1
    integer optional,intent(in),check(compute_v1t==0||compute_v1t==1) :: compute_v1t = 1
    integer optional,intent(in),check(compute_v2t==0||compute_v2t==1) :: compute_v2t = 1
    integer optional,intent(in),check(trans==0||trans==1) :: trans = 0
    integer optional,intent(in),check(signs==0||signs==1) :: signs = 0

    integer intent(hide),check(p+mmp==q+mmq),depend(p,q,mmp,mmq) :: m = p + mmp

    double complex intent(in,out,copy,out=cs11),dimension(p,q) :: x11
    double complex intent(in,out,copy,out=cs22),dimension(mmp,mmq) :: x22
    double complex intent(in,out,copy,out=cs12),dimension(p,mmq),check(mmq==shape(x12,1)||p==shape(x12,0)),depend(p,mmq) :: x12
    double complex intent(in,out,copy,out=cs21),dimension(mmp,q),check(mmp==shape(x21,0)||q==shape(x21,1)),depend(mmp,q) :: x21

    integer intent(hide),depend(x11) :: p = shape(x11,0)
    integer intent(hide),depend(x11) :: q = shape(x11,1)
    integer intent(hide),depend(x22) :: mmp = shape(x22,0)
    integer intent(hide),depend(x22) :: mmq = shape(x22,1)

    integer intent(hide),depend(x11) :: ldx11 = MAX(1,shape(x11,0))
    integer intent(hide),depend(x12) :: ldx12 = MAX(1,shape(x12,0))
    integer intent(hide),depend(x21) :: ldx21 = MAX(1,shape(x21,0))
    integer intent(hide),depend(x22) :: ldx22 = MAX(1,shape(x22,0))

    double precision intent(out),dimension(min(min(p,mmp),min(q,mmq))),depend(p,q,mmp,mmq) :: theta
    double complex intent(out),dimension((compute_u1?p:0),(compute_u1?p:0)),depend(p) :: u1
    double complex intent(out),dimension((compute_u2?mmp:0),(compute_u2?mmp:0)),depend(mmp) :: u2
    double complex intent(out),dimension((compute_v1t?q:0),(compute_v1t?q:0)),depend(q) :: v1t
    double complex intent(out),dimension((compute_v2t?mmq:0),(compute_v2t?mmq:0)),depend(mmq) :: v2t

    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)

    double complex intent(hide),dimension(lwork),depend(lwork) :: work
    double precision intent(hide),dimension(lrwork),depend(lrwork) :: rwork
    integer intent(hide),dimension(p+mmp-MIN(MIN(p,mmp),MIN(q,mmq))),depend(p,q,mmp,mmq) :: iwork

    integer optional,intent(in),check(lwork==-1||lwork>0),depend(m,mmp,mmq) :: lwork = 2*m + MAX(1,MAX(mmp,mmq)) + 1
    integer optional,intent(in),check(lrwork==-1||lrwork>0),depend(q) :: lrwork = 5*MAX(1,q-1) + 4*MAX(1,q) + 8*q + 1
    integer intent(out) :: info

end subroutine zuncsd



subroutine cuncsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq)
    ! LWORK computation for (C/Z)UNCSD

    fortranname cuncsd
    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&rwork,&lrwork,&iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: p
    integer intent(in) :: q

    complex intent(hide) :: x11
    complex intent(hide) :: x22
    complex intent(hide) :: x12
    complex intent(hide) :: x21
    integer intent(hide),depend(m,p) :: mmp = m - p
    integer intent(hide),depend(m,q) :: mmq = m - q
    integer intent(hide),depend(p) :: ldx11 = MAX(1,p)
    integer intent(hide),depend(p) :: ldx12 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldx21 = MAX(1,mmp)
    integer intent(hide),depend(mmp) :: ldx22 = MAX(1,mmp)
    real intent(hide) :: theta
    complex intent(hide) :: u1
    complex intent(hide) :: u2
    complex intent(hide) :: v1t
    complex intent(hide) :: v2t
    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)
    integer intent(hide) :: iwork
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: lrwork = -1

    complex intent(out) :: work
    real intent(out) :: rwork
    integer intent(out) :: info

end subroutine cuncsd_lwork


subroutine zuncsd_lwork(m,p,q,x11,ldx11,x12,ldx12,x21,ldx21,x22,ldx22,theta,u1,ldu1,u2,ldu2,v1t,ldv1t,v2t,ldv2t,work,lwork,rwork,lrwork,iwork,info,mmp,mmq)
    ! LWORK computation for (C/Z)UNCSD

    fortranname zuncsd
    callstatement (*f2py_func)("Y","Y","Y","Y","N","D",&m,&p,&q,&x11,&ldx11,&x12,&ldx12,&x21,&ldx21,&x22,&ldx22,&theta,&u1,&ldu1,&u2,&ldu2,&v1t,&ldv1t,&v2t,&ldv2t,&work,&lwork,&rwork,&lrwork,&iwork,&info)
    callprotoargument char*,char*,char*,char*,char*,char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    integer intent(in) :: m
    integer intent(in) :: p
    integer intent(in) :: q

    double complex intent(hide) :: x11
    double complex intent(hide) :: x22
    double complex intent(hide) :: x12
    double complex intent(hide) :: x21
    integer intent(hide),depend(m,p) :: mmp = m - p
    integer intent(hide),depend(m,q) :: mmq = m - q
    integer intent(hide),depend(p) :: ldx11 = MAX(1,p)
    integer intent(hide),depend(p) :: ldx12 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldx21 = MAX(1,mmp)
    integer intent(hide),depend(mmp) :: ldx22 = MAX(1,mmp)
    double precision intent(hide) :: theta
    double complex intent(hide) :: u1
    double complex intent(hide) :: u2
    double complex intent(hide) :: v1t
    double complex intent(hide) :: v2t
    integer intent(hide),depend(p) :: ldu1 = MAX(1,p)
    integer intent(hide),depend(mmp) :: ldu2 = MAX(1,mmp)
    integer intent(hide),depend(q) :: ldv1t = MAX(1,q)
    integer intent(hide),depend(mmq) :: ldv2t = MAX(1,mmq)
    integer intent(hide) :: iwork
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: lrwork = -1

    double complex intent(out) :: work
    double precision intent(out) :: rwork
    integer intent(out) :: info

end subroutine zuncsd_lwork



subroutine sorghr(n,lo,hi,a,tau,work,lwork,info)
    !
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    real dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    real dimension(n-1),intent(in),depend(n) :: tau
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine sorghr


subroutine dorghr(n,lo,hi,a,tau,work,lwork,info)
    !
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double precision dimension(n-1),intent(in),depend(n) :: tau
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine dorghr



subroutine sorghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation ofr orghr
    fortranname sorghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*
    integer intent(in) :: n
    real intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine sorghr_lwork


subroutine dorghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation ofr orghr
    fortranname dorghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*
    integer intent(in) :: n
    double precision intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine dorghr_lwork



subroutine cunghr(n,lo,hi,a,tau,work,lwork,info)
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    complex dimension(n-1),intent(in),depend(n) :: tau
    complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine cunghr


subroutine zunghr(n,lo,hi,a,tau,work,lwork,info)
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double complex dimension(n-1),intent(in),depend(n) :: tau
    double complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine zunghr



subroutine cunghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for orghr
    fortranname cunghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*
    integer intent(in) :: n
    complex intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine cunghr_lwork


subroutine zunghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for orghr
    fortranname zunghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*
    integer intent(in) :: n
    double complex intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine zunghr_lwork



subroutine sorgqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    real dimension(m,n),intent(in,out,copy,out=q) :: a
    real dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sorgqr


subroutine dorgqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double precision dimension(m,n),intent(in,out,copy,out=q) :: a
    double precision dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dorgqr



subroutine cungqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    complex dimension(m,n),intent(in,out,copy,out=q) :: a
    complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cungqr


subroutine zungqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double complex dimension(m,n),intent(in,out,copy,out=q) :: a
    double complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zungqr



subroutine sormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = ormqr(side,trans,a,tau,c,lwork)
    ! multiplies the real matrix C with the real orthogonal matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='T'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    real dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    real dimension(k),intent(in):: tau
    real dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    real dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine sormqr


subroutine dormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = ormqr(side,trans,a,tau,c,lwork)
    ! multiplies the real matrix C with the real orthogonal matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='T'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    double precision dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    double precision dimension(k),intent(in):: tau
    double precision dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    double precision dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine dormqr



subroutine cunmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = unmqr(side,trans,a,tau,c,lwork)
    ! multiplies the complex matrix C with the complex unitary matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='C'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    complex dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    complex dimension(k),intent(in):: tau
    complex dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    complex dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine cunmqr


subroutine zunmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = unmqr(side,trans,a,tau,c,lwork)
    ! multiplies the complex matrix C with the complex unitary matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='C'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    double complex dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    double complex dimension(k),intent(in):: tau
    double complex dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    double complex dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine zunmqr



subroutine sgeqrt(m,n,nb,a,lda,t,ldt,work,info)
    ! a,t,info = geqrt(nb,a,[overwrite_a=0])
    !
    ! Computes a QR factorization with block size nb of a general matrix A,
    ! using the compact WY representation for Q. T stores the upper triangular
    ! block reflectors.

    callstatement (*f2py_func)(&m,&n,&nb,a,&lda,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=nb&&nb>=1):: nb
    real dimension(m,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    real dimension(nb,MIN(m,n)),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    real dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine sgeqrt


subroutine dgeqrt(m,n,nb,a,lda,t,ldt,work,info)
    ! a,t,info = geqrt(nb,a,[overwrite_a=0])
    !
    ! Computes a QR factorization with block size nb of a general matrix A,
    ! using the compact WY representation for Q. T stores the upper triangular
    ! block reflectors.

    callstatement (*f2py_func)(&m,&n,&nb,a,&lda,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=nb&&nb>=1):: nb
    double precision dimension(m,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double precision dimension(nb,MIN(m,n)),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double precision dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine dgeqrt


subroutine cgeqrt(m,n,nb,a,lda,t,ldt,work,info)
    ! a,t,info = geqrt(nb,a,[overwrite_a=0])
    !
    ! Computes a QR factorization with block size nb of a general matrix A,
    ! using the compact WY representation for Q. T stores the upper triangular
    ! block reflectors.

    callstatement (*f2py_func)(&m,&n,&nb,a,&lda,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=nb&&nb>=1):: nb
    complex dimension(m,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    complex dimension(nb,MIN(m,n)),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    complex dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine cgeqrt


subroutine zgeqrt(m,n,nb,a,lda,t,ldt,work,info)
    ! a,t,info = geqrt(nb,a,[overwrite_a=0])
    !
    ! Computes a QR factorization with block size nb of a general matrix A,
    ! using the compact WY representation for Q. T stores the upper triangular
    ! block reflectors.

    callstatement (*f2py_func)(&m,&n,&nb,a,&lda,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=nb&&nb>=1):: nb
    double complex dimension(m,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double complex dimension(nb,MIN(m,n)),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double complex dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine zgeqrt



subroutine sgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
    ! c,info = gemqrt(side,trans,v,t,c,[overwrite_c=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in matrix V and the upper triangular block
    ! reflectors in matrix T. C may be multiplied by Q, its transpose (for real
    ! matrices), or its adjoint (for complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&nb,v,&ldv,t,&ldt,c,&ldc,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(m,n,v),check((*side=='L'?m:n)>=k&&k>=0):: k = shape(v,1)
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    real dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    real dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    real dimension(m,n),intent(in,out,copy):: c
    integer intent(hide),depend(c):: ldc = MAX(1,shape(c,0))
    real dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine sgemqrt


subroutine dgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
    ! c,info = gemqrt(side,trans,v,t,c,[overwrite_c=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in matrix V and the upper triangular block
    ! reflectors in matrix T. C may be multiplied by Q, its transpose (for real
    ! matrices), or its adjoint (for complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&nb,v,&ldv,t,&ldt,c,&ldc,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(m,n,v),check((*side=='L'?m:n)>=k&&k>=0):: k = shape(v,1)
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    double precision dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    double precision dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double precision dimension(m,n),intent(in,out,copy):: c
    integer intent(hide),depend(c):: ldc = MAX(1,shape(c,0))
    double precision dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine dgemqrt


subroutine cgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
    ! c,info = gemqrt(side,trans,v,t,c,[overwrite_c=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in matrix V and the upper triangular block
    ! reflectors in matrix T. C may be multiplied by Q, its transpose (for real
    ! matrices), or its adjoint (for complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&nb,v,&ldv,t,&ldt,c,&ldc,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(m,n,v),check((*side=='L'?m:n)>=k&&k>=0):: k = shape(v,1)
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    complex dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    complex dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    complex dimension(m,n),intent(in,out,copy):: c
    integer intent(hide),depend(c):: ldc = MAX(1,shape(c,0))
    complex dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine cgemqrt


subroutine zgemqrt(side,trans,m,n,k,nb,v,ldv,t,ldt,c,ldc,work,info)
    ! c,info = gemqrt(side,trans,v,t,c,[overwrite_c=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in matrix V and the upper triangular block
    ! reflectors in matrix T. C may be multiplied by Q, its transpose (for real
    ! matrices), or its adjoint (for complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&nb,v,&ldv,t,&ldt,c,&ldc,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(m,n,v),check((*side=='L'?m:n)>=k&&k>=0):: k = shape(v,1)
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    double complex dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    double complex dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double complex dimension(m,n),intent(in,out,copy):: c
    integer intent(hide),depend(c):: ldc = MAX(1,shape(c,0))
    double complex dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine zgemqrt



subroutine stpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
    ! a,b,t,info = tpqrt(l,nb,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Computes a QR factorization with block size nb of a triangular-pentagonal
    ! matrix consisting of square upper triangular matrix A and pentagonal
    ! matrix B, in the compact WY representation. L is the order of the
    ! trapezoidal part of matrix B. T stores the upper triangular block
    ! reflectors.

    callstatement (*f2py_func)(&m,&n,&l,&nb,a,&lda,b,&ldb,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*

    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=l&&l>=0):: l
    integer intent(in),depend(n),check(n>=nb&&nb>=1):: nb
    real dimension(n,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    real dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    real dimension(nb,n),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    real dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine stpqrt


subroutine dtpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
    ! a,b,t,info = tpqrt(l,nb,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Computes a QR factorization with block size nb of a triangular-pentagonal
    ! matrix consisting of square upper triangular matrix A and pentagonal
    ! matrix B, in the compact WY representation. L is the order of the
    ! trapezoidal part of matrix B. T stores the upper triangular block
    ! reflectors.

    callstatement (*f2py_func)(&m,&n,&l,&nb,a,&lda,b,&ldb,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*

    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=l&&l>=0):: l
    integer intent(in),depend(n),check(n>=nb&&nb>=1):: nb
    double precision dimension(n,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double precision dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    double precision dimension(nb,n),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double precision dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine dtpqrt


subroutine ctpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
    ! a,b,t,info = tpqrt(l,nb,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Computes a QR factorization with block size nb of a triangular-pentagonal
    ! matrix consisting of square upper triangular matrix A and pentagonal
    ! matrix B, in the compact WY representation. L is the order of the
    ! trapezoidal part of matrix B. T stores the upper triangular block
    ! reflectors.

    callstatement (*f2py_func)(&m,&n,&l,&nb,a,&lda,b,&ldb,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*

    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=l&&l>=0):: l
    integer intent(in),depend(n),check(n>=nb&&nb>=1):: nb
    complex dimension(n,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    complex dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    complex dimension(nb,n),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    complex dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine ctpqrt


subroutine ztpqrt(m,n,l,nb,a,lda,b,ldb,t,ldt,work,info)
    ! a,b,t,info = tpqrt(l,nb,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Computes a QR factorization with block size nb of a triangular-pentagonal
    ! matrix consisting of square upper triangular matrix A and pentagonal
    ! matrix B, in the compact WY representation. L is the order of the
    ! trapezoidal part of matrix B. T stores the upper triangular block
    ! reflectors.

    callstatement (*f2py_func)(&m,&n,&l,&nb,a,&lda,b,&ldb,t,&ldt,work,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*

    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(in),depend(m,n),check(MIN(m,n)>=l&&l>=0):: l
    integer intent(in),depend(n),check(n>=nb&&nb>=1):: nb
    double complex dimension(n,n),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double complex dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    double complex dimension(nb,n),intent(out):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double complex dimension(nb,n),intent(hide,cache):: work
    integer intent(out):: info

end subroutine ztpqrt



subroutine stpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,info)
    ! a,b,info = tpmqrt(side,trans,l,v,t,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in the pentagonal matrix V and the upper
    ! triangular block reflectors in matrix T. L is the order of the trapezoidal
    ! part of matrix V. Matrix C consists of blocks A and B, and may be
    ! multiplied by Q, its transpose (for real matrices), or its adjoint (for
    ! complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&nb,v,&ldv,t,&ldt,a,&lda,b,&ldb,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(hide),depend(t):: k = shape(t,1)
    integer intent(in),depend(k),check(k>=l&&l>=0):: l
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    real dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    real dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    real dimension((side[0]=='L'?k:m),(side[0]=='L'?n:k)),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    real dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    real dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine stpmqrt


subroutine dtpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,info)
    ! a,b,info = tpmqrt(side,trans,l,v,t,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in the pentagonal matrix V and the upper
    ! triangular block reflectors in matrix T. L is the order of the trapezoidal
    ! part of matrix V. Matrix C consists of blocks A and B, and may be
    ! multiplied by Q, its transpose (for real matrices), or its adjoint (for
    ! complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&nb,v,&ldv,t,&ldt,a,&lda,b,&ldb,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(hide),depend(t):: k = shape(t,1)
    integer intent(in),depend(k),check(k>=l&&l>=0):: l
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    double precision dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    double precision dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double precision dimension((side[0]=='L'?k:m),(side[0]=='L'?n:k)),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double precision dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    double precision dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine dtpmqrt


subroutine ctpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,info)
    ! a,b,info = tpmqrt(side,trans,l,v,t,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in the pentagonal matrix V and the upper
    ! triangular block reflectors in matrix T. L is the order of the trapezoidal
    ! part of matrix V. Matrix C consists of blocks A and B, and may be
    ! multiplied by Q, its transpose (for real matrices), or its adjoint (for
    ! complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&nb,v,&ldv,t,&ldt,a,&lda,b,&ldb,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(hide),depend(t):: k = shape(t,1)
    integer intent(in),depend(k),check(k>=l&&l>=0):: l
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    complex dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    complex dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    complex dimension((side[0]=='L'?k:m),(side[0]=='L'?n:k)),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    complex dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    complex dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine ctpmqrt


subroutine ztpmqrt(side,trans,m,n,k,l,nb,v,ldv,t,ldt,a,lda,b,ldb,work,info)
    ! a,b,info = tpmqrt(side,trans,l,v,t,a,b,[overwrite_a=0,overwrite_b=0])
    !
    ! Multiplies a general matrix C by the orthogonal matrix Q defined by the
    ! elementary reflectors stored in the pentagonal matrix V and the upper
    ! triangular block reflectors in matrix T. L is the order of the trapezoidal
    ! part of matrix V. Matrix C consists of blocks A and B, and may be
    ! multiplied by Q, its transpose (for real matrices), or its adjoint (for
    ! complex matrices) from the left or right.

    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&nb,v,&ldv,t,&ldt,a,&lda,b,&ldb,work,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(b):: m = shape(b,0)
    integer intent(hide),depend(b):: n = shape(b,1)
    integer intent(hide),depend(t):: k = shape(t,1)
    integer intent(in),depend(k),check(k>=l&&l>=0):: l
    integer intent(hide),depend(k,t),check(k>=nb&&nb>=1):: nb = shape(t,0)
    double complex dimension((side[0]=='L'?m:n),k),intent(in):: v
    integer intent(hide),depend(v):: ldv = MAX(1,shape(v,0))
    double complex dimension(nb,k),intent(in):: t
    integer intent(hide),depend(t):: ldt = MAX(1,shape(t,0))
    double complex dimension((side[0]=='L'?k:m),(side[0]=='L'?n:k)),intent(in,out,copy):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double complex dimension(m,n),intent(in,out,copy):: b
    integer intent(hide),depend(b):: ldb = MAX(1,shape(b,0))
    double complex dimension((side[0]=='L'?n:m)*nb),intent(hide,cache):: work
    integer intent(out):: info

end subroutine ztpmqrt



subroutine sormrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    real dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    real dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    real dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    real dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine sormrz


subroutine dormrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    double precision dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double precision dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    double precision dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    double precision dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine dormrz


subroutine cunmrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    complex dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    complex dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    complex dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    complex dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine cunmrz


subroutine zunmrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    double complex dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double complex dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    double complex dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    double complex dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine zunmrz



subroutine sormrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname sormrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    real intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    real intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    real intent(hide):: tau
    real intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info

end subroutine sormrz_lwork


subroutine dormrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname dormrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    double precision intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    double precision intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    double precision intent(hide):: tau
    double precision intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info

end subroutine dormrz_lwork


subroutine cunmrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname cunmrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    complex intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    complex intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    complex intent(hide):: tau
    complex intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info

end subroutine cunmrz_lwork


subroutine zunmrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname zunmrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    double complex intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    double complex intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    double complex intent(hide):: tau
    double complex intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info

end subroutine zunmrz_lwork



subroutine sorgrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    real dimension(m,n),intent(in,out,copy,out=q) :: a
    real dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sorgrq


subroutine dorgrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double precision dimension(m,n),intent(in,out,copy,out=q) :: a
    double precision dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dorgrq



subroutine cungrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    complex dimension(m,n),intent(in,out,copy,out=q) :: a
    complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cungrq


subroutine zungrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double complex dimension(m,n),intent(in,out,copy,out=q) :: a
    double complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zungrq



subroutine strtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    real dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine strtri


subroutine dtrtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double precision dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine dtrtri


subroutine ctrtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    complex dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine ctrtri


subroutine ztrtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double complex dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine ztrtri



subroutine strsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    real dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    real dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    real dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    real intent(out) :: scale

    integer intent(out) :: info

end subroutine strsyl


subroutine dtrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    double precision dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    double precision dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    double precision dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    double precision intent(out) :: scale

    integer intent(out) :: info

end subroutine dtrsyl


subroutine ctrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    complex dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    complex dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    complex dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    real intent(out) :: scale

    integer intent(out) :: info

end subroutine ctrsyl


subroutine ztrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    double complex dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    double complex dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    double complex dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    double precision intent(out) :: scale

    integer intent(out) :: info

end subroutine ztrsyl



subroutine chbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! in :Band:zubevd.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    complex dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    ! case n=0 is omitted in calculaton of lwork, lrwork, liwork
    ! so we forbid it
    check( n>0 ) n
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    real dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    complex dimension(ldz,ldz),intent(out),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?2*n*n:n),1)
    complex dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional, check(lrwork>=(compute_v?1+5*n+2*n*n:n)),depend(n) :: lrwork=(compute_v?1+5*n+2*n*n:n)

    real intent(hide),dimension(lrwork),depend(lrwork) :: rwork

    ! documentation says liwork >=2+5*n, but that crashes, +1 helps
    integer optional, check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine chbevd


subroutine zhbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! in :Band:zubevd.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double complex dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    ! case n=0 is omitted in calculaton of lwork, lrwork, liwork
    ! so we forbid it
    check( n>0 ) n
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    double precision dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double complex dimension(ldz,ldz),intent(out),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?2*n*n:n),1)
    double complex dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional, check(lrwork>=(compute_v?1+5*n+2*n*n:n)),depend(n) :: lrwork=(compute_v?1+5*n+2*n*n:n)

    double precision intent(hide),dimension(lrwork),depend(lrwork) :: rwork

    ! documentation says liwork >=2+5*n, but that crashes, +1 helps
    integer optional, check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine zhbevd



subroutine chbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,rwork,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,rwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,complex_float*,F_INT*,complex_float*,float*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    complex dimension(ldab,n),intent(in, overwrite) :: ab

    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    complex dimension(ldq,ldq),intent(hide),depend(ldq) :: q

    real :: vl
    real :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    real optional,intent(in):: abstol=0.0

    real dimension(n),intent(out),depend(n) :: w

    complex dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    complex dimension(n),depend(n),intent(hide) :: work
    real dimension(7*n),depend(n),intent(hide) :: rwork
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine chbevx


subroutine zhbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,rwork,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,rwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,complex_double*,F_INT*,complex_double*,double*,F_INT*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double complex dimension(ldab,n),intent(in, overwrite) :: ab

    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    double complex dimension(ldq,ldq),intent(hide),depend(ldq) :: q

    double precision :: vl
    double precision :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    double precision optional,intent(in):: abstol=0.0

    double precision dimension(n),intent(out),depend(n) :: w

    double complex dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    double complex dimension(n),depend(n),intent(hide) :: work
    double precision dimension(7*n),depend(n),intent(hide) :: rwork
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine zhbevx



subroutine sgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    real dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    real dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    real dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    real dimension(p),depend(p),intent(in,copy) :: d
    real dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    real intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine sgglse


subroutine dgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    double precision dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    double precision dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    double precision dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    double precision dimension(p),depend(p),intent(in,copy) :: d
    double precision dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    double precision intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine dgglse


subroutine cgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    complex dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    complex dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    complex dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    complex dimension(p),depend(p),intent(in,copy) :: d
    complex dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    complex intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine cgglse


subroutine zgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    double complex dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    double complex dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    double complex dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    double complex dimension(p),depend(p),intent(in,copy) :: d
    double complex dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    double complex intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine zgglse




subroutine sgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname sgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    real intent(out) :: work

    real intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    real intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    real intent(hide) :: c
    real intent(hide) :: d
    real intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine sgglse_lwork



subroutine dgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname dgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    double precision intent(out) :: work

    double precision intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    double precision intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    double precision intent(hide) :: c
    double precision intent(hide) :: d
    double precision intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine dgglse_lwork



subroutine cgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname cgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    complex intent(out) :: work

    complex intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    complex intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    complex intent(hide) :: c
    complex intent(hide) :: d
    complex intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine cgglse_lwork



subroutine zgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname zgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    double complex intent(out) :: work

    double complex intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    double complex intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    double complex intent(hide) :: c
    double complex intent(hide) :: d
    double complex intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine zgglse_lwork



subroutine sppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
    ! ?PPCON estimates the reciprocal of the condition number (in the
    ! 1-norm) of a symmetric/Hermitian positive definite packed matrix using
    ! the Cholesky factorization A = U**T*U or A = L*L**T computed by
    ! DPPTRF.
    !
    ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
    ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    real dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    real intent(in):: anorm
    real intent(out):: rcond
    real depend(n),dimension(3*n),intent(hide,cache):: work
    integer dimension(n), intent(hide,cache),depend(n) :: irwork
    integer intent(out):: info
 
end subroutine sppcon


subroutine dppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
    ! ?PPCON estimates the reciprocal of the condition number (in the
    ! 1-norm) of a symmetric/Hermitian positive definite packed matrix using
    ! the Cholesky factorization A = U**T*U or A = L*L**T computed by
    ! DPPTRF.
    !
    ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
    ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    double precision dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double precision depend(n),dimension(3*n),intent(hide,cache):: work
    integer dimension(n), intent(hide,cache),depend(n) :: irwork
    integer intent(out):: info
 
end subroutine dppcon


subroutine cppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
    ! ?PPCON estimates the reciprocal of the condition number (in the
    ! 1-norm) of a symmetric/Hermitian positive definite packed matrix using
    ! the Cholesky factorization A = U**T*U or A = L*L**T computed by
    ! DPPTRF.
    !
    ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
    ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,complex_float*,float*,float*,complex_float*,float*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    complex dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    real intent(in):: anorm
    real intent(out):: rcond
    complex depend(n),dimension(2*n),intent(hide,cache):: work
    real dimension(n), intent(hide,cache),depend(n) :: irwork
    integer intent(out):: info
 
end subroutine cppcon


subroutine zppcon(lower,n,ap,anorm,rcond,work,irwork,info,L)
    ! ?PPCON estimates the reciprocal of the condition number (in the
    ! 1-norm) of a symmetric/Hermitian positive definite packed matrix using
    ! the Cholesky factorization A = U**T*U or A = L*L**T computed by
    ! DPPTRF.
    !
    ! An estimate is obtained for norm(inv(A)), and the reciprocal of the
    ! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,F_INT*,complex_double*,double*,double*,complex_double*,double*,F_INT*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    double complex dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double complex depend(n),dimension(2*n),intent(hide,cache):: work
    double precision dimension(n), intent(hide,cache),depend(n) :: irwork
    integer intent(out):: info
 
end subroutine zppcon



subroutine sppsv(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPSV computes the solution to a real system of linear equations
    !    A * X = B,
    ! where A is an N-by-N symmetric positive definite matrix stored in
    ! packed format and X and B are N-by-NRHS matrices.
    !
    ! The Cholesky decomposition is used to factor A as
    !    A = U**T* U,  if UPLO = 'U', or
    !    A = L * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is a lower triangular
    ! matrix.  The factored form of A is then used to solve the system of
    ! equations A * X = B.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,float*,float*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    real dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    real dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine sppsv


subroutine dppsv(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPSV computes the solution to a real system of linear equations
    !    A * X = B,
    ! where A is an N-by-N symmetric positive definite matrix stored in
    ! packed format and X and B are N-by-NRHS matrices.
    !
    ! The Cholesky decomposition is used to factor A as
    !    A = U**T* U,  if UPLO = 'U', or
    !    A = L * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is a lower triangular
    ! matrix.  The factored form of A is then used to solve the system of
    ! equations A * X = B.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,double*,double*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    double precision dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    double precision dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine dppsv


subroutine cppsv(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPSV computes the solution to a real system of linear equations
    !    A * X = B,
    ! where A is an N-by-N symmetric positive definite matrix stored in
    ! packed format and X and B are N-by-NRHS matrices.
    !
    ! The Cholesky decomposition is used to factor A as
    !    A = U**T* U,  if UPLO = 'U', or
    !    A = L * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is a lower triangular
    ! matrix.  The factored form of A is then used to solve the system of
    ! equations A * X = B.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    complex dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine cppsv


subroutine zppsv(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPSV computes the solution to a real system of linear equations
    !    A * X = B,
    ! where A is an N-by-N symmetric positive definite matrix stored in
    ! packed format and X and B are N-by-NRHS matrices.
    !
    ! The Cholesky decomposition is used to factor A as
    !    A = U**T* U,  if UPLO = 'U', or
    !    A = L * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is a lower triangular
    ! matrix.  The factored form of A is then used to solve the system of
    ! equations A * X = B.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    double complex dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    double complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine zppsv



subroutine spptrf(lower,n,ap,info,L)
    ! ?PPTRF computes the Cholesky factorization of a symmetric/hermitian
    ! positive definite matrix A stored in packed format.
    ! 
    ! The factorization has the form
    !    A = U**T * U,  if UPLO = 'U', or
    !    A = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,float*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    real dimension(L),intent(in,out,copy,out=ul) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinespptrf


subroutine dpptrf(lower,n,ap,info,L)
    ! ?PPTRF computes the Cholesky factorization of a symmetric/hermitian
    ! positive definite matrix A stored in packed format.
    ! 
    ! The factorization has the form
    !    A = U**T * U,  if UPLO = 'U', or
    !    A = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,double*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    double precision dimension(L),intent(in,out,copy,out=ul) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinedpptrf


subroutine cpptrf(lower,n,ap,info,L)
    ! ?PPTRF computes the Cholesky factorization of a symmetric/hermitian
    ! positive definite matrix A stored in packed format.
    ! 
    ! The factorization has the form
    !    A = U**T * U,  if UPLO = 'U', or
    !    A = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    complex dimension(L),intent(in,out,copy,out=ul) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinecpptrf


subroutine zpptrf(lower,n,ap,info,L)
    ! ?PPTRF computes the Cholesky factorization of a symmetric/hermitian
    ! positive definite matrix A stored in packed format.
    ! 
    ! The factorization has the form
    !    A = U**T * U,  if UPLO = 'U', or
    !    A = L  * L**T,  if UPLO = 'L',
    ! where U is an upper triangular matrix and L is lower triangular.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    double complex dimension(L),intent(in,out,copy,out=ul) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinezpptrf



subroutine spptri(lower,n,ap,info,L)
    ! ?PPTRI computes the inverse of a symmetric/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
    ! computed by ?PPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,float*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    real dimension(L),intent(in,out,copy,out=uli) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinespptri


subroutine dpptri(lower,n,ap,info,L)
    ! ?PPTRI computes the inverse of a symmetric/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
    ! computed by ?PPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,double*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    double precision dimension(L),intent(in,out,copy,out=uli) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinedpptri


subroutine cpptri(lower,n,ap,info,L)
    ! ?PPTRI computes the inverse of a symmetric/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
    ! computed by ?PPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    complex dimension(L),intent(in,out,copy,out=uli) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinecpptri


subroutine zpptri(lower,n,ap,info,L)
    ! ?PPTRI computes the inverse of a symmetric/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
    ! computed by ?PPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,ap,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    double complex dimension(L),intent(in,out,copy,out=uli) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    integer intent(out) :: info

end subroutinezpptri



subroutine spptrs(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPTRS solves a system of linear equations A*X = B with a symmetric
    ! positive definite matrix A in packed storage using the Cholesky
    ! factorization A = U**T*U or A = L*L**T computed by DPPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,float*,float*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    real dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    real dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine spptrs


subroutine dpptrs(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPTRS solves a system of linear equations A*X = B with a symmetric
    ! positive definite matrix A in packed storage using the Cholesky
    ! factorization A = U**T*U or A = L*L**T computed by DPPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,double*,double*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    double precision dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    double precision dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine dpptrs


subroutine cpptrs(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPTRS solves a system of linear equations A*X = B with a symmetric
    ! positive definite matrix A in packed storage using the Cholesky
    ! factorization A = U**T*U or A = L*L**T computed by DPPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    complex dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine cpptrs


subroutine zpptrs(lower,n,nrhs,ap,b,ldb,info,L)
    ! DPPTRS solves a system of linear equations A*X = B with a symmetric
    ! positive definite matrix A in packed storage using the Cholesky
    ! factorization A = U**T*U or A = L*L**T computed by DPPTRF.
    threadsafe
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,ap,b,&ldb,&info)
    callprotoargument char*,F_INT*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*
    
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in),check(n>=0) :: n
    integer intent(hide),depend(b) :: ldb = max(1, shape(b,0))
    integer intent(hide),depend(b) :: nrhs = shape(b,1)
    double complex dimension(L),intent(in) :: ap
    integer intent(hide),depend(ap,n),check(L>=(n*(n+1)/2)) :: L = len(ap)
    double complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer intent(out) :: info

end subroutine zpptrs



subroutine ssbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info)
    ! in :Band:dsbev.f
    ! principally ssbevd does the same, and are recommended for use.
    ! (see man dsbevd)

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&info)

    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    real dimension(ldab,n), intent(in,overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    real dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    real dimension(ldz,ldz),intent(out),depend(ldz) :: z

    real dimension(MAX(1,3*n-1)),intent(hide),depend(n) :: work
    integer intent(out)::info

end subroutine ssbev


subroutine dsbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info)
    ! in :Band:dsbev.f
    ! principally dsbevd does the same, and are recommended for use.
    ! (see man dsbevd)

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&info)

    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double precision dimension(ldab,n), intent(in,overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    double precision dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double precision dimension(ldz,ldz),intent(out),depend(ldz) :: z

    double precision dimension(MAX(1,3*n-1)),intent(hide),depend(n) :: work
    integer intent(out)::info

end subroutine dsbev



subroutine ssbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,liwork,info)
    ! in :Band:dsbevd.f
    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    real dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    real dimension(n),intent(out),depend(n) :: w
    real dimension(ldz,ldz),intent(out),depend(ldz) :: z

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    real dimension(ldz,ldz),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?1+5*n+2*n*n:2*n),1)
    real dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional,check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine ssbevd


subroutine dsbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,liwork,info)
    ! in :Band:dsbevd.f
    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double precision dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    double precision dimension(n),intent(out),depend(n) :: w
    double precision dimension(ldz,ldz),intent(out),depend(ldz) :: z

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double precision dimension(ldz,ldz),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?1+5*n+2*n*n:2*n),1)
    double precision dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional,check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine dsbevd



subroutine ssbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,float*, F_INT*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range


    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    real dimension(ldab,n),intent(in, overwrite) :: ab


    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    real dimension(ldq,ldq),intent(hide),depend(ldq) :: q


    real :: vl
    real :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    real optional,intent(in):: abstol=0.0

    real dimension(n),intent(out),depend(n) :: w

    real dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    real dimension(7*n),depend(n),intent(hide) :: work
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine ssbevx


subroutine dsbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,iwork,ifail,&info)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,double*, F_INT*,F_INT*,F_INT*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range


    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double precision dimension(ldab,n),intent(in, overwrite) :: ab


    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    double precision dimension(ldq,ldq),intent(hide),depend(ldq) :: q


    double precision :: vl
    double precision :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    double precision optional,intent(in):: abstol=0.0

    double precision dimension(n),intent(out),depend(n) :: w

    double precision dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    double precision dimension(7*n),depend(n),intent(hide) :: work
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine dsbevx



subroutine sstebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,w,iblock,isplit,info)
    ! computes all or selected eigenvalues of a real, symmetric tridiagonal
    ! matrix.

    callstatement (*f2py_func)((range>0?(range==1?"V":"I"):"A"),order,&n,&vl,&vu,&il,&iu,&tol,d,e,&m,&nsplit,w,iblock,isplit,work,iwork,&info)
    callprotoargument char*,char*,F_INT*,float*,float*,F_INT*,F_INT*,float*,float*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,F_INT*

    real dimension(n),intent(in) :: d
    real dimension(n-1),depend(n),intent(in) :: e
    real intent(in) :: vl
    real intent(in) :: vu
    character intent(in) :: order
    integer intent(in) :: il
    integer intent(in) :: iu
    real intent(in) :: tol
    integer intent(in) :: range
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    real dimension(4*n),depend(n),intent(hide) :: work
    integer dimension(3*n),depend(n),intent(hide) :: iwork
    integer intent(out) :: m
    integer intent(hide) :: nsplit
    real dimension(n),depend(n),intent(out) :: w
    integer dimension(n),depend(n),intent(out) :: iblock
    integer dimension(n),depend(n),intent(out) :: isplit
    integer intent(out) :: info

end subroutine sstebz


subroutine dstebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,w,iblock,isplit,info)
    ! computes all or selected eigenvalues of a real, symmetric tridiagonal
    ! matrix.

    callstatement (*f2py_func)((range>0?(range==1?"V":"I"):"A"),order,&n,&vl,&vu,&il,&iu,&tol,d,e,&m,&nsplit,w,iblock,isplit,work,iwork,&info)
    callprotoargument char*,char*,F_INT*,double*,double*,F_INT*,F_INT*,double*,double*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,F_INT*

    double precision dimension(n),intent(in) :: d
    double precision dimension(n-1),depend(n),intent(in) :: e
    double precision intent(in) :: vl
    double precision intent(in) :: vu
    character intent(in) :: order
    integer intent(in) :: il
    integer intent(in) :: iu
    double precision intent(in) :: tol
    integer intent(in) :: range
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    double precision dimension(4*n),depend(n),intent(hide) :: work
    integer dimension(3*n),depend(n),intent(hide) :: iwork
    integer intent(out) :: m
    integer intent(hide) :: nsplit
    double precision dimension(n),depend(n),intent(out) :: w
    integer dimension(n),depend(n),intent(out) :: iblock
    integer dimension(n),depend(n),intent(out) :: isplit
    integer intent(out) :: info

end subroutine dstebz



subroutine ssterf(d,e,n,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&info)
    callprotoargument F_INT*,float*,float*,F_INT*

    real dimension(n),intent(in,out,copy,out=vals) :: d
    real dimension(n-1),depend(n),intent(in,copy) :: e
    integer depend(d),intent(hide) :: n = shape(d,0)
    integer intent(out) :: info

end subroutine ssterf


subroutine dsterf(d,e,n,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&info)
    callprotoargument F_INT*,double*,double*,F_INT*

    double precision dimension(n),intent(in,out,copy,out=vals) :: d
    double precision dimension(n-1),depend(n),intent(in,copy) :: e
    integer depend(d),intent(hide) :: n = shape(d,0)
    integer intent(out) :: info

end subroutine dsterf



subroutine sstein(d,e,w,iblock,isplit,m,n,z,ldz,work,iwork,ifail,info)
    ! computes eigenvectors corresponding to eigenvalues of a real, symmetric
    ! tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&m,w,iblock,isplit,z,&ldz,work,iwork,ifail,&info)
    callprotoargument F_INT*,float*,float*,F_INT*,float*,F_INT*,F_INT*,float*,F_INT*,float*,F_INT*,F_INT*,F_INT*

    real dimension(n),intent(in) :: d
    real dimension(n-1),depend(n),intent(in) :: e
    real dimension(m),intent(in) :: w
    integer depend(w),intent(hide) :: m = shape(w,0)
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    integer dimension(n),depend(n),intent(in) :: iblock
    integer dimension(n),depend(n),intent(in) :: isplit
    real dimension(ldz,m),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = n
    real dimension(5*n),intent(hide) :: work
    integer dimension(n),intent(hide) :: iwork
    integer dimension(m),depend(m),intent(hide) :: ifail
    integer intent(out) :: info

end subroutine sstein


subroutine dstein(d,e,w,iblock,isplit,m,n,z,ldz,work,iwork,ifail,info)
    ! computes eigenvectors corresponding to eigenvalues of a real, symmetric
    ! tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&m,w,iblock,isplit,z,&ldz,work,iwork,ifail,&info)
    callprotoargument F_INT*,double*,double*,F_INT*,double*,F_INT*,F_INT*,double*,F_INT*,double*,F_INT*,F_INT*,F_INT*

    double precision dimension(n),intent(in) :: d
    double precision dimension(n-1),depend(n),intent(in) :: e
    double precision dimension(m),intent(in) :: w
    integer depend(w),intent(hide) :: m = shape(w,0)
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    integer dimension(n),depend(n),intent(in) :: iblock
    integer dimension(n),depend(n),intent(in) :: isplit
    double precision dimension(ldz,m),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = n
    double precision dimension(5*n),intent(hide) :: work
    integer dimension(n),intent(hide) :: iwork
    integer dimension(m),depend(m),intent(hide) :: ifail
    integer intent(out) :: info

end subroutine dstein



subroutine sstemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*,F_INT*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    real dimension(n),intent(in,copy) :: d
    real dimension(n),intent(in) :: e
    integer intent(in) :: range
    real intent(in) :: vl
    real intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(out) :: m
    real dimension(n),depend(n),intent(out) :: w
    real dimension(n,n),depend(n),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),optional,intent(in),check(lwork>=(compute_v?18*n:12*n)) :: lwork = max((compute_v?18*n:12*n),1)
    real dimension(lwork),depend(lwork),intent(hide) :: work
    integer depend(n),optional,intent(in),check(liwork>=(compute_v?10*n:8*n)) :: liwork = (compute_v?10*n:8*n)
    integer dimension(liwork),depend(liwork),intent(hide) :: iwork
    integer intent(out) :: info

end subroutine sstemr


subroutine dstemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*,F_INT*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    double precision dimension(n),intent(in,copy) :: d
    double precision dimension(n),intent(in) :: e
    integer intent(in) :: range
    double precision intent(in) :: vl
    double precision intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(out) :: m
    double precision dimension(n),depend(n),intent(out) :: w
    double precision dimension(n,n),depend(n),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),optional,intent(in),check(lwork>=(compute_v?18*n:12*n)) :: lwork = max((compute_v?18*n:12*n),1)
    double precision dimension(lwork),depend(lwork),intent(hide) :: work
    integer depend(n),optional,intent(in),check(liwork>=(compute_v?10*n:8*n)) :: liwork = (compute_v?10*n:8*n)
    integer dimension(liwork),depend(liwork),intent(hide) :: iwork
    integer intent(out) :: info

end subroutine dstemr



subroutine sstemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! LWORK=-1, LIWORK=-1 call for STEMR

    fortranname cstemr
    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,float*,float*,float*,float*,F_INT*,F_INT*,F_INT*,float*,float*,F_INT*,F_INT*,F_INT*,F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*

    real dimension(n),intent(in,copy) :: d
    real dimension(n),intent(in,copy) :: e
    integer intent(in) :: range
    real intent(in) :: vl
    real intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(hide) :: m
    real dimension(n),depend(n),intent(hide) :: w
    real dimension(n,n),depend(n),intent(hide) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),intent(hide) :: lwork = -1
    real intent(out) :: work
    integer intent(hide) :: liwork = -1
    integer intent(out) :: iwork
    integer intent(out) :: info
end subroutine sstemr_lwork


subroutine dstemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! LWORK=-1, LIWORK=-1 call for STEMR

    fortranname zstemr
    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,F_INT*,double*,double*,double*,double*,F_INT*,F_INT*,F_INT*,double*,double*,F_INT*,F_INT*,F_INT*,F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*

    double precision dimension(n),intent(in,copy) :: d
    double precision dimension(n),intent(in,copy) :: e
    integer intent(in) :: range
    double precision intent(in) :: vl
    double precision intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(hide) :: m
    double precision dimension(n),depend(n),intent(hide) :: w
    double precision dimension(n,n),depend(n),intent(hide) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),intent(hide) :: lwork = -1
    double precision intent(out) :: work
    integer intent(hide) :: liwork = -1
    integer intent(out) :: iwork
    integer intent(out) :: info
end subroutine dstemr_lwork



subroutine sstev(d,e,compute_v,n,z,ldz,work,info)
    ! computes all eigenvalues, and, optionally eigvectors of a real,
    ! symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),&n,d,e,z,&ldz,work,&info)
    callprotoargument char*,F_INT*,float*,float*,float*,F_INT*,float*,F_INT*

    integer optional,intent(in):: compute_v = 1
    real dimension(n),intent(in,out,copy,out=vals) :: d
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    real depend(n),dimension(MAX(n-1,1)),intent(in,copy) :: e
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    real dimension(ldz,(compute_v?n:1)),intent(out),depend(n,ldz) :: z
    real dimension((compute_v?MAX(1,2*n-2):1)),depend(n),intent(hide) :: work
    integer intent(out) :: info

end subroutine sstev


subroutine dstev(d,e,compute_v,n,z,ldz,work,info)
    ! computes all eigenvalues, and, optionally eigvectors of a real,
    ! symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),&n,d,e,z,&ldz,work,&info)
    callprotoargument char*,F_INT*,double*,double*,double*,F_INT*,double*,F_INT*

    integer optional,intent(in):: compute_v = 1
    double precision dimension(n),intent(in,out,copy,out=vals) :: d
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    double precision depend(n),dimension(MAX(n-1,1)),intent(in,copy) :: e
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double precision dimension(ldz,(compute_v?n:1)),intent(out),depend(n,ldz) :: z
    double precision dimension((compute_v?MAX(1,2*n-2):1)),depend(n),intent(hide) :: work
    integer intent(out) :: info

end subroutine dstev



subroutine ssfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    !
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,float*,float*,F_INT*,float*,float*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    real intent(in):: alpha
    real intent(in):: beta
    real dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    real dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine ssfrk


subroutine dsfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    !
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,double*,double*,F_INT*,double*,double*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    double precision intent(in):: alpha
    double precision intent(in):: beta
    double precision dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    double precision dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine dsfrk


subroutine chfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    !
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,float*,complex_float*,F_INT*,float*,complex_float*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    real intent(in):: alpha
    real intent(in):: beta
    complex dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    complex dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine chfrk


subroutine zhfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    !
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,F_INT*,F_INT*,double*,complex_double*,F_INT*,double*,complex_double*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    double precision intent(in):: alpha
    double precision intent(in):: beta
    double complex dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    double complex dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine zhfrk



subroutine stpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,F_INT*,float*,float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    real dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine stpttf


subroutine dtpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,F_INT*,double*,double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double precision dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine dtpttf


subroutine ctpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,complex_float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    complex dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine ctpttf


subroutine ztpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,complex_double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double complex dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine ztpttf



subroutine stpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !

    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,F_INT*,float*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    real dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine stpttr


subroutine dtpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !

    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,F_INT*,double*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double precision dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine dtpttr


subroutine ctpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !

    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    complex dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine ctpttr


subroutine ztpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !

    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double complex dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine ztpttr



subroutine stfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,F_INT*,float*,float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    real dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine stfttp


subroutine dtfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,F_INT*,double*,double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double precision dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine dtfttp


subroutine ctfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,complex_float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    complex dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine ctfttp


subroutine ztfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !

    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,complex_double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double complex dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine ztfttp



subroutine stfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR).
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,F_INT*,float*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    real dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine stfttr


subroutine dtfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR).
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,F_INT*,double*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double precision dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine dtfttr


subroutine ctfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR).
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    complex dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine ctfttr


subroutine ztfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR).
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double complex dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine ztfttr



subroutine strttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    real dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    real dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine strttf


subroutine dtrttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double precision dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double precision dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine dtrttf


subroutine ctrttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    complex dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine ctrttf


subroutine ztrttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double complex dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine ztrttf



subroutine strttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP).
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,float*,F_INT*

    character optional, intent(F_INT),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    real dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    real dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine strttp


subroutine dtrttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP).
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,double*,F_INT*

    character optional, intent(F_INT),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double precision dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double precision dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine dtrttp


subroutine ctrttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP).
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,complex_float*,F_INT*

    character optional, intent(F_INT),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    complex dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine ctrttp


subroutine ztrttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP).
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,complex_double*,F_INT*

    character optional, intent(F_INT),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double complex dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine ztrttp



subroutine stfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,F_INT*,F_INT*,float*,float*,float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    real intent(in):: alpha
    real dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    real dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine stfsm


subroutine dtfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,F_INT*,F_INT*,double*,double*,double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    double precision intent(in):: alpha
    double precision dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    double precision dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine dtfsm


subroutine ctfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,F_INT*,F_INT*,complex_float*,complex_float*,complex_float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    complex intent(in):: alpha
    complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    complex dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine ctfsm


subroutine ztfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,F_INT*,F_INT*,complex_double*,complex_double*,complex_double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    double complex intent(in):: alpha
    double complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    double complex dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine ztfsm



subroutine spftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine spftrf


subroutine dpftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine dpftrf


subroutine cpftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine cpftrf


subroutine zpftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine zpftrf



subroutine spftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine spftri


subroutine dpftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine dpftri


subroutine cpftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,complex_float*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine cpftri


subroutine zpftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,F_INT*,complex_double*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    integer intent(out):: info

end subroutine zpftri



subroutine spftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,float*,float*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    real dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinespftrs


subroutine dpftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,double*,double*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    double precision dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinedpftrs


subroutine cpftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    complex dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinecpftrs


subroutine zpftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,F_INT*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    double complex dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinezpftrs



subroutine stzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    real dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    real dimension(m),intent(out),depend(m):: tau
    real dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info

end subroutinestzrzf


subroutine dtzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double precision dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    double precision dimension(m),intent(out),depend(m):: tau
    double precision dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info

end subroutinedtzrzf


subroutine ctzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    complex dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    complex dimension(m),intent(out),depend(m):: tau
    complex dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info

end subroutinectzrzf


subroutine ztzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double complex dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    double complex dimension(m),intent(out),depend(m):: tau
    double complex dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info

end subroutineztzrzf



subroutine stzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname stzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,float*,F_INT*,float*,float*,F_INT*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    real intent(hide) :: a
    real intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    real intent(out) :: work
    integer intent(out) :: info

end subroutinestzrzf_lwork


subroutine dtzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname dtzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,double*,F_INT*,double*,double*,F_INT*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    double precision intent(hide) :: a
    double precision intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    double precision intent(out) :: work
    integer intent(out) :: info

end subroutinedtzrzf_lwork


subroutine ctzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname ctzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_float*,F_INT*,complex_float*,complex_float*,F_INT*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    complex intent(hide) :: a
    complex intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    complex intent(out) :: work
    integer intent(out) :: info

end subroutinectzrzf_lwork


subroutine ztzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname ztzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument F_INT*,F_INT*,complex_double*,F_INT*,complex_double*,complex_double*,F_INT*,F_INT*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    double complex intent(hide) :: a
    double complex intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    double complex intent(out) :: work
    integer intent(out) :: info

end subroutineztzrzf_lwork



subroutine slasd4( n, i, d, z, delta, rho, sigma, work, info )
	! sigma, delta, work, info = lasd4(d,z,i,rho=1.0)
   	! Computes i-th square root of eigenvalue of rank one augmented diagonal matrix. Needed by SVD update procedure

	callstatement { i++; (*f2py_func)( &n, &i, d, z, delta, &rho, &sigma, work, &info); }
    callprotoargument F_INT*, F_INT*, float*, float*, float*, float*, float*, float*, F_INT*

	integer intent(hide),depend(d):: n = shape(d,0)
	integer intent(in),depend(d),check(i>=0 && i<=(shape(d,0)-1)):: i

	real dimension(n),intent(in)           :: d
	real dimension(n),intent(in),depend(n) :: z

	real intent(out) :: sigma
	real dimension(n),intent(out),depend(n) :: delta
	real intent(in),optional:: rho = 1.0

	real dimension(n),intent(out),depend(n) :: work
	integer intent(out) :: info

end subroutine slasd4


subroutine dlasd4( n, i, d, z, delta, rho, sigma, work, info )
	! sigma, delta, work, info = lasd4(d,z,i,rho=1.0)
   	! Computes i-th square root of eigenvalue of rank one augmented diagonal matrix. Needed by SVD update procedure

	callstatement { i++; (*f2py_func)( &n, &i, d, z, delta, &rho, &sigma, work, &info); }
    callprotoargument F_INT*, F_INT*, double*, double*, double*, double*, double*, double*, F_INT*

	integer intent(hide),depend(d):: n = shape(d,0)
	integer intent(in),depend(d),check(i>=0 && i<=(shape(d,0)-1)):: i

	double precision dimension(n),intent(in)           :: d
	double precision dimension(n),intent(in),depend(n) :: z

	double precision intent(out) :: sigma
	double precision dimension(n),intent(out),depend(n) :: delta
	double precision intent(in),optional:: rho = 1.0

	double precision dimension(n),intent(out),depend(n) :: work
	integer intent(out) :: info

end subroutine dlasd4



subroutine slauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    real dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine slauum


subroutine dlauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double precision dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine dlauum


subroutine clauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,complex_float*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    complex dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine clauum


subroutine zlauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,F_INT*,complex_double*,F_INT*,F_INT*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double complex dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine zlauum



subroutine slaswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {F_INT i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument F_INT*,float*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    real dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine slaswp


subroutine dlaswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {F_INT i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument F_INT*,double*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double precision dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine dlaswp


subroutine claswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {F_INT i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument F_INT*,complex_float*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    complex dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine claswp


subroutine zlaswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {F_INT i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument F_INT*,complex_double*,F_INT*,F_INT*,F_INT*,F_INT*,F_INT*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double complex dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine zlaswp



! dlamch = dlamch(cmach)
!
! determine double precision machine parameters
!  CMACH   (input) CHARACTER*1
!          Specifies the value to be returned by DLAMCH:
!          = 'E' or 'e',   DLAMCH := eps
!          = 'S' or 's ,   DLAMCH := sfmin
!          = 'B' or 'b',   DLAMCH := base
!          = 'P' or 'p',   DLAMCH := eps*base
!          = 'N' or 'n',   DLAMCH := t
!          = 'R' or 'r',   DLAMCH := rnd
!          = 'M' or 'm',   DLAMCH := emin
!          = 'U' or 'u',   DLAMCH := rmin
!          = 'L' or 'l',   DLAMCH := emax
!          = 'O' or 'o',   DLAMCH := rmax
!
!          where
!
!          eps   = relative machine precision
!          sfmin = safe minimum, such that 1/sfmin does not overflow
!          base  = base of the machine
!          prec  = eps*base
!          t     = number of (base) digits in the mantissa
!          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
!          emin  = minimum exponent before (gradual) underflow
!          rmin  = underflow threshold - base**(emin-1)
!          emax  = largest exponent before overflow
!          rmax  = overflow threshold  - (base**emax)*(1-eps)
function dlamch(cmach)
    character :: cmach
    double precision intent(out):: dlamch
end function dlamch

function slamch(cmach)
    character :: cmach
    real intent(out):: slamch
end function slamch

function slange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a real matrix A.
    real slange, n2
    callstatement (*f2py_func)(&slange,norm,&m,&n,a,&lda,work)
    callprotoargument float*,char*,F_INT*,F_INT*,float*,F_INT*,float*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    real dimension(m,n),intent(in) :: a
    real dimension(m+1),intent(cache,hide) :: work
end function slange


function dlange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a real matrix A.
    double precision dlange, n2
    callstatement (*f2py_func)(&dlange,norm,&m,&n,a,&lda,work)
    callprotoargument double*,char*,F_INT*,F_INT*,double*,F_INT*,double*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    double precision dimension(m,n),intent(in) :: a
    double precision dimension(m+1),intent(cache,hide) :: work
end function dlange



function clange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a complex matrix A.
    real clange, n2
    callstatement (*f2py_func)(&clange,norm,&m,&n,a,&lda,work)
    callprotoargument float*,char*,F_INT*,F_INT*,complex_float*,F_INT*,float*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    complex dimension(m,n),intent(in) :: a
    real dimension(m+1),intent(cache,hide) :: work
end function clange


function zlange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a complex matrix A.
    double precision zlange, n2
    callstatement (*f2py_func)(&zlange,norm,&m,&n,a,&lda,work)
    callprotoargument double*,char*,F_INT*,F_INT*,complex_double*,F_INT*,double*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    double complex dimension(m,n),intent(in) :: a
    double precision dimension(m+1),intent(cache,hide) :: work
end function zlange



subroutine slarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    real intent(in,out) :: alpha
    real intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    real intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine slarfg


subroutine dlarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    double precision intent(in,out) :: alpha
    double precision intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    double precision intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine dlarfg


subroutine clarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    complex intent(in,out) :: alpha
    complex intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    complex intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine clarfg


subroutine zlarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    double complex intent(in,out) :: alpha
    double complex intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    double complex intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine zlarfg



subroutine slarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    real intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    real intent(in) :: tau
    real dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    real intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine slarf


subroutine dlarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    double precision intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    double precision intent(in) :: tau
    double precision dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    double precision intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine dlarf


subroutine clarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    complex intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    complex intent(in) :: tau
    complex dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    complex intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine clarf


subroutine zlarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    double complex intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    double complex intent(in) :: tau
    double complex dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    double complex intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine zlarf



subroutine slartg(f,g,cs,sn,r)
    real intent(in) :: f
    real intent(in) :: g
    real intent(out) :: cs
    real intent(out) :: sn
    real intent(out) :: r
end subroutine slartg


subroutine dlartg(f,g,cs,sn,r)
    double precision intent(in) :: f
    double precision intent(in) :: g
    double precision intent(out) :: cs
    double precision intent(out) :: sn
    double precision intent(out) :: r
end subroutine dlartg


subroutine clartg(f,g,cs,sn,r)
    complex intent(in) :: f
    complex intent(in) :: g
    real intent(out) :: cs
    complex intent(out) :: sn
    complex intent(out) :: r
end subroutine clartg


subroutine zlartg(f,g,cs,sn,r)
    double complex intent(in) :: f
    double complex intent(in) :: g
    double precision intent(out) :: cs
    double complex intent(out) :: sn
    double complex intent(out) :: r
end subroutine zlartg



subroutine crot(n,x,offx,incx,y,offy,incy,c,s,lx,ly)
    callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
    callprotoargument F_INT*,complex_float*,F_INT*,complex_float*,F_INT*,float*,complex_float*
    complex dimension(lx),intent(in,out,copy) :: x
    complex dimension(ly),intent(in,out,copy) :: y
    integer intent(hide),depend(x) :: lx = len(x)
    integer intent(hide),depend(y) :: ly = len(y)
    real intent(in) :: c
    complex intent(in) :: s
    integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
    integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
    integer optional, intent(in), depend(lx), check(offx>=0 && offx<lx) :: offx=0
    integer optional, intent(in), depend(ly), check(offy>=0 && offy<ly) :: offy=0
    integer optional, intent(in), depend(lx,incx,offx,ly,incy,offy) :: n = (lx-1-offx)/abs(incx)+1
    check(lx-offx>(n-1)*abs(incx)) :: n
    check(ly-offy>(n-1)*abs(incy)) :: n
end subroutine crot


subroutine zrot(n,x,offx,incx,y,offy,incy,c,s,lx,ly)
    callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
    callprotoargument F_INT*,complex_double*,F_INT*,complex_double*,F_INT*,double*,complex_double*
    double complex dimension(lx),intent(in,out,copy) :: x
    double complex dimension(ly),intent(in,out,copy) :: y
    integer intent(hide),depend(x) :: lx = len(x)
    integer intent(hide),depend(y) :: ly = len(y)
    double precision intent(in) :: c
    double complex intent(in) :: s
    integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
    integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
    integer optional, intent(in), depend(lx), check(offx>=0 && offx<lx) :: offx=0
    integer optional, intent(in), depend(ly), check(offy>=0 && offy<ly) :: offy=0
    integer optional, intent(in), depend(lx,incx,offx,ly,incy,offy) :: n = (lx-1-offx)/abs(incx)+1
    check(lx-offx>(n-1)*abs(incx)) :: n
    check(ly-offy>(n-1)*abs(incy)) :: n
end subroutine zrot



subroutine ilaver(major, minor, patch)
    integer intent(out) :: major
    integer intent(out) :: minor
    integer intent(out) :: patch
end subroutine ilaver

end interface

end python module _flapack

! This file was auto-generated with f2py (version:2.10.173).
! See http://cens.ioc.ee/projects/f2py2e/
