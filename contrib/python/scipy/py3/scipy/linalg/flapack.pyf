! Signatures for f2py wrappers of FORTRAN LAPACK functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! $Revision$ $Date$
!
! Additions by Travis Oliphant, Tiziano Zito, Collin RM Stocks, Fabian Pedregosa
!              Skipper Seabold, Ilhan Polat
!
! Shorthand Notations:
! --------------------
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
!

python module _flapack
interface

    ! Following classification is due to
    ! http://www.netlib.org/lapack/explore-html/

python module gees__user__routines 
    interface
        function sselect(arg1,arg2)
            real :: arg1,arg2
            logical :: sselect
        end function sselect

        function dselect(arg1,arg2)
            double precision :: arg1,arg2
            logical :: dselect
        end function dselect

        function cselect(arg)
            complex :: arg
            logical :: cselect
        end function cselect

        function zselect(arg)
            double complex :: arg
            logical :: zselect
        end function zselect


    end interface
end python module gees__user__routines

python module gges__user__routines 
    interface
        function cselect(alpha, beta)
            complex :: alpha, beta
            logical :: cselect
        end function cselect

        function zselect(alpha, beta)
            double complex :: alpha, beta
            logical :: zselect
        end function zselect


        function sselect(alphar, alphai, beta)
            real :: alphar, alphai, beta
            logical :: sselect
        end function sselect

        function dselect(alphar, alphai, beta)
            double precision :: alphar, alphai, beta
            logical :: dselect
        end function dselect


    end interface
end python module gges__user__routines
! Signatures for f2py-wrappers of FORTRAN LAPACK General Matrix functions.
!

subroutine sgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,int*,float*,int*,int*,int*,float*,int*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    real dimension(n),intent(out),depend(n) :: pivscale
    real dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info
 
end subroutine sgebal


subroutine dgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,int*,double*,int*,int*,int*,double*,int*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    double precision dimension(n),intent(out),depend(n) :: pivscale
    double precision dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info
 
end subroutine dgebal


subroutine cgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,int*,complex_float*,int*,int*,int*,float*,int*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    real dimension(n),intent(out),depend(n) :: pivscale
    complex dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info
 
end subroutine cgebal


subroutine zgebal(scale,permute,n,a,m,lo,hi,pivscale,info)
    !
    ! ba,lo,hi,pivscale,info = gebal(a,scale=0,permute=0,overwrite_a=0)
    ! Balance general matrix a.
    ! hi,lo are such that ba[i][j]==0 if i>j and j=0...lo-1 or i=hi+1..n-1
    ! pivscale([0:lo], [lo:hi+1], [hi:n+1]) = (p1,d,p2) where (p1,p2)[j] is
    ! the index of the row and column interchanged with row and column j.
    ! d[j] is the scaling factor applied to row and column j.
    ! The order in which the interchanges are made is n-1 to hi+1, then 0 to lo-1.
    !
    ! P * A * P = [[T1,X,Y],[0,B,Z],[0,0,T2]]
    ! BA = [[T1,X*D,Y],[0,inv(D)*B*D,ind(D)*Z],[0,0,T2]]
    ! where D = diag(d), T1,T2 are upper triangular matrices.
    ! lo,hi mark the starting and ending columns of submatrix B.

    callstatement { (*f2py_func)((permute?(scale?"B":"P"):(scale?"S":"N")),&n,a,&m,&lo,&hi,pivscale,&info); hi--; lo--; }
    callprotoargument char*,int*,complex_double*,int*,int*,int*,double*,int*
    integer intent(in),optional :: permute = 0
    integer intent(in),optional :: scale = 0
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(a) :: n = shape(a,1)
    check(m>=n) m
    integer intent(out) :: hi,lo
    double precision dimension(n),intent(out),depend(n) :: pivscale
    double complex dimension(m,n),intent(in,out,copy,out=ba) :: a
    integer intent(out) :: info
 
end subroutine zgebal



subroutine sgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,float*,int*,float*,float*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    real dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    real dimension(n-1),intent(out),depend(n) :: tau
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info
    
end subroutine sgehrd


subroutine dgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,double*,int*,double*,double*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double precision dimension(n-1),intent(out),depend(n) :: tau
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info
    
end subroutine dgehrd


subroutine cgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    complex dimension(n-1),intent(out),depend(n) :: tau
    complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info
    
end subroutine cgehrd


subroutine zgehrd(n,lo,hi,a,tau,work,lwork,info)
    !
    ! hq,tau,info = gehrd(a,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Reduce general matrix A to upper Hessenberg form H by unitary similarity
    ! transform Q^H * A * Q = H
    !
    ! Q = H(lo) * H(lo+1) * ... * H(hi-1)
    ! H(i) = I - tau * v * v^H
    ! v[0:i+1] = 0, v[i+1]=1, v[hi+1:n] = 0
    ! v[i+2:hi+1] is stored in hq[i+2:hi+i,i]
    ! tau is tau[i]
    !
    ! hq for n=7,lo=1,hi=5:
    ! [a a h h h h a
    !    a h h h h a
    !    h h h h h h
    !    v2h h h h h
    !    v2v3h h h h
    !    v2v3v4h h h
    !              a]
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double complex dimension(n-1),intent(out),depend(n) :: tau
    double complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=MAX(n,1)) :: lwork = MAX(n,1)
    integer intent(out) :: info
    
end subroutine zgehrd


   
subroutine sgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname sgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,float*,int*,float*,float*,int*,int*
    integer intent(in) :: n
    real intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine sgehrd_lwork

   
subroutine dgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname dgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,double*,int*,double*,double*,int*,int*
    integer intent(in) :: n
    double precision intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine dgehrd_lwork

   
subroutine cgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname cgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*
    integer intent(in) :: n
    complex intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine cgehrd_lwork

   
subroutine zgehrd_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for GEHRD
    fortranname zgehrd
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*
    integer intent(in) :: n
    double complex intent(hide) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info
end subroutine zgehrd_lwork



subroutine sgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {int i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,float*,int*,int*,float*,int*,int*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    real dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine sgesv


subroutine dgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {int i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,double*,int*,int*,double*,int*,int*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    double precision dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine dgesv


subroutine cgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {int i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,complex_float*,int*,int*,complex_float*,int*,int*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    complex dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine cgesv


subroutine zgesv(n,nrhs,a,piv,b,info)
    ! lu,piv,x,info = gesv(a,b,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A = P * L * U
    ! U is upper diagonal triangular, L is unit lower triangular,
    ! piv pivots columns.

    callstatement {int i;(*f2py_func)(&n,&nrhs,a,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,complex_double*,int*,int*,complex_double*,int*,int*

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    integer dimension(n),depend(n),intent(out) :: piv
    double complex dimension(n,nrhs),check(shape(a,0)==shape(b,0)),depend(n) :: b
    integer intent(out)::info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lu) a
end subroutine zgesv



subroutine sgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, single and double reals (sgesvx and dgesvx)
    threadsafe
    callstatement {int i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,int*,int*,float*,int*,float*,int*,int*,char*,float*,float*,float*,int*,float*,int*,float*,float*,float*,float*,int*,int*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real optional,dimension(n,n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    real optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    real optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    real depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    real dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    real dimension(4*n),depend(n),intent(hide,cache):: work
    integer intent(hide,cache),dimension(n),depend(n) :: iwork
    integer intent(out):: info

end subroutine sgesvx


subroutine dgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, single and double reals (sgesvx and dgesvx)
    threadsafe
    callstatement {int i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,int*,int*,double*,int*,double*,int*,int*,char*,double*,double*,double*,int*,double*,int*,double*,double*,double*,double*,int*,int*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision optional,dimension(n,n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    double precision optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    double precision optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    double precision depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double precision dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double precision dimension(4*n),depend(n),intent(hide,cache):: work
    integer intent(hide,cache),dimension(n),depend(n) :: iwork
    integer intent(out):: info

end subroutine dgesvx



subroutine cgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, complex and double complex (cgesvx and zgesvx)
    threadsafe
    callstatement {int i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,int*,char*,float*,float*,complex_float*,int*,complex_float*,int*,float*,float*,float*,complex_float*,float*,int*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    complex optional,dimension(n,n),depend(n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    real optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    real optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    complex depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    complex dimension(2*n),depend(n),intent(hide,cache):: work
    real intent(hide,cache),dimension(2*n),depend(n) :: rwork
    integer intent(out):: info

end subroutine cgesvx


subroutine zgesvx(fact,trans,n,nrhs,a,lda,af,ldaf,ipiv,equed,r,c,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! Solve A * X = B using LU decomposition
    ! The expert driver of ?GESV with condition number, backward/forward error estimates, and iterative refinement
    ! This part takes care of the data types, complex and double complex (cgesvx and zgesvx)
    threadsafe
    callstatement {int i;(*f2py_func)(fact,trans,&n,&nrhs,a,&lda,af,&ldaf,ipiv,equed,r,c,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,int*,char*,double*,double*,complex_double*,int*,complex_double*,int*,double*,double*,double*,complex_double*,double*,int*

    character optional,intent(in):: trans = "N"
    character optional,intent(in):: fact = "E"
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=as):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double complex optional,dimension(n,n),depend(n),intent(in,out,out=lu):: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,dimension(n),depend(n),intent(in,out):: ipiv
    character optional,intent(in,out):: equed = "B"
    double precision optional,dimension(n),depend(n),intent(in,out,out=rs):: r
    double precision optional,dimension(n),depend(n),intent(in,out,out=cs):: c
    double complex depend(n),dimension(n,nrhs),intent(in,out,copy,out=bs):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(n),intent(hide):: ldx = n
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double complex dimension(2*n),depend(n),intent(hide,cache):: work
    double precision intent(hide,cache),dimension(2*n),depend(n) :: rwork
    integer intent(out):: info

end subroutine zgesvx



subroutine sgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,float*,int*,float*,float*,float*,int*,int*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    real depend(n),dimension(4*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine sgecon


subroutine dgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,double*,int*,double*,double*,double*,int*,int*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double precision depend(n),dimension(4*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine dgecon


subroutine cgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,complex_float*,int*,float*,float*,complex_float*,float*,int*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    complex depend(n),dimension(2*n),intent(hide,cache):: work
    real depend(n),dimension(2*n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine cgecon


subroutine zgecon(norm,n,a,lda,anorm,rcond,work,irwork,info)
   ! Computes the 1- or inf- norm reciprocal condition number estimate.
    threadsafe
    callstatement (*f2py_func)(norm,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,complex_double*,int*,double*,double*,complex_double*,double*,int*

    character optional,intent(in):: norm = '1'
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double complex depend(n),dimension(2*n),intent(hide,cache):: work
    double precision depend(n),dimension(2*n),intent(hide,cache):: irwork
    integer intent(out):: info

end subroutine zgecon


   
subroutine sgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {int i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument int*,int*,float*,int*,int*,int*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine sgetrf

   
subroutine dgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {int i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument int*,int*,double*,int*,int*,int*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine dgetrf

   
subroutine cgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {int i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument int*,int*,complex_float*,int*,int*,int*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine cgetrf

   
subroutine zgetrf(m,n,a,piv,info)
    ! lu,piv,info = getrf(a,overwrite_a=0)
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A = P * L * U
    threadsafe
    callstatement {int i;(*f2py_func)(&m,&n,a,&m,piv,&info);for(i=0,n=MIN(m,n);i<n;--piv[i++]);}
    callprotoargument int*,int*,complex_double*,int*,int*,int*

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=lu) :: a
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: piv
    integer intent(out):: info

end subroutine zgetrf



subroutine sgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,int*,int*,float*,int*,int*,float*,int*,int*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    real dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine sgetrs


subroutine dgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,int*,int*,double*,int*,int*,double*,int*,int*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    double precision dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine dgetrs


subroutine cgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,int*,int*,complex_float*,int*,int*,complex_float*,int*,int*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine cgetrs


subroutine zgetrs(n,nrhs,lu,piv,b,info,trans)
    ! x,info = getrs(lu,piv,b,trans=0,overwrite_b=0)
    ! Solve  A  * X = B if trans=0
    ! Solve A^T * X = B if trans=1
    ! Solve A^H * X = B if trans=2
    ! A = P * L * U
    threadsafe
    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)((trans?(trans==2?"C":"T"):"N"),&n,&nrhs,lu,&n,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument char*,int*,int*,complex_double*,int*,int*,complex_double*,int*,int*

    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

    integer depend(lu),intent(hide):: n = shape(lu,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),intent(in) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    double complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n),check(shape(lu,0)==shape(b,0)) :: b
    integer intent(out):: info

end subroutine zgetrs



subroutine sgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,float*,int*,int*,float*,int*,int*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    real dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine sgetri


subroutine dgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,double*,int*,int*,double*,int*,int*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    double precision dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine dgetri


subroutine cgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,complex_float*,int*,int*,complex_float*,int*,int*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    complex dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine cgetri


subroutine zgetri(n,lu,piv,work,lwork,info)
    ! inv_a,info = getri(lu,piv,lwork=3*n,overwrite_lu=0)
    ! Find A inverse A^-1.
    ! A = P * L * U

    callstatement {int i;for(i=0;i<n;++piv[i++]);(*f2py_func)(&n,lu,&n,piv,work,&lwork,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,complex_double*,int*,int*,complex_double*,int*,int*

    integer depend(lu),intent(hide):: n = shape(lu,0)
    double complex dimension(n,n),intent(in,out,copy,out=inv_a) :: lu
    check(shape(lu,0)==shape(lu,1)) :: lu
    integer dimension(n),intent(in),depend(n) :: piv
    integer intent(out):: info
    integer optional,intent(in),depend(n),check(lwork>=n) :: lwork=max(3*n,1)
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

end subroutine zgetri



subroutine sgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname sgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument int*,float*,int*,int*,float*,int*,int*

    integer intent(in):: n
    real intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    real intent(out) :: work
end subroutine sgetri_lwork


subroutine dgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname dgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument int*,double*,int*,int*,double*,int*,int*

    integer intent(in):: n
    double precision intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    double precision intent(out) :: work
end subroutine dgetri_lwork


subroutine cgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname cgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument int*,complex_float*,int*,int*,complex_float*,int*,int*

    integer intent(in):: n
    complex intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    complex intent(out) :: work
end subroutine cgetri_lwork


subroutine zgetri_lwork(n,lu,piv,work,lwork,info)
    ! *GETRI LWORK query
    fortranname zgetri
    callstatement (*f2py_func)(&n,&lu,&n,&piv,&work,&lwork,&info)
    callprotoargument int*,complex_double*,int*,int*,complex_double*,int*,int*

    integer intent(in):: n
    double complex intent(hide) :: lu
    integer intent(hide) :: piv
    integer intent(out):: info
    integer intent(hide) :: lwork=-1
    double complex intent(out) :: work
end subroutine zgetri_lwork



subroutine sgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,iwork,&info)
    callprotoargument char*,int*,int*,float*,int*,float*,float*,int*,float*,int*,float*,int*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    real dimension(m,n),intent(in,copy,aligned8) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    real dimension(u0,u1),intent(out),depend(u0, u1) :: u
    real dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn,compute_uv) &
        :: lwork = max((compute_uv?4*minmn*minmn+MAX(m,n)+9*minmn:MAX(14*minmn+4,10*minmn+2+25*(25+8))+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine sgesdd


subroutine dgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,iwork,&info)
    callprotoargument char*,int*,int*,double*,int*,double*,double*,int*,double*,int*,double*,int*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double precision dimension(m,n),intent(in,copy,aligned8) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double precision dimension(u0,u1),intent(out),depend(u0, u1) :: u
    double precision dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn,compute_uv) &
        :: lwork = max((compute_uv?4*minmn*minmn+MAX(m,n)+9*minmn:MAX(14*minmn+4,10*minmn+2+25*(25+8))+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine dgesdd



subroutine sgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! LWORK computation for (S/D)GESDD

    fortranname sgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&iwork,&info)
    callprotoargument char*,int*,int*,float*,int*,float*,float*,int*,float*,int*,float*,int*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    real intent(hide) :: a
    real intent(hide) :: s
    real intent(hide) :: u
    real intent(hide) :: vt
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info
    
end subroutine sgesdd_lwork


subroutine dgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,iwork,info)
    ! LWORK computation for (S/D)GESDD

    fortranname dgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&iwork,&info)
    callprotoargument char*,int*,int*,double*,int*,double*,double*,int*,double*,int*,double*,int*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    double precision intent(hide) :: a
    double precision intent(hide) :: s
    double precision intent(hide) :: u
    double precision intent(hide) :: vt
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info
    
end subroutine dgesdd_lwork



subroutine cgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,iwork,&info)
    callprotoargument char*,int*,int*,complex_float*,int*,float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*,int*
   
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    complex dimension(m,n),intent(in,copy) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    real dimension((compute_uv?minmn*MAX(5*minmn+7, 2*MAX(m,n)+2*minmn+1):7*minmn)),intent(hide,cache),depend(minmn,compute_uv) :: rwork
    integer optional,intent(in),depend(minmn,compute_uv) &
         :: lwork = max((compute_uv?2*minmn*minmn+MAX(m,n)+2*minmn:2*minmn+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine cgesdd


subroutine zgesdd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! u,s,vt,info = gesdd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD) using divide and conquer:
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False

    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,iwork,&info)
    callprotoargument char*,int*,int*,complex_double*,int*,double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*,int*
   
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double complex dimension(m,n),intent(in,copy) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    double complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    double precision dimension((compute_uv?minmn*MAX(5*minmn+7, 2*MAX(m,n)+2*minmn+1):7*minmn)),intent(hide,cache),depend(minmn,compute_uv) :: rwork
    integer optional,intent(in),depend(minmn,compute_uv) &
         :: lwork = max((compute_uv?2*minmn*minmn+MAX(m,n)+2*minmn:2*minmn+MAX(m,n)),1)
    integer intent(hide,cache),dimension(8*minmn),depend(minmn) :: iwork
    integer intent(out)::info

end subroutine zgesdd



subroutine cgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! (C/Z)GESDD call with LWORK=-1 -- copypaste of above gesdd with dummy arrays

    fortranname cgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&iwork,&info)
    callprotoargument char*,int*,int*,complex_float*,int*,float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    complex intent(hide) :: a
    real intent(hide) :: s
    complex intent(hide) :: u
    complex intent(hide) :: vt
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info
    
end subroutine cgesdd_lwork


subroutine zgesdd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,iwork,info)
    ! (C/Z)GESDD call with LWORK=-1 -- copypaste of above gesdd with dummy arrays

    fortranname zgesdd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&iwork,&info)
    callprotoargument char*,int*,int*,complex_double*,int*,double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    double complex intent(hide) :: a
    double precision intent(hide) :: s
    double complex intent(hide) :: u
    double complex intent(hide) :: vt
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(hide) :: lwork = -1
    integer intent(hide) :: iwork
    integer intent(out) :: info
    
end subroutine zgesdd_lwork



subroutine sgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
  
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,float*,int*,float*,float*,int*,float*,int*,float*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    real dimension(m,n),intent(in,copy,aligned8) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    real dimension(u0,u1),intent(out),depend(u0, u1) :: u
    real dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn) :: lwork = max(MAX(3*minmn+MAX(m,n),5*minmn),1)
    integer intent(out) :: info

end subroutine sgesvd


subroutine dgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
  
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,double*,int*,double*,double*,int*,double*,int*,double*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double precision dimension(m,n),intent(in,copy,aligned8) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double precision dimension(u0,u1),intent(out),depend(u0, u1) :: u
    double precision dimension(vt0,vt1),intent(out),depend(vt0, vt1) :: vt
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work
    integer optional,intent(in),depend(minmn) :: lwork = max(MAX(3*minmn+MAX(m,n),5*minmn),1)
    integer intent(out) :: info

end subroutine dgesvd



subroutine sgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! LWORK computation for (S/D)GESVD

    fortranname sgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,float*,int*,float*,float*,int*,float*,int*,float*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    real intent(hide) :: a
    real intent(hide) :: s
    real intent(hide) :: u
    real intent(hide) :: vt
    integer intent(hide) :: lwork = -1
    real intent(out) :: work
    integer intent(out) :: info

end subroutine sgesvd_lwork


subroutine dgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,lwork,info)
    ! LWORK computation for (S/D)GESVD

    fortranname dgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,double*,int*,double*,double*,int*,double*,int*,double*,int*,int*
    
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    double precision intent(hide) :: a
    double precision intent(hide) :: s
    double precision intent(hide) :: u
    double precision intent(hide) :: vt
    integer intent(hide) :: lwork = -1
    double precision intent(out) :: work
    integer intent(out) :: info

end subroutine dgesvd_lwork



subroutine cgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
 
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,int*,float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*
 
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    complex dimension(m,n),intent(in,copy) :: a
    real dimension(minmn),intent(out),depend(minmn) :: s
    complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    real dimension((MAX(1,5*minmn))),intent(hide,cache),depend(minmn) :: rwork
    integer optional,intent(in),depend(minmn) :: lwork = MAX(2*minmn+MAX(m,n),1)
    integer intent(out) :: info
 
end subroutine cgesvd


subroutine zgesvd(m,n,minmn,u0,u1,vt0,vt1,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! u,s,vt,info = gesvd(a,compute_uv=1,lwork=..,overwrite_a=0)
    ! Compute the singular value decomposition (SVD):
    !   A = U * SIGMA * conjugate-transpose(V)
    ! A - M x N matrix
    ! U - M x M matrix or min(M,N) x N if full_matrices=False
    ! SIGMA - M x N zero matrix with a main diagonal filled with min(M,N)
    !               singular values
    ! transpose(V) - N x N matrix or N x min(M,N) if full_matrices=False
 
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,a,&m,s,u,&u0,vt,&vt0,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,int*,double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*
 
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: u1 = (compute_uv?(full_matrices?m:minmn):1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide),depend(compute_uv,minmn) :: vt1 = (compute_uv?n:1)
    double complex dimension(m,n),intent(in,copy) :: a
    double precision dimension(minmn),intent(out),depend(minmn) :: s
    double complex dimension(u0,u1),intent(out),depend(u0,u1) :: u
    double complex dimension(vt0,vt1),intent(out),depend(vt0,vt1) :: vt
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    double precision dimension((MAX(1,5*minmn))),intent(hide,cache),depend(minmn) :: rwork
    integer optional,intent(in),depend(minmn) :: lwork = MAX(2*minmn+MAX(m,n),1)
    integer intent(out) :: info
 
end subroutine zgesvd



subroutine cgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! (C/Z)GESVD call with LWORK=-1 -- copypaste of above gesvd with dummy arrays

    fortranname cgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,int*,float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*
  
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide) :: lwork = -1
    complex intent(hide) :: a
    real intent(hide) :: s
    complex intent(hide) :: u
    complex intent(hide) :: vt
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(out) :: info
  
end subroutine cgesvd_lwork


subroutine zgesvd_lwork(m,n,minmn,u0,vt0,a,compute_uv,full_matrices,u,s,vt,work,rwork,lwork,info)
    ! (C/Z)GESVD call with LWORK=-1 -- copypaste of above gesvd with dummy arrays

    fortranname zgesvd
    callstatement (*f2py_func)((compute_uv?(full_matrices?"A":"S"):"N"),(compute_uv?(full_matrices?"A":"S"):"N"),&m,&n,&a,&m,&s,&u,&u0,&vt,&vt0,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,int*,double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*
  
    integer intent(in),optional,check(compute_uv==0||compute_uv==1):: compute_uv = 1
    integer intent(in),optional,check(full_matrices==0||full_matrices==1):: full_matrices = 1
    integer intent(in),depend(a):: m
    integer intent(in),depend(a):: n
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(compute_uv,minmn) :: u0 = (compute_uv?m:1)
    integer intent(hide),depend(compute_uv,minmn, full_matrices) :: vt0 = (compute_uv?(full_matrices?n:minmn):1)
    integer intent(hide) :: lwork = -1
    double complex intent(hide) :: a
    double precision intent(hide) :: s
    double complex intent(hide) :: u
    double complex intent(hide) :: vt
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(out) :: info
  
end subroutine zgesvd_lwork



subroutine sgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,float*,int*,float*,int*,float*,int*,int*

    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    real dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    real intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    real depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine sgels


subroutine dgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,double*,int*,double*,int*,double*,int*,int*

    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    double precision dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double precision intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    double precision depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine dgels


subroutine cgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,complex_float*,int*,complex_float*,int*,complex_float*,int*,int*

    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    complex dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    complex intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    complex depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine cgels


subroutine zgels(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! lqr,x,info = gels(a,b,lwork=..,overwrite_a=False,overwrite_b=False)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(trans,&m,&n,&nrhs,a,&lda,b,&ldb,work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,complex_double*,int*,complex_double*,int*,complex_double*,int*,int*

    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(b):: nrhs = shape(b,1)
    double complex dimension(m,n),intent(in,out,copy,out=lqr):: a
    integer intent(hide),depend(a):: lda = MAX(1,shape(a,0))
    double complex intent(in,out,copy,out=x),depend(trans,m,n),dimension(MAX(m,n),nrhs),check(shape(b,0)==MAX(m,n)) :: b
    integer depend(b),intent(hide):: ldb = MAX(1,MAX(m,n))
    integer optional,intent(in),depend(nrhs,m,n),check(lwork>=1||lwork==-1)::lwork=MAX(MIN(m,n)+MAX(MIN(m,n),nrhs),1)
    double complex depend(lwork),dimension(MAX(1,lwork)),intent(hide,cache):: work
    integer intent(out)::info

end subroutine zgels



subroutine sgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname sgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,float*,int*,float*,int*,float*,int*,int*
  
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs
  
    real intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    real intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1
  
    real intent(out):: work
    integer intent(out)::info
  
end subroutine sgels_lwork


subroutine dgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname dgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,double*,int*,double*,int*,double*,int*,int*
  
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs
  
    double precision intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    double precision intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1
  
    double precision intent(out):: work
    integer intent(out)::info
  
end subroutine dgels_lwork


subroutine cgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname cgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,complex_float*,int*,complex_float*,int*,complex_float*,int*,int*
  
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs
  
    complex intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    complex intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1
  
    complex intent(out):: work
    integer intent(out)::info
  
end subroutine cgels_lwork


subroutine zgels_lwork(trans,m,n,nrhs,a,lda,b,ldb,work,lwork,info)
    ! ?GELS LWORK Query for optimal block size

    fortranname zgels
    callstatement (*f2py_func)(trans,&m,&n,&nrhs,&a,&lda,&b,&ldb,&work,&lwork,&info)
    callprotoargument char*,int*,int*,int*,complex_double*,int*,complex_double*,int*,complex_double*,int*,int*
  
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),check(nrhs>=0) :: nrhs
  
    double complex intent(hide):: a
    integer intent(hide):: lda = MAX(1,m)
    double complex intent(hide):: b
    integer intent(hide):: ldb = MAX(1,MAX(m,n))
    integer intent(hide):: lwork=-1
  
    double complex intent(out):: work
    integer intent(out)::info
  
end subroutine zgels_lwork



subroutine sgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).
  
    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,float*,float*,int*,float*,int*,int*
  
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real dimension(m,n),intent(in,out,copy,out=v) :: a
  
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b
  
    real intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s
  
    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
       check(lwork>=1||lwork==-1) &
       :: lwork=max(3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)),1)
       !check(lwork>=3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)))
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out)::info
  
end subroutine sgelss


subroutine dgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).
  
    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,double*,double*,int*,double*,int*,int*
  
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision dimension(m,n),intent(in,out,copy,out=v) :: a
  
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b
  
    double precision intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s
  
    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
       check(lwork>=1||lwork==-1) &
       :: lwork=max(3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)),1)
       !check(lwork>=3*minmn+MAX(2*minmn,MAX(maxmn,nrhs)))
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out)::info
  
end subroutine dgelss



subroutine sgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
   ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size
    fortranname sgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,float*,float*,int*,float*,int*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real intent(hide) :: a

    integer intent(in):: nrhs
    real intent(hide) :: b

    real intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    real intent(out) :: work
    integer intent(out)::info

end subroutine sgelss_lwork


subroutine dgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,info)
   ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size
    fortranname dgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,double*,double*,int*,double*,int*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision intent(hide) :: a

    integer intent(in):: nrhs
    double precision intent(hide) :: b

    double precision intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    double precision intent(out) :: work
    integer intent(out)::info

end subroutine dgelss_lwork



subroutine cgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,int*,complex_float*,int*,float*,int*
  
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex dimension(m,n),intent(in,out,copy,out=v) :: a
  
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b
  
    real intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s
  
    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
        check(lwork>=1||lwork==-1) &
        :: lwork=max(2*minmn+MAX(maxmn,nrhs),1)
        ! check(lwork>=2*minmn+MAX(maxmn,nrhs))
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    real dimension(5*minmn),intent(hide),depend(lwork) :: rwork
    integer intent(out)::info
  
end subroutine cgelss


subroutine zgelss(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! v,x,s,rank,work,info = gelss(a,b,cond=-1.0,overwrite_a=0,overwrite_b=0)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,int*,complex_double*,int*,double*,int*
  
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex dimension(m,n),intent(in,out,copy,out=v) :: a
  
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b
  
    double precision intent(in),optional :: cond = -1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s
  
    integer optional,intent(in),depend(nrhs,minmn,maxmn),&
        check(lwork>=1||lwork==-1) &
        :: lwork=max(2*minmn+MAX(maxmn,nrhs),1)
        ! check(lwork>=2*minmn+MAX(maxmn,nrhs))
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    double precision dimension(5*minmn),intent(hide),depend(lwork) :: rwork
    integer intent(out)::info
  
end subroutine zgelss



subroutine cgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
    ! Query for optimal lwork size

    fortranname cgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,int*,complex_float*,int*,float*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex intent(hide) :: a

    integer intent(in):: nrhs
    complex intent(hide) :: b

    real intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(out)::info

end subroutine sgelss_lwork


subroutine zgelss_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,rwork,lwork,info)
    ! work,info = gelss_lwork(m,n,nrhs,cond=-1.0)
    ! Query for optimal lwork size

    fortranname zgelss
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,int*,complex_double*,int*,double*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex intent(hide) :: a

    integer intent(in):: nrhs
    double complex intent(hide) :: b

    double precision intent(in),optional :: cond = -1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer optional,intent(in) :: lwork=-1
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(out)::info

end subroutine dgelss_lwork



subroutine sgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! v,x,j,rank,info = dgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,int*,float*,int*,float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    real dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=MAX(minmn+3*n+1, 2*minmn+nrhs)) :: lwork
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out)::info

end subroutine sgelsy


subroutine dgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! v,x,j,rank,info = dgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,int*,double*,int*,double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    double precision dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=MAX(minmn+3*n+1, 2*minmn+nrhs)) :: lwork
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out)::info

end subroutine dgelsy



subroutine sgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! work,info = dgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname sgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,int*,float*,int*,float*,int*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real intent(hide) :: a

    integer intent(in):: nrhs
    real intent(hide):: b

    real intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide):: jptv

    integer intent(in),optional :: lwork = -1
    real intent(out) :: work
    integer intent(out)::info

end subroutine sgelsy_lwork


subroutine dgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,info)
    ! work,info = dgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname dgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,int*,double*,int*,double*,int*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision intent(hide) :: a

    integer intent(in):: nrhs
    double precision intent(hide):: b

    double precision intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide):: jptv

    integer intent(in),optional :: lwork = -1
    double precision intent(out) :: work
    integer intent(out)::info

end subroutine dgelsy_lwork



subroutine cgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! v,x,j,rank,info = zgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,int*,float*,int*,complex_float*,int*,float*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide), depend(m,n) :: minmn = MIN(m,n)
    complex dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=minmn+MAX(MAX(2*minmn, n+1), minmn+nrhs)) :: lwork
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    real dimension(2*n),intent(hide,cache),depend(n) :: rwork
    integer intent(out)::info

end subroutine cgelsy


subroutine zgelsy(m,n,maxmn,minmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! v,x,j,rank,info = zgelsy(a,b,jptv,cond,lwork,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,jptv,&cond,&r,work,&lwork,rwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,int*,double*,int*,complex_double*,int*,double*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    integer intent(hide), depend(m,n) :: minmn = MIN(m,n)
    double complex dimension(m,n),intent(in,out,copy,out=v) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in) :: cond
    integer intent(out,out=rank) :: r
    integer intent(in,out,out=j),dimension(n),depend(n) :: jptv

    ! LWORK is obtained by the query call
    integer intent(in),depend(nrhs,m,n,minmn) :: lwork
    check(lwork>=minmn+MAX(MAX(2*minmn, n+1), minmn+nrhs)) :: lwork
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work
    double precision dimension(2*n),intent(hide,cache),depend(n) :: rwork
    integer intent(out)::info

end subroutine zgelsy



subroutine cgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! work,info = zgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname cgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,int*,float*,int*,complex_float*,int*,float*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide) :: maxmn = MAX(m,n)
    complex intent(hide) :: a

    integer intent(in):: nrhs
    complex intent(hide) :: b

    real intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide) :: jptv

    integer intent(in),optional :: lwork = -1
    complex intent(out) :: work
    real intent(hide) :: rwork
    integer intent(out)::info

end subroutine cgelsy_lwork


subroutine zgelsy_lwork(m,n,maxmn,nrhs,a,b,jptv,cond,r,work,lwork,rwork,info)
    ! work,info = zgelsy_lwork(m,n,nrhs,cond)
    ! Query for optimal lwork size

    fortranname zgelsy
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&jptv,&cond,&r,&work,&lwork,&rwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,int*,double*,int*,complex_double*,int*,double*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide) :: maxmn = MAX(m,n)
    double complex intent(hide) :: a

    integer intent(in):: nrhs
    double complex intent(hide) :: b

    double precision intent(in) :: cond
    integer intent(hide) :: r
    integer intent(hide) :: jptv

    integer intent(in),optional :: lwork = -1
    double complex intent(out) :: work
    double precision intent(hide) :: rwork
    integer intent(out)::info

end subroutine zgelsy_lwork



subroutine sgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_iwork,iwork,info)
    ! x,s,rank,info = dgelsd(a,b,lwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,iwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,float*,float*,int*,float*,int*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_iwork
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine sgelsd


subroutine dgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_iwork,iwork,info)
    ! x,s,rank,info = dgelsd(a,b,lwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork,iwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,double*,double*,int*,double*,int*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_iwork
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine dgelsd



subroutine sgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,iwork,info)
   ! work,iwork,info = dgelsd_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size

    fortranname sgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&iwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,float*,float*,int*,float*,int*,int*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    real intent(hide) :: a

    integer intent(in):: nrhs
    real intent(hide) :: b

    real intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    real intent(out) :: work

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine sgelsd_lwork


subroutine dgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,iwork,info)
   ! work,iwork,info = dgelsd_lwork(m,n,nrhs,cond=-1.0)
   ! Query for optimal lwork size

    fortranname dgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork,&iwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,double*,double*,int*,double*,int*,int*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double precision intent(hide) :: a

    integer intent(in):: nrhs
    double precision intent(hide) :: b

    double precision intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    double precision intent(out) :: work

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine dgelsd_lwork



subroutine cgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_rwork,rwork, size_iwork,iwork,info)
    ! x,s,rank,info = zgelsd(a,b,lwork,size_rwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork, rwork, iwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,int*, complex_float*,int*,float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    real intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    real intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1||lwork==-1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_rwork, size_iwork
    complex dimension(MAX(lwork,1)),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_rwork
    real intent(cache,hide),dimension(MAX(1,size_rwork)),depend(size_rwork) :: rwork

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine cgelsd


subroutine zgelsd(m,n,minmn,maxmn,nrhs,a,b,s,cond,r,work,lwork,size_rwork,rwork, size_iwork,iwork,info)
    ! x,s,rank,info = zgelsd(a,b,lwork,size_rwork,size_iwork,cond=-1.0,overwrite_a=True,overwrite_b=True)
    ! Solve Minimize 2-norm(A * X - B).

    callstatement (*f2py_func)(&m,&n,&nrhs,a,&m,b,&maxmn,s,&cond,&r,work,&lwork, rwork, iwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,int*, complex_double*,int*,double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(m,n):: minmn = MIN(m,n)
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex dimension(m,n),intent(in,copy) :: a

    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(maxmn,nrhs),check(maxmn==shape(b,0)),depend(maxmn) :: b
    intent(in,out,copy,out=x) b

    double precision intent(in),optional :: cond=-1.0
    integer intent(out,out=rank) :: r
    double precision intent(out),dimension(minmn),depend(minmn) :: s

    integer intent(in),check(lwork>=1||lwork==-1) :: lwork
    ! Impossible to calculate lwork explicitly, need to obtain it from query call first
    ! Same for size_rwork, size_iwork
    double complex dimension(MAX(lwork,1)),intent(cache,hide),depend(lwork) :: work

    integer intent(in) :: size_rwork
    double precision intent(cache,hide),dimension(MAX(1,size_rwork)),depend(size_rwork) :: rwork

    integer intent(in) :: size_iwork
    integer intent(cache,hide),dimension(MAX(1,size_iwork)),depend(size_iwork) :: iwork
    integer intent(out)::info

end subroutine zgelsd



subroutine cgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,rwork,iwork,info)
    ! work,rwork,iwork,info = zgelsd_lwork(m,n,nrhs,lwork=-1.0,cond=-1.0)
    ! Query for optimal lwork size

    fortranname cgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork, &rwork, &iwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,int*, complex_float*,int*,float*,int*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    complex intent(hide) :: a

    integer intent(in):: nrhs
    complex intent(hide) :: b

    real intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    real intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    complex intent(out) :: work
    real intent(out) :: rwork

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine cgelsd_lwork


subroutine zgelsd_lwork(m,n,maxmn,nrhs,a,b,s,cond,r,work,lwork,rwork,iwork,info)
    ! work,rwork,iwork,info = zgelsd_lwork(m,n,nrhs,lwork=-1.0,cond=-1.0)
    ! Query for optimal lwork size

    fortranname zgelsd
    callstatement (*f2py_func)(&m,&n,&nrhs,&a,&m,&b,&maxmn,&s,&cond,&r,&work,&lwork, &rwork, &iwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,int*, complex_double*,int*,double*,int*,int*

    integer intent(in) :: m
    integer intent(in) :: n
    integer intent(hide),depend(m,n):: maxmn = MAX(m,n)
    double complex intent(hide) :: a

    integer intent(in):: nrhs
    double complex intent(hide) :: b

    double precision intent(in),optional :: cond=-1.0
    integer intent(hide) :: r
    double precision intent(hide) :: s

    integer intent(in),optional :: lwork = -1
    double complex intent(out) :: work
    double precision intent(out) :: rwork

    integer intent(out) :: iwork
    integer intent(out)::info

end subroutine zgelsd_lwork



subroutine sgeqp3(m,n,a,jpvt,tau,work,lwork,info)
   ! qr_a,jpvt,tau,work,info = geqp3(a,lwork=3*(n+1),overwrite_a=0)
   ! Compute a QR factorization of a real M-by-N matrix A with column pivoting:
   !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,&info)
    callprotoargument int*,int*,float*,int*,int*,float*,float*,int*,int*
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    real dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info
end subroutine sgeqp3


subroutine dgeqp3(m,n,a,jpvt,tau,work,lwork,info)
   ! qr_a,jpvt,tau,work,info = geqp3(a,lwork=3*(n+1),overwrite_a=0)
   ! Compute a QR factorization of a real M-by-N matrix A with column pivoting:
   !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,&info)
    callprotoargument int*,int*,double*,int*,int*,double*,double*,int*,int*
    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    double precision dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info
end subroutine dgeqp3



subroutine cgeqp3(m,n,a,jpvt,tau,work,lwork,rwork,info)
    ! qr_a,jpvt,tau,work,info = geqp3(a,lwork,overwrite_a=0)
    ! Compute a QR factorization of a complex M-by-N matrix A with column pivoting:
    !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,rwork,&info)
    callprotoargument int*,int*,complex_float*,int*,int*,complex_float*,complex_float*,int*,float*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    real dimension(2*n),intent(hide),depend(n) :: rwork
    integer intent(out) :: info

end subroutine cgeqp3


subroutine zgeqp3(m,n,a,jpvt,tau,work,lwork,rwork,info)
    ! qr_a,jpvt,tau,work,info = geqp3(a,lwork,overwrite_a=0)
    ! Compute a QR factorization of a complex M-by-N matrix A with column pivoting:
    !   A * P = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,jpvt,tau,work,&lwork,rwork,&info)
    callprotoargument int*,int*,complex_double*,int*,int*,complex_double*,complex_double*,int*,double*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    integer dimension(n),intent(out) :: jpvt
    double complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*(n+1),1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    double precision dimension(2*n),intent(hide),depend(n) :: rwork
    integer intent(out) :: info

end subroutine zgeqp3



subroutine sgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,float*,int*,float*,float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    real dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sgeqrf


subroutine dgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,double*,int*,double*,double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double precision dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dgeqrf


subroutine cgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cgeqrf


subroutine zgeqrf(m,n,a,tau,work,lwork,info)
    ! qr_a,tau,work,info = geqrf(a,lwork=3*n,overwrite_a=0)
    ! Compute a QR factorization of a real M-by-N matrix A:
    !   A = Q * R.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zgeqrf



subroutine sgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,float*,int*,float*,float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    real dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    real dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sgerqf


subroutine dgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,double*,int*,double*,double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double precision dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double precision dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dgerqf


subroutine cgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cgerqf


subroutine zgerqf(m,n,a,tau,work,lwork,info)
   ! rq_a,tau,work,info = gerqf(a,lwork=3*n,overwrite_a=0)
   ! Compute an RQ factorization of a real M-by-N matrix A:
   !   A = R * Q.

    threadsafe
    callstatement (*f2py_func)(&m,&n,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    double complex dimension(m,n),intent(in,out,copy,out=qr,aligned8) :: a
    double complex dimension(MIN(m,n)),intent(out) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zgerqf



subroutine sgeev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! wr,wi,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=4*n,overwrite_a=0)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,int*,float*,int*,float*,float*,float*,int*,float*,int*,float*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    real  dimension(n,n),intent(in,copy,aligned8) :: a
    check(shape(a,0)==shape(a,1)) :: a

    real dimension(n),intent(out),depend(n) :: wr
    real dimension(n),intent(out),depend(n) :: wi

    real dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    real dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(4*n,1)
    check(lwork>=((compute_vl||compute_vr)?4*n:3*n)) :: lwork
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(out):: info

end subroutine sgeev


subroutine dgeev(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! wr,wi,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=4*n,overwrite_a=0)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,wr,wi,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision  dimension(n,n),intent(in,copy,aligned8) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double precision dimension(n),intent(out),depend(n) :: wr
    double precision dimension(n),intent(out),depend(n) :: wi

    double precision dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double precision dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(4*n,1)
    check(lwork>=((compute_vl||compute_vr)?4*n:3*n)) :: lwork
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(out):: info

end subroutine dgeev



subroutine sgeev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! LWORK=-1 call for (S/D)GEEV --- keep in sync with above (S/D)GEEV definition

    fortranname sgeev
    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&wr,&wi,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&info);}
    callprotoargument char*,char*,int*,float*,int*,float*,float*,float*,int*,float*,int*,float*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    real intent(hide) :: a

    real intent(hide) :: wr
    real intent(hide) :: wi

    real intent(hide) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    real intent(hide) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    real intent(out) :: work

    integer intent(out):: info

end subroutine sgeev_lwork


subroutine dgeev_lwork(compute_vl,compute_vr,n,a,wr,wi,vl,ldvl,vr,ldvr,work,lwork,info)
    ! LWORK=-1 call for (S/D)GEEV --- keep in sync with above (S/D)GEEV definition

    fortranname dgeev
    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&wr,&wi,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&info);}
    callprotoargument char*,char*,int*,double*,int*,double*,double*,double*,int*,double*,int*,double*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    double precision intent(hide) :: a

    double precision intent(hide) :: wr
    double precision intent(hide) :: wi

    double precision intent(hide) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double precision intent(hide) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    double precision intent(out) :: work

    integer intent(out):: info

end subroutine dgeev_lwork



subroutine cgeev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! w,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,w,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    complex  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    complex  dimension(n),intent(out),depend(n) :: w

    complex  dimension(ldvl,n),depend(ldvl),intent(out) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    complex  dimension(ldvr,n),depend(ldvr),intent(out) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(2*n,1)
    check(lwork>=2*n) :: lwork
    complex dimension(lwork),intent(hide),depend(lwork) :: work
    real dimension(2*n),intent(hide,cache),depend(n) :: rwork

    integer intent(out):: info

end subroutine cgeev


subroutine zgeev(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! w,vl,vr,info = geev(a,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,w,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double complex  dimension(n),intent(out),depend(n) :: w

    double complex  dimension(ldvl,n),depend(ldvl),intent(out) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    double complex  dimension(ldvr,n),depend(ldvr),intent(out) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(2*n,1)
    check(lwork>=2*n) :: lwork
    double complex dimension(lwork),intent(hide),depend(lwork) :: work
    double precision dimension(2*n),intent(hide,cache),depend(n) :: rwork

    integer intent(out):: info

end subroutine zgeev



subroutine cgeev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! LWORK=-1 call for (C/Z)GEEV --- keep in sync with above (C/Z)GEEV definition

    fortranname cgeev
    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&w,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    complex intent(hide) :: a

    complex intent(hide) :: w

    complex intent(hide) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    complex intent(hide) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    complex intent(out) :: work
    real intent(hide) :: rwork

    integer intent(out):: info

end subroutine cgeev_lwork


subroutine zgeev_lwork(compute_vl,compute_vr,n,a,w,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! LWORK=-1 call for (C/Z)GEEV --- keep in sync with above (C/Z)GEEV definition

    fortranname zgeev
    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,&a,&n,&w,&vl,&ldvl,&vr,&ldvr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(in) :: n
    double complex intent(hide) :: a

    double complex intent(hide) :: w

    double complex intent(hide) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    double complex intent(hide) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer intent(hide) :: lwork = -1
    double complex intent(out) :: work
    double precision intent(hide) :: rwork

    integer intent(out):: info

end subroutine zgeev_lwork



subroutine sgegv(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)
    ! Compute the generalized eigenvalues (alphar +/- alphai*i, beta)
    ! of the real nonsymmetric matrices A and B: det(A-w*B)=0 where w=alpha/beta.
    ! Optionally, compute the left and/or right generalized eigenvectors:
    ! (A - w B) r = 0, l^H * (A - w B) = 0
    !
    ! alphar,alphai,beta,vl,vr,info = gegv(a,b,compute_vl=1,compute_vr=1,lwork=8*n,overwrite_a=0,overwrite_b=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info)
    callprotoargument char*,char*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,float*,int*,float*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    real  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    real  dimension(n,n),depend(n),intent(in,copy) :: b
    check(shape(b,0)==shape(b,1) && shape(b,0)==n) :: b

    real dimension(n),depend(n),intent(out) :: alphar
    real dimension(n),depend(n),intent(out) :: alphai
    real dimension(n),depend(n),intent(out) :: beta

    real  dimension(ldvl,n),intent(out),depend(ldvl) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    real  dimension(ldvr,n),intent(out),depend(ldvr) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(8*n,1)
    check(lwork>=8*n) :: lwork
    real dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out):: info

end subroutine sgegv


subroutine dgegv(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)
    ! Compute the generalized eigenvalues (alphar +/- alphai*i, beta)
    ! of the real nonsymmetric matrices A and B: det(A-w*B)=0 where w=alpha/beta.
    ! Optionally, compute the left and/or right generalized eigenvectors:
    ! (A - w B) r = 0, l^H * (A - w B) = 0
    !
    ! alphar,alphai,beta,vl,vr,info = gegv(a,b,compute_vl=1,compute_vr=1,lwork=8*n,overwrite_a=0,overwrite_b=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info)
    callprotoargument char*,char*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,double*,int*,double*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double precision  dimension(n,n),depend(n),intent(in,copy) :: b
    check(shape(b,0)==shape(b,1) && shape(b,0)==n) :: b

    double precision dimension(n),depend(n),intent(out) :: alphar
    double precision dimension(n),depend(n),intent(out) :: alphai
    double precision dimension(n),depend(n),intent(out) :: beta

    double precision  dimension(ldvl,n),intent(out),depend(ldvl) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    double precision  dimension(ldvr,n),intent(out),depend(ldvr) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(8*n,1)
    check(lwork>=8*n) :: lwork
    double precision dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out):: info

end subroutine dgegv



subroutine cgegv(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! Compute the generalized eigenvalues (alpha, beta)
    ! of the comples nonsymmetric matrices A and B: det(A-w*B)=0 where w=alpha/beta.
    ! Optionally, compute the left and/or right generalized eigenvectors:
    ! (A - w B) r = 0, l^H * (A - w B) = 0
    !
    ! alpha,beta,vl,vr,info = gegv(a,b,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0,overwrite_b=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    complex  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    complex  dimension(n,n),depend(n),intent(in,copy) :: b
    check(shape(b,0)==shape(b,1) && shape(b,0)==n) :: b

    complex dimension(n),depend(n),intent(out) :: alpha
    complex dimension(n),depend(n),intent(out) :: beta

    complex  dimension(ldvl,n),intent(out),depend(ldvl) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    complex  dimension(ldvr,n),intent(out),depend(ldvr) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(2*n,1)
    check(lwork>=2*n) :: lwork
    complex dimension(lwork),intent(hide),depend(lwork) :: work
    real dimension(8*n),intent(hide),depend(n) :: rwork

    integer intent(out):: info

end subroutine cgegv


subroutine zgegv(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)
    ! Compute the generalized eigenvalues (alpha, beta)
    ! of the comples nonsymmetric matrices A and B: det(A-w*B)=0 where w=alpha/beta.
    ! Optionally, compute the left and/or right generalized eigenvectors:
    ! (A - w B) r = 0, l^H * (A - w B) = 0
    !
    ! alpha,beta,vl,vr,info = gegv(a,b,compute_vl=1,compute_vr=1,lwork=2*n,overwrite_a=0,overwrite_b=0)

    callstatement (*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double complex  dimension(n,n),depend(n),intent(in,copy) :: b
    check(shape(b,0)==shape(b,1) && shape(b,0)==n) :: b

    double complex dimension(n),depend(n),intent(out) :: alpha
    double complex dimension(n),depend(n),intent(out) :: beta

    double complex  dimension(ldvl,n),intent(out),depend(ldvl) :: vl
    integer intent(hide),depend(compute_vl,n) :: ldvl=(compute_vl?n:1)

    double complex  dimension(ldvr,n),intent(out),depend(ldvr) :: vr
    integer intent(hide),depend(compute_vr,n) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n) :: lwork=max(2*n,1)
    check(lwork>=2*n) :: lwork
    double complex dimension(lwork),intent(hide),depend(lwork) :: work
    double precision dimension(8*n),intent(hide),depend(n) :: rwork

    integer intent(out):: info

end subroutine zgegv



subroutine cgees(compute_v,sort_t,cselect,n,a,nrows,sdim,w,vs,ldvs,work,lwork,rwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a complex matrix is in Schur form if it is upper
    !  triangular

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_cselect_in_gees__user__routines,&n,a,&nrows,&sdim,w,vs,&ldvs,work,&lwork,rwork,bwork,&info,1,1)
    callprotoargument char*,char*,int(*)(complex_float*),int*,complex_float*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*,float*,int*,int*,int,int

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external cselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    complex intent(in,out,copy,out=t),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    complex intent(out),dimension(n) :: w
    complex intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    real optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine cgees


subroutine zgees(compute_v,sort_t,zselect,n,a,nrows,sdim,w,vs,ldvs,work,lwork,rwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a complex matrix is in Schur form if it is upper
    !  triangular

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_zselect_in_gees__user__routines,&n,a,&nrows,&sdim,w,vs,&ldvs,work,&lwork,rwork,bwork,&info,1,1)
    callprotoargument char*,char*,int(*)(complex_double*),int*,complex_double*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*,double*,int*,int*,int,int

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external zselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    double complex intent(in,out,copy,out=t),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    double complex intent(out),dimension(n) :: w
    double complex intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    double complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    double precision optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine zgees



subroutine sgees(compute_v,sort_t,sselect,n,a,nrows,sdim,wr,wi,vs,ldvs,work,lwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a real matrix is in Schur form if it is upper quasi-
    !  triangular with 1x1 and 2x2 blocks.

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_sselect_in_gees__user__routines,&n,a,&nrows,&sdim,wr,wi,vs,&ldvs,work,&lwork,bwork,&info,1,1)
    callprotoargument char*,char*,int(*)(float*,float*),int*,float*,int*,int*,float*,float*,float*,int*,float*,int*,int*,int*,int,int

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external sselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    real intent(in,out,copy,out=t,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    real intent(out),dimension(n) :: wr
    real intent(out),dimension(n) :: wi
    real intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    real intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    real optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine sgees


subroutine dgees(compute_v,sort_t,dselect,n,a,nrows,sdim,wr,wi,vs,ldvs,work,lwork,bwork,info)
    ! t,sdim,w,vs,work,info=gees(compute_v=1,sort_t=0,select,a,lwork=3*n)
    ! For an NxN matrix compute the eigenvalues, the schur form T, and optionally
    !  the matrix of Schur vectors Z.  This gives the Schur factorization
    !  A = Z * T * Z^H  -- a real matrix is in Schur form if it is upper quasi-
    !  triangular with 1x1 and 2x2 blocks.

    callstatement (*f2py_func)((compute_v?"V":"N"),(sort_t?"S":"N"),cb_dselect_in_gees__user__routines,&n,a,&nrows,&sdim,wr,wi,vs,&ldvs,work,&lwork,bwork,&info,1,1)
    callprotoargument char*,char*,int(*)(double*,double*),int*,double*,int*,int*,double*,double*,double*,int*,double*,int*,int*,int*,int,int

    use gees__user__routines

    integer optional,intent(in),check(compute_v==0||compute_v==1) :: compute_v = 1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t = 0
    external dselect
    integer intent(hide),depend(a) :: n = shape(a,1)
    double precision intent(in,out,copy,out=t,aligned8),check(shape(a,0)==shape(a,1)),dimension(n,n) :: a
    integer intent(hide),depend(a) :: nrows=shape(a,0)
    integer intent(out) :: sdim=0
    double precision intent(out),dimension(n) :: wr
    double precision intent(out),dimension(n) :: wi
    double precision intent(out),depend(ldvs,n),dimension(ldvs,n) :: vs
    integer intent(hide),depend(compute_v,n) :: ldvs=((compute_v==1)?n:1)
    double precision intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),check((lwork==-1)||(lwork >= MAX(1,2*n))),depend(n) :: lwork = max(3*n,1)
    double precision optional,intent(hide),depend(n),dimension(n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out) :: info

end subroutine dgees



subroutine sgges(jobvsl,jobvsr,sort_t,sselect,n,a,lda,b,ldb,sdim,alphar,alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
    ! For a pair of N-by-N real nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_sselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alphar,alphai,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,bwork,&info)
    callprotoargument char*,char*,char*,int(*)(float*,float*,float*),int*,float*,int*,float*,int*,int*,float*,float*,float*,float*,int*,float*,int*,float*,int*,int*,int*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external sselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    real intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    real intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    real intent(out),dimension(n) :: alphar
    real intent(out),dimension(n) :: alphai
    real intent(out),dimension(n) :: beta
    real intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    real intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    real intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,MAX(8*n, 6*n+16))||lwork==-1):: lwork=max(8*n+16,1)
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine sgges


subroutine dgges(jobvsl,jobvsr,sort_t,dselect,n,a,lda,b,ldb,sdim,alphar,alphai,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,bwork,info)
    ! For a pair of N-by-N real nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_dselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alphar,alphai,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,bwork,&info)
    callprotoargument char*,char*,char*,int(*)(double*,double*,double*),int*,double*,int*,double*,int*,int*,double*,double*,double*,double*,int*,double*,int*,double*,int*,int*,int*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external dselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    double precision intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    double precision intent(out),dimension(n) :: alphar
    double precision intent(out),dimension(n) :: alphai
    double precision intent(out),dimension(n) :: beta
    double precision intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    double precision intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    double precision intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,MAX(8*n, 6*n+16))||lwork==-1):: lwork=max(8*n+16,1)
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine dgges



subroutine cgges(jobvsl,jobvsr,sort_t,cselect,n,a,lda,b,ldb,sdim,alpha,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
    ! For a pair of N-by-N complex nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**H )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_cselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alpha,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,rwork,bwork,&info)
    callprotoargument char*,char*,char*,int(*)(complex_float*,complex_float*),int*,complex_float*,int*,complex_float*,int*,int*,complex_float*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*,int*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external cselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    complex intent(out),dimension(n) :: alpha
    complex intent(out),dimension(n) :: beta
    complex intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    complex intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,2*n)||lwork==-1):: lwork=max(2*n,1)
    real intent(hide),dimension(8*n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine cgges


subroutine zgges(jobvsl,jobvsr,sort_t,zselect,n,a,lda,b,ldb,sdim,alpha,beta,vsl,ldvsl,vsr,ldvsr,work,lwork,rwork,bwork,info)
    ! For a pair of N-by-N complex nonsymmetric matrices (A,B) computes
    ! the generalized eigenvalues, the generalized real Schur form (S,T),
    ! optionally, the left and/or right matrices of Schur vectors (VSL
    ! and VSR).
    ! (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**H )

    callstatement (*f2py_func)((jobvsl?"V":"N"),(jobvsr?"V":"N"),(sort_t?"S":"N"),cb_zselect_in_gges__user__routines,&n,a,&lda,b,&ldb,&sdim,alpha,beta,vsl,&ldvsl,vsr,&ldvsr,work,&lwork,rwork,bwork,&info)
    callprotoargument char*,char*,char*,int(*)(complex_double*,complex_double*),int*,complex_double*,int*,complex_double*,int*,int*,complex_double*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*,int*

    use gges__user__routines

    integer optional,intent(in),check(jobvsl==0||jobvsl==1) :: jobvsl=1
    integer optional,intent(in),check(jobvsr==0||jobvsr==1) :: jobvsr=1
    integer optional,intent(in),check(sort_t==0||sort_t==1) :: sort_t=0
    external zselect
    integer intent(hide),depend(a) :: n=shape(a,1)
    double complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(out) :: sdim=0
    double complex intent(out),dimension(n) :: alpha
    double complex intent(out),dimension(n) :: beta
    double complex intent(out),depend(ldvsl,n),dimension(ldvsl,n) :: vsl
    integer optional,intent(in),depend(jobvsl,n) :: ldvsl=((jobvsl==1)?n:1)
    double complex intent(out),depend(ldvsr,n),dimension(ldvsr,n) :: vsr
    integer optional,intent(in),depend(jobvsr,n) :: ldvsr=((jobvsr==1)?n:1)
    double complex intent(out),depend(lwork),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(n),check(lwork>=MAX(1,2*n)||lwork==-1):: lwork=max(2*n,1)
    double precision intent(hide),dimension(8*n) :: rwork
    logical optional,intent(hide),depend(n),dimension(n) :: bwork
    integer intent(out):: info

end subroutine zgges



subroutine sggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,float*,int*,float*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    real  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    real intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    real intent(out), dimension(n), depend(n) :: alphar
    real intent(out), dimension(n), depend(n) :: alphai
    real intent(out), dimension(n), depend(n) :: beta

    real  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    real  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(8*n,1)
    check((lwork==-1) || (lwork>=MAX(1,8*n))) :: lwork
    real intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work

    integer intent(out):: info

end subroutine sggev


subroutine dggev(compute_vl,compute_vr,n,a,b,alphar,alphai,beta,vl,ldvl,vr,ldvr,work,lwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alphar,alphai,beta,vl,&ldvl,vr,&ldvr,work,&lwork,&info);}
    callprotoargument char*,char*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,double*,int*,double*,int*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision  dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double precision intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    double precision intent(out), dimension(n), depend(n) :: alphar
    double precision intent(out), dimension(n), depend(n) :: alphai
    double precision intent(out), dimension(n), depend(n) :: beta

    double precision  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double precision  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(8*n,1)
    check((lwork==-1) || (lwork>=MAX(1,8*n))) :: lwork
    double precision intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work

    integer intent(out):: info

end subroutine dggev



subroutine cggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info);}
    callprotoargument char*,char*,int*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    complex dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    complex intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    complex intent(out), dimension(n), depend(n) :: alpha
    complex intent(out), dimension(n), depend(n) :: beta

    complex  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    complex  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(2*n,1)
    check((lwork==-1) || (lwork>=MAX(1,2*n))) :: lwork
    complex intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work
    real intent(hide), dimension(8*n), depend(n) :: rwork

    integer intent(out):: info

end subroutine sggev


subroutine zggev(compute_vl,compute_vr,n,a,b,alpha,beta,vl,ldvl,vr,ldvr,work,lwork,rwork,info)

    callstatement {(*f2py_func)((compute_vl?"V":"N"),(compute_vr?"V":"N"),&n,a,&n,b,&n,alpha,beta,vl,&ldvl,vr,&ldvr,work,&lwork,rwork,&info);}
    callprotoargument char*,char*,int*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*

    integer optional,intent(in):: compute_vl = 1
    check(compute_vl==1||compute_vl==0) compute_vl
    integer optional,intent(in):: compute_vr = 1
    check(compute_vr==1||compute_vr==0) compute_vr

    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex dimension(n,n),intent(in,copy) :: a
    check(shape(a,0)==shape(a,1)) :: a

    double complex intent(in,copy), dimension(n,n) :: b
    check(shape(b,0)==shape(b,1)) :: b

    double complex intent(out), dimension(n), depend(n) :: alpha
    double complex intent(out), dimension(n), depend(n) :: beta

    double complex  depend(ldvl,n), dimension(ldvl,n),intent(out) :: vl
    integer intent(hide),depend(n,compute_vl) :: ldvl=(compute_vl?n:1)

    double complex  depend(ldvr,n), dimension(ldvr,n),intent(out) :: vr
    integer intent(hide),depend(n,compute_vr) :: ldvr=(compute_vr?n:1)

    integer optional,intent(in),depend(n,compute_vl,compute_vr) :: lwork=max(2*n,1)
    check((lwork==-1) || (lwork>=MAX(1,2*n))) :: lwork
    double complex intent(out), dimension(MAX(lwork,1)), depend(lwork) :: work
    double precision intent(hide), dimension(8*n), depend(n) :: rwork

    integer intent(out):: info

end subroutine dggev


! Signatures for f2py-wrappers of FORTRAN LAPACK General Banded Matrix functions.
!

subroutine sgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {int i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,int*,int*,float*,int*,int*,float*,int*,int*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    real dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    real dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine sgbsv


subroutine dgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {int i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,int*,int*,double*,int*,int*,double*,int*,int*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    double precision dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    double precision dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine dgbsv


subroutine cgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {int i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,int*,int*,complex_float*,int*,int*,complex_float*,int*,int*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    complex dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    complex dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine cgbsv


subroutine zgbsv(n,kl,ku,nrhs,ab,piv,b,info)
     ! lub,piv,x,info = gbsv(kl,ku,ab,b,overwrite_ab=0,overwrite_b=0)
    ! Solve A * X = B
    ! A = P * L * U
    ! A is a band matrix of order n with kl subdiagonals and ku superdiagonals
    ! starting at kl-th row.
    ! X, B are n-by-nrhs matrices
 
    callstatement {int i=2*kl+ku+1;(*f2py_func)(&n,&kl,&ku,&nrhs,ab,&i,piv,b,&n,&info);for(i=0;i<n;--piv[i++]);}
    callprotoargument int*,int*,int*,int*,complex_double*,int*,int*,complex_double*,int*,int*
    integer depend(ab),intent(hide):: n = shape(ab,1)
    integer intent(in) :: kl
    integer intent(in) :: ku
    integer depend(b),intent(hide) :: nrhs = shape(b,1)
    double complex dimension(2*kl+ku+1,n),depend(kl,ku), check(2*kl+ku+1==shape(ab,0)) :: ab
    integer dimension(n),depend(n),intent(out) :: piv
    double complex dimension(n,nrhs),depend(n),check(shape(ab,1)==shape(b,0)) :: b
    integer intent(out) :: info
    intent(in,out,copy,out=x) b
    intent(in,out,copy,out=lub) ab

end subroutine zgbsv


   
subroutine sgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {int i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument int*,int*,int*,int*,float*,int*,int*,int*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    real dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine sgbtrf

   
subroutine dgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {int i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument int*,int*,int*,int*,double*,int*,int*,int*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    double precision dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine dgbtrf

   
subroutine cgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {int i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument int*,int*,int*,int*,complex_float*,int*,int*,int*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    complex dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine cgbtrf

   
subroutine zgbtrf(m,n,ab,kl,ku,ldab,ipiv,info)
    ! in :Band:dgbtrf.f
    ! lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
    ! Compute  an  LU factorization of a real m-by-n band matrix

    ! threadsafe  ! FIXME: should this be added ?

    callstatement {int i;(*f2py_func)(&m,&n,&kl,&ku,ab,&ldab,ipiv,&info); for(i=0,n=MIN(m,n);i<n;--ipiv[i++]);}
    callprotoargument int*,int*,int*,int*,complex_double*,int*,int*,int*

    ! let the default be a square matrix:
    integer optional,depend(ab) :: m=shape(ab,1)
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku

    double complex dimension(ldab,n),intent(in,out,copy,out=lu) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=max(shape(ab,0),1)
    integer dimension(MIN(m,n)),depend(m,n),intent(out) :: ipiv
    integer intent(out):: info

end subroutine zgbtrf



subroutine sgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {int i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,int*,int *,int*,int*,float*,int*,int*,float*,int*,int*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    real dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    real dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine sgbtrs


subroutine dgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {int i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,int*,int *,int*,int*,double*,int*,int*,double*,int*,int*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    double precision dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    double precision dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine dgbtrs


subroutine cgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {int i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,int*,int *,int*,int*,complex_float*,int*,int*,complex_float*,int*,int*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    complex dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine cgbtrs


subroutine zgbtrs(ab,kl,ku,b,ipiv,trans,n,nrhs,ldab,ldb,info) ! in :Band:dgbtrs.f
    ! x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
    ! solve a system of linear equations A * X = B or A' * X = B
    ! with a general band matrix A using the  LU  factorization
    ! computed by DGBTRF
    !
    ! TRANS   Specifies the form of the system of equations.
    !  0  = 'N':  A * X =B  (No transpose)
    !  1  = 'T':  A'* X = B  (Transpose)
    !  2  = 'C':  A'* X = B  (Conjugate transpose = Transpose)
    
    callstatement {int i;for(i=0;i<n;++ipiv[i++]);(*f2py_func)((trans>0?(trans==1?"T":"C"):"N"),&n,&kl,&ku,&nrhs,ab,&ldab,ipiv,b,&ldb,&info);for(i=0;i<n;--ipiv[i++]);}
    callprotoargument char*,int*,int *,int*,int*,complex_double*,int*,int*,complex_double*,int*,int*
    !character optional:: trans='N'
    integer optional:: trans=0
    integer optional,depend(ab) :: n=shape(ab,1)
    integer :: kl
    integer :: ku
    integer intent(hide),depend(b):: nrhs=shape(b,1)

    double complex dimension(ldab,n),intent(in) :: ab
    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)

    integer dimension(n),intent(in) :: ipiv
    double complex dimension(ldb,nrhs),intent(in,out,copy,out=x) :: b
    integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    !integer optional,check(shape(b,0)==ldb),depend(b) :: ldb=shape(b,0)
    integer intent(out):: info

end subroutine zgbtrs


! Signatures for f2py-wrappers of FORTRAN LAPACK General Tridiagonal Matrix functions.
!

subroutine sgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument int*, int*, float*, float*, float*, float*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    real dimension(n), intent(in,out,copy) :: d
    real dimension(n-1), intent(in,out,copy), depend(n) :: du
    real dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine sgtsv


subroutine dgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument int*, int*, double*, double*, double*, double*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    double precision dimension(n), intent(in,out,copy) :: d
    double precision dimension(n-1), intent(in,out,copy), depend(n) :: du
    double precision dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine dgtsv


subroutine cgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument int*, int*, complex_float*, complex_float*, complex_float*, complex_float*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    complex dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    complex dimension(n), intent(in,out,copy) :: d
    complex dimension(n-1), intent(in,out,copy), depend(n) :: du
    complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine cgtsv


subroutine zgtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument int*, int*, complex_double*, complex_double*, complex_double*, complex_double*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double complex dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    double complex dimension(n), intent(in,out,copy) :: d
    double complex dimension(n-1), intent(in,out,copy), depend(n) :: du
    double complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine zgtsv


! Signatures for f2py-wrappers of FORTRAN LAPACK Symmetric/Hermitian Matrix functions.
!

subroutine ssyev(compute_v,lower,n,w,a,work,lwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,&info)
    callprotoargument char*,char*,int*,float*,int*,float*,float*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(3*n-1,1)
    check(lwork>=3*n-1) :: lwork
    real dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out) :: info

end subroutine ssyev


subroutine dsyev(compute_v,lower,n,w,a,work,lwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,&info)
    callprotoargument char*,char*,int*,double*,int*,double*,double*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(3*n-1,1)
    check(lwork>=3*n-1) :: lwork
    double precision dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out) :: info

end subroutine dsyev



subroutine cheev(compute_v,lower,n,w,a,work,lwork,rwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,float*,complex_float*,int*,float*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(2*n-1,1)
    check(lwork>=2*n-1) :: lwork
    complex dimension(lwork),intent(hide),depend(lwork) :: work

    real dimension(3*n-1),intent(hide),depend(n) :: rwork

    integer intent(out) :: info

end subroutine cheev


subroutine zheev(compute_v,lower,n,w,a,work,lwork,rwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,double*,complex_double*,int*,double*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(2*n-1,1)
    check(lwork>=2*n-1) :: lwork
    double complex dimension(lwork),intent(hide),depend(lwork) :: work

    double precision dimension(3*n-1),intent(hide),depend(n) :: rwork

    integer intent(out) :: info

end subroutine zheev



subroutine ssyevd(compute_v,lower,n,w,a,work,lwork,iwork,liwork,info)
    ! w,v,info = syevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A using D&C.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,float*,int*,float*,float*,int*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?1+6*n+2*n*n:2*n+1),1)
    check(lwork>=(compute_v?1+6*n+2*n*n:2*n+1)) :: lwork
    real dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(hide),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(out) :: info

end subroutine ssyevd


subroutine dsyevd(compute_v,lower,n,w,a,work,lwork,iwork,liwork,info)
    ! w,v,info = syevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A using D&C.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,double*,int*,double*,double*,int*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?1+6*n+2*n*n:2*n+1),1)
    check(lwork>=(compute_v?1+6*n+2*n*n:2*n+1)) :: lwork
    double precision dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(hide),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(out) :: info

end subroutine dsyevd



subroutine cheevd(compute_v,lower,n,w,a,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! w,v,info = heevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A using D&C.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,float*,complex_float*,int*,float*,int*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    real dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?2*n+n*n:n+1),1)
    check(lwork>=(compute_v?2*n+n*n:n+1)) :: lwork
    complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(hide),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(hide),depend(n,compute_v) :: lrwork = (compute_v?1+5*n+2*n*n:n)
    real dimension(lrwork),intent(hide,cache),depend(n,lrwork) :: rwork
    integer intent(out) :: info

end subroutine cheevd


subroutine zheevd(compute_v,lower,n,w,a,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! w,v,info = heevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A using D&C.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,double*,complex_double*,int*,double*,int*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    double precision dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?2*n+n*n:n+1),1)
    check(lwork>=(compute_v?2*n+n*n:n+1)) :: lwork
    double complex dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(hide),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(hide),depend(n,compute_v) :: lrwork = (compute_v?1+5*n+2*n*n:n)
    double precision dimension(lrwork),intent(hide,cache),depend(n,lrwork) :: rwork
    integer intent(out) :: info

end subroutine zheevd



   subroutine ssytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,int*,float*,int*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     real dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinessytf2


   subroutine dsytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,int*,double*,int*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double precision dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinedsytf2


   subroutine csytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,int*,complex_float*,int*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinecsytf2


   subroutine zsytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,int*,complex_double*,int*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutinezsytf2



  subroutine ssygst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = sygst(a,b)
    ! Transforms the generalized symmetric eigenvalue problem to standard.
    ! A = inv(U^T) * A * inv(U), if itype == 1
    ! A = U^T * A * U or L^T * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument int*,char*,int*,float*,int*,float*,int*,int*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     real dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     real dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine ssygst


  subroutine dsygst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = sygst(a,b)
    ! Transforms the generalized symmetric eigenvalue problem to standard.
    ! A = inv(U^T) * A * inv(U), if itype == 1
    ! A = U^T * A * U or L^T * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument int*,char*,int*,double*,int*,double*,int*,int*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double precision dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     double precision dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine dsygst



   subroutine ssytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,float*,int*,int*,float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     real dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     real depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine ssytrf


   subroutine dsytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,double*,int*,int*,double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double precision dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     double precision depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine dsytrf


   subroutine csytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,complex_float*,int*,int*,complex_float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine csytrf


   subroutine zsytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,complex_double*,int*,int*,complex_double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zsytrf




   subroutine ssytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname ssytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,float*,int*,int*,float*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     real intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     real intent(out):: work
     integer intent(out):: info

   end subroutine ssytrf_lwork



   subroutine dsytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname dsytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,double*,int*,int*,double*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     double precision intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     double precision intent(out):: work
     integer intent(out):: info

   end subroutine dsytrf_lwork



   subroutine csytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname csytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,complex_float*,int*,int*,complex_float*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine csytrf_lwork



   subroutine zsytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname zsytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,complex_double*,int*,int*,complex_double*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zsytrf_lwork




   subroutine ssysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,float*,int*,int*,float*,int*,float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     real dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     real depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine ssysv



   subroutine dsysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,double*,int*,int*,double*,int*,double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     double precision dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     double precision depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine dsysv



   subroutine csysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine csysv



   subroutine zsysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     double complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zsysv



   subroutine ssysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname ssysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,float*,int*,int*,float*,int*,float*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     real intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     real intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     real intent(out):: work
     integer intent(out):: info

   end subroutine ssysv_lwork


   subroutine dsysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname dsysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,double*,int*,int*,double*,int*,double*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     double precision intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     double precision intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     double precision intent(out):: work
     integer intent(out):: info

   end subroutine dsysv_lwork


   subroutine csysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname csysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine csysv_lwork


   subroutine zsysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname zsysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     double complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zsysv_lwork



   subroutine ssysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,int*,int*,float*,int*,float*,int*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,int*,int*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     real optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     real depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     real dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     real intent(out):: rcond
     real intent(out),dimension(nrhs),depend(nrhs):: ferr
     real intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=3*n||lwork==-1):: lwork = max(3*n,1)
     real dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     integer intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine ssysvx


   subroutine dsysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,int*,int*,double*,int*,double*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,int*,int*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     double precision optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     double precision depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     double precision dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     double precision intent(out):: rcond
     double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
     double precision intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=3*n||lwork==-1):: lwork = max(3*n,1)
     double precision dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     integer intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine dsysvx


   subroutine csysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,float*,complex_float*,int*,float*,int*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     complex optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     complex depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     complex dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     real intent(out):: rcond
     real intent(out),dimension(nrhs),depend(nrhs):: ferr
     real intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=2*n||lwork==-1):: lwork = max(3*n,1)
     complex dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     real intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine csysvx


   subroutine zsysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,double*,complex_double*,int*,double*,int*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     double complex optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     double complex depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     double complex dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     double precision intent(out):: rcond
     double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
     double precision intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=2*n||lwork==-1):: lwork = max(3*n,1)
     double complex dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     double precision intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine zsysvx



   subroutine ssysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname ssysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,int*,int*,float*,int*,float*,int*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     real intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     real intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     real intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     real intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     real intent(hide):: rcond
     real intent(hide):: ferr
     real intent(hide):: berr
     integer intent(hide):: lwork = -1
     integer intent(hide):: irwork

     real intent(out) :: work
     integer intent(out):: info

   end subroutine ssysvx_lwork


   subroutine dsysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname dsysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,int*,int*,double*,int*,double*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     double precision intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     double precision intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     double precision intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     double precision intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     double precision intent(hide):: rcond
     double precision intent(hide):: ferr
     double precision intent(hide):: berr
     integer intent(hide):: lwork = -1
     integer intent(hide):: irwork

     double precision intent(out) :: work
     integer intent(out):: info

   end subroutine dsysvx_lwork


   subroutine csysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname csysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,float*,complex_float*,int*,float*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     complex intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     complex intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     real intent(hide):: rcond
     real intent(hide):: ferr
     real intent(hide):: berr
     integer intent(hide):: lwork = -1
     real intent(hide):: irwork

     complex intent(out) :: work
     integer intent(out):: info

   end subroutine csysvx_lwork


   subroutine zsysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname zsysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,double*,complex_double*,int*,double*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     double complex intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     double complex intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     double complex intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     double precision intent(hide):: rcond
     double precision intent(hide):: ferr
     double precision intent(hide):: berr
     integer intent(hide):: lwork = -1
     double precision intent(hide):: irwork

     double complex intent(out) :: work
     integer intent(out):: info

   end subroutine zsysvx_lwork




  subroutine ssycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a real symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (S/D)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info)
    callprotoargument char*,int*,float*,int*,int*,float*,float*,float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(in) :: anorm
    real intent(out) :: rcond
    real intent(hide),dimension(2*n),depend(n) :: work
    integer intent(hide),dimension(n),depend(n) :: iwork
    integer intent(out) :: info

  end subroutine ssycon



  subroutine dsycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a real symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (S/D)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info)
    callprotoargument char*,int*,double*,int*,int*,double*,double*,double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(in) :: anorm
    double precision intent(out) :: rcond
    double precision intent(hide),dimension(2*n),depend(n) :: work
    integer intent(hide),dimension(n),depend(n) :: iwork
    integer intent(out) :: info

  end subroutine dsycon




  subroutine csycon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,int*,complex_float*,int*,int*,float*,float*,complex_float*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(in) :: anorm
    real intent(out) :: rcond
    complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine csycon



  subroutine zsycon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,int*,complex_double*,int*,int*,double*,double*,complex_double*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(in) :: anorm
    double precision intent(out) :: rcond
    double complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine zsycon



  subroutine checon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,int*,complex_float*,int*,int*,float*,float*,complex_float*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    real intent(in) :: anorm
    real intent(out) :: rcond
    complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine checon



  subroutine zhecon(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,int*,complex_double*,int*,int*,double*,double*,complex_double*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    double precision intent(in) :: anorm
    double precision intent(out) :: rcond
    double complex intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine zhecon



  subroutine chegst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = hegst(a,b)
    ! Transforms the generalized Hermitian eigenvalue problem to standard.
    ! A = inv(U^H) * A * inv(U), if itype == 1
    ! A = U^H * A * U or L^H * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument int*,char*,int*,complex_float*,int*,complex_float*,int*,int*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     complex dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine chegst


  subroutine zhegst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = hegst(a,b)
    ! Transforms the generalized Hermitian eigenvalue problem to standard.
    ! A = inv(U^H) * A * inv(U), if itype == 1
    ! A = U^H * A * U or L^H * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument int*,char*,int*,complex_double*,int*,complex_double*,int*,int*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     double complex dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine zhegst




   subroutine chetrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a hermitian matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?HETF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,complex_float*,int*,int*,complex_float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine chetrf



   subroutine zhetrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a hermitian matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?HETF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,complex_double*,int*,int*,complex_double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     double complex dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zhetrf




   subroutine chetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?HETRF

     fortranname chetrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,complex_float*,int*,int*,complex_float*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine chetrf_lwork



   subroutine zhetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?HETRF

     fortranname zhetrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,complex_double*,int*,int*,complex_double*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     double complex intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zhetrf_lwork




   subroutine chesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solves A * X = B for X
   ! A is hermitian. For symmetric A see ?SYSV
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
     threadsafe
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=uduh):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine chesv



   subroutine zhesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solves A * X = B for X
   ! A is hermitian. For symmetric A see ?SYSV
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
     threadsafe
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=uduh):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     double complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     double complex depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine zhesv



   subroutine chesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for C/ZHESV

     fortranname chesv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in):: n

     integer intent(hide):: nrhs = 1
     complex intent(hide):: a
     integer intent(hide),depend(n):: lda = n
     integer intent(hide):: ipiv
     complex intent(hide):: b
     integer intent(hide),depend(n):: ldb = n
     integer intent(hide):: lwork = -1

     complex intent(out):: work
     integer intent(out):: info

   end subroutine chesv_lwork


   subroutine zhesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for C/ZHESV

     fortranname zhesv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in):: n

     integer intent(hide):: nrhs = 1
     double complex intent(hide):: a
     integer intent(hide),depend(n):: lda = n
     integer intent(hide):: ipiv
     double complex intent(hide):: b
     integer intent(hide),depend(n):: ldb = n
     integer intent(hide):: lwork = -1

     double complex intent(out):: work
     integer intent(out):: info

   end subroutine zhesv_lwork



subroutine chesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
   ! Solves A * X = B for X
   ! Expert driver for ?HESV
   ! A is hermitian. For symmetric A see ?SYSVX
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
    threadsafe
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,float*,complex_float*,int*,float*,int*

    integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    complex optional,dimension(n,n),depend(n),intent(in,out,out=uduh) :: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,depend(n),dimension(n),intent(in,out):: ipiv
    complex depend(n),dimension(n,nrhs),intent(in,copy) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    complex depend(n,nrhs),dimension(n,nrhs),intent(out) :: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    complex dimension(MAX(1,lwork)),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(2*n,1)
    real intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out):: info

end subroutine chesvx


subroutine zhesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
   ! Solves A * X = B for X
   ! Expert driver for ?HESV
   ! A is hermitian. For symmetric A see ?SYSVX
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
    threadsafe
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,double*,complex_double*,int*,double*,int*

    integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double complex optional,dimension(n,n),depend(n),intent(in,out,out=uduh) :: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,depend(n),dimension(n),intent(in,out):: ipiv
    double complex depend(n),dimension(n,nrhs),intent(in,copy) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double complex depend(n,nrhs),dimension(n,nrhs),intent(out) :: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double complex dimension(MAX(1,lwork)),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(2*n,1)
    double precision intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out):: info

end subroutine zhesvx



subroutine chesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
    ! lwork computation for ?HESVX
    fortranname chesvx
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,float*,complex_float*,int*,float*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in):: n

    integer intent(hide) :: factored = 0
    integer depend(b),intent(hide):: nrhs = 1
    complex intent(hide) :: a
    integer depend(n),intent(hide):: lda = n
    complex intent(hide) :: af
    integer depend(n),intent(hide):: ldaf = n
    integer intent(hide):: ipiv
    complex intent(hide) :: b
    integer depend(n),intent(hide):: ldb = n
    complex intent(hide) :: x
    integer depend(n),intent(hide):: ldx = n
    real intent(hide):: rcond
    real intent(hide):: ferr
    real intent(hide):: berr
    integer intent(hide):: lwork = -1
    real intent(hide):: rwork

    complex intent(out):: work
    integer intent(out):: info

end subroutine chesvx_lwork


subroutine zhesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
    ! lwork computation for ?HESVX
    fortranname zhesvx
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,double*,complex_double*,int*,double*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in):: n

    integer intent(hide) :: factored = 0
    integer depend(b),intent(hide):: nrhs = 1
    double complex intent(hide) :: a
    integer depend(n),intent(hide):: lda = n
    double complex intent(hide) :: af
    integer depend(n),intent(hide):: ldaf = n
    integer intent(hide):: ipiv
    double complex intent(hide) :: b
    integer depend(n),intent(hide):: ldb = n
    double complex intent(hide) :: x
    integer depend(n),intent(hide):: ldx = n
    double precision intent(hide):: rcond
    double precision intent(hide):: ferr
    double precision intent(hide):: berr
    integer intent(hide):: lwork = -1
    double precision intent(hide):: rwork

    double complex intent(out):: work
    integer intent(out):: info

end subroutine zhesvx_lwork



subroutine ssytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a real symmetric matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**T * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,int*,float*,int*,float*,float*,float*,float*,int*,int*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    real dimension(n),intent(out),depend(n) :: d
    real dimension(n-1),intent(out),depend(n) :: e
    real dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine ssytrd


subroutine dsytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a real symmetric matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**T * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,int*,double*,int*,double*,double*,double*,double*,int*,int*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    double precision dimension(n),intent(out),depend(n) :: d
    double precision dimension(n-1),intent(out),depend(n) :: e
    double precision dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dsytrd



subroutine ssytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for sytrd
    fortranname ssytrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,int*,float*,int*,float*,float*,float*,float*,int*,int*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    real intent(hide) :: a
    real intent(hide) :: d
    real intent(hide) :: e
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine ssytrd_lwork


subroutine dsytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for sytrd
    fortranname dsytrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,int*,double*,int*,double*,double*,double*,double*,int*,int*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    double precision intent(hide) :: a
    double precision intent(hide) :: d
    double precision intent(hide) :: e
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine dsytrd_lwork



subroutine chetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a complex hermitian matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**H * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,int*,complex_float*,int*,float*,float*,complex_float*,complex_float*,int*,int*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    real dimension(n),intent(out),depend(n) :: d
    real dimension(n-1),intent(out),depend(n) :: e
    complex dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine chetrd


subroutine zhetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a complex hermitian matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**H * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,int*,complex_double*,int*,double*,double*,complex_double*,complex_double*,int*,int*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    double precision dimension(n),intent(out),depend(n) :: d
    double precision dimension(n-1),intent(out),depend(n) :: e
    double complex dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    double complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zhetrd



subroutine chetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for hetrd
    fortranname chetrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,int*,complex_float*,int*,float*,float*,complex_float*,complex_float*,int*,int*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    complex intent(hide) :: a
    real intent(hide) :: d
    real intent(hide) :: e
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine chetrd_lwork


subroutine zhetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for hetrd
    fortranname zhetrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,int*,complex_double*,int*,double*,double*,complex_double*,complex_double*,int*,int*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    double complex intent(hide) :: a
    double precision intent(hide) :: d
    double precision intent(hide) :: e
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine zhetrd_lwork



subroutine ssyevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! Standard Eigenvalue Problem
    ! simple/expert driver: all eigenvectors or optionally selected eigenvalues
    ! algorithm: Relatively Robust Representation
    ! matrix storage
    ! Real - Single precision
    character intent(in) :: jobz='V'
    character intent(in) :: range='A'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    real intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    real intent(hide) :: vl=0
    real intent(hide) :: vu=1
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    real intent(hide) :: abstol=0.
    integer  intent(hide),depend(iu) :: m=iu-il+1
    real intent(out),dimension(n),depend(n) :: w
    real intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(hide),dimension(2*m) :: isuppz
    integer intent(in),depend(n) :: lwork=max(26*n,1)
    real  intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n):: liwork=10*n
    integer intent(hide),dimension(liwork) :: iwork
    integer  intent(out) :: info

end subroutine ssyevr


subroutine dsyevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! Standard Eigenvalue Problem
    ! simple/expert driver: all eigenvectors or optionally selected eigenvalues
    ! algorithm: Relatively Robust Representation
    ! matrix storage
    ! Real - Single precision
    character intent(in) :: jobz='V'
    character intent(in) :: range='A'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double precision intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double precision intent(hide) :: vl=0
    double precision intent(hide) :: vu=1
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    double precision intent(hide) :: abstol=0.
    integer  intent(hide),depend(iu) :: m=iu-il+1
    double precision intent(out),dimension(n),depend(n) :: w
    double precision intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(hide),dimension(2*m) :: isuppz
    integer intent(in),depend(n) :: lwork=max(26*n,1)
    double precision  intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n):: liwork=10*n
    integer intent(hide),dimension(liwork) :: iwork
    integer  intent(out) :: info

end subroutine dsyevr



subroutine cheevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Standard Eigenvalue Problem
    ! simple/expert driver: all eigenvectors or optionally selected eigenvalues
    ! algorithm: Relatively Robust Representation
    ! matrix storage
    ! Complex - Single precision
    character intent(in) :: jobz='V'
    character intent(in) :: range='A'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    complex intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    real intent(hide) :: vl=0
    real intent(hide) :: vu=1
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    real intent(hide) :: abstol=0.
    integer  intent(hide),depend(iu) :: m=iu-il+1
    real intent(out),dimension(n),depend(n) :: w
    complex intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(hide),dimension(2*m) :: isuppz
    integer intent(in),depend(n) :: lwork=max(18*n,1)
    complex  intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: lrwork=24*n
    real intent(hide),dimension(lrwork) :: rwork
    integer intent(hide),depend(n):: liwork=10*n
    integer intent(hide),dimension(liwork) :: iwork
    integer  intent(out) :: info

end subroutine cheevr


subroutine zheevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Standard Eigenvalue Problem
    ! simple/expert driver: all eigenvectors or optionally selected eigenvalues
    ! algorithm: Relatively Robust Representation
    ! matrix storage
    ! Complex - Single precision
    character intent(in) :: jobz='V'
    character intent(in) :: range='A'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double complex intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double precision intent(hide) :: vl=0
    double precision intent(hide) :: vu=1
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    double precision intent(hide) :: abstol=0.
    integer  intent(hide),depend(iu) :: m=iu-il+1
    double precision intent(out),dimension(n),depend(n) :: w
    double complex intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(hide),dimension(2*m) :: isuppz
    integer intent(in),depend(n) :: lwork=max(18*n,1)
    double complex  intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: lrwork=24*n
    double precision intent(hide),dimension(lrwork) :: rwork
    integer intent(hide),depend(n):: liwork=10*n
    integer intent(hide),dimension(liwork) :: iwork
    integer  intent(out) :: info

end subroutine zheevr



subroutine ssygv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    real intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    real intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    real intent(out),dimension(n),depend(n) :: w
    integer intent(hide) :: lwork=max(3*n-1,1)
    real intent(hide),dimension(lwork) :: work
    integer intent(out) :: info

end subroutine ssygv


subroutine dsygv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double precision intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double precision intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(hide) :: lwork=max(3*n-1,1)
    double precision intent(hide),dimension(lwork) :: work
    integer intent(out) :: info

end subroutine dsygv



subroutine chegv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    complex intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    complex intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    real intent(out),dimension(n),depend(n) :: w
    integer intent(hide) :: lwork=max(18*n-1,1)
    complex intent(hide),dimension(lwork) :: work
    real intent(hide),dimension(3*n-2) :: rwork
    integer intent(out) :: info

end subroutine chegv


subroutine zhegv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double complex intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double complex intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(hide) :: lwork=max(18*n-1,1)
    double complex intent(hide),dimension(lwork) :: work
    double precision intent(hide),dimension(3*n-2) :: rwork
    integer intent(out) :: info

end subroutine zhegv



!
! Divide and conquer routines for generalized eigenvalue problem
!
subroutine ssygvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,iwork,liwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: divide and conquer
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    real intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    real intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    real intent(out),dimension(n),depend(n) :: w
    integer intent(in),depend(n) :: lwork=max(1+6*n+2*n*n,1)
    real intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: liwork=3+5*n
    integer intent(hide),dimension(liwork) :: iwork
    integer intent(out) :: info

end subroutine ssygvd

subroutine dsygvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,iwork,liwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: divide and conquer
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double precision intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double precision intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(in),depend(n) :: lwork=max(1+6*n+2*n*n,1)
    double precision intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: liwork=3+5*n
    integer intent(hide),dimension(liwork) :: iwork
    integer intent(out) :: info

end subroutine dsygvd



subroutine chegvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: divide and conquer
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    complex intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    complex intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    real intent(out),dimension(n),depend(n) :: w
    integer intent(in),depend(n) :: lwork=max(2*n+n*n,1)
    complex intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: lrwork=1+5*n+2*n*n
    real intent(hide),dimension(lrwork) :: rwork
    integer intent(hide),depend(n) :: liwork=3+5*n
    integer intent(hide),dimension(liwork) :: iwork
    integer intent(out) :: info

end subroutine chegvd


subroutine zhegvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: divide and conquer
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double complex intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double complex intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    double precision intent(out),dimension(n),depend(n) :: w
    integer intent(in),depend(n) :: lwork=max(2*n+n*n,1)
    double complex intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: lrwork=1+5*n+2*n*n
    double precision intent(hide),dimension(lrwork) :: rwork
    integer intent(hide),depend(n) :: liwork=3+5*n
    integer intent(hide),dimension(liwork) :: iwork
    integer intent(out) :: info

end subroutine zhegvd



!
! Expert routines for generalized eigenvalue problem
!
subroutine ssygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! Generalized Eigenvalue Problem
    ! expert driver (selected eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(hide) :: range='I'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    real intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    real intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    real intent(hide) :: vl=0.
    real intent(hide) :: vu=0.
    integer optional,intent(in) :: il=1
    integer intent(in) :: iu
    real intent(hide) :: abstol=0.
    integer intent(hide),depend(iu) :: m=iu-il+1
    real intent(out),dimension(n),depend(n) :: w
    real intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(in),depend(n) :: lwork=max(8*n,1)
    real intent(hide),dimension(lwork),depend(n,lwork) :: work
    integer intent(hide),dimension(5*n) :: iwork
    integer intent(out),dimension(n),depend(n) :: ifail
    integer intent(out) :: info

end subroutine ssygvx

subroutine dsygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! Generalized Eigenvalue Problem
    ! expert driver (selected eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(hide) :: range='I'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double precision intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double precision intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    double precision intent(hide) :: vl=0.
    double precision intent(hide) :: vu=0.
    integer optional,intent(in) :: il=1
    integer intent(in) :: iu
    double precision intent(hide) :: abstol=0.
    integer intent(hide),depend(iu) :: m=iu-il+1
    double precision intent(out),dimension(n),depend(n) :: w
    double precision intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(in),depend(n) :: lwork=max(8*n,1)
    double precision intent(hide),dimension(lwork),depend(n,lwork) :: work
    integer intent(hide),dimension(5*n) :: iwork
    integer intent(out),dimension(n),depend(n) :: ifail
    integer intent(out) :: info

end subroutine dsygvx



subroutine chegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! Generalized Eigenvalue Problem
    ! expert driver (selected eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(hide) :: range='I'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    complex intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    complex intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    real intent(hide) :: vl=0.
    real intent(hide) :: vu=0.
    integer optional,intent(in) :: il=1
    integer intent(in) :: iu
    real intent(hide) :: abstol=0.
    integer intent(hide),depend(iu) :: m=iu-il+1
    real intent(out),dimension(n),depend(n) :: w
    complex intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(in),depend(n) :: lwork=max(18*n-1,1)
    complex intent(hide),dimension(lwork),depend(n,lwork) :: work
    real intent(hide),dimension(7*n) :: rwork
    integer intent(hide),dimension(5*n) :: iwork
    integer intent(out),dimension(n),depend(n) :: ifail
    integer intent(out) :: info
end subroutine chegvx


subroutine zhegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! Generalized Eigenvalue Problem
    ! expert driver (selected eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(hide) :: range='I'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    double complex intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    double complex intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    double precision intent(hide) :: vl=0.
    double precision intent(hide) :: vu=0.
    integer optional,intent(in) :: il=1
    integer intent(in) :: iu
    double precision intent(hide) :: abstol=0.
    integer intent(hide),depend(iu) :: m=iu-il+1
    double precision intent(out),dimension(n),depend(n) :: w
    double complex intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(in),depend(n) :: lwork=max(18*n-1,1)
    double complex intent(hide),dimension(lwork),depend(n,lwork) :: work
    double precision intent(hide),dimension(7*n) :: rwork
    integer intent(hide),dimension(5*n) :: iwork
    integer intent(out),dimension(n),depend(n) :: ifail
    integer intent(out) :: info
end subroutine zhegvx


! Signatures for f2py-wrappers of FORTRAN LAPACK Positive Definite Matrix functions.
!


subroutine sposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,int*,int*,float*,int*,float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    real dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine sposv



subroutine dposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,int*,int*,double*,int*,double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    double precision dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine dposv



subroutine cposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,int*,int*,complex_float*,int*,complex_float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine cposv



subroutine zposv(n,nrhs,a,b,info,lower)
    ! c,x,info = posv(a,b,lower=0,overwrite_a=0,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&n,b,&n,&info)
    callprotoargument char*,int*,int*,complex_double*,int*,complex_double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),intent(in,out,copy,out=c) :: a
    check(shape(a,0)==shape(a,1)) :: a
    double complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(a,0)==shape(b,0)) :: b
    integer intent(out) :: info

end subroutine zposv



subroutine sposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,int*,int*,float*,int*,float*,int*,char*,float*,float*,int*,float*,int*,float*,float*,float*,float*,int*,int*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    real optional,dimension(n),depend(n),intent(in,out):: s
    real dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    real dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    real intent(hide),dimension(3*n),depend(n):: work
    integer intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine sposvx


subroutine dposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,int*,int*,double*,int*,double*,int*,char*,double*,double*,int*,double*,int*,double*,double*,double*,double*,int*,int*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    double precision optional,dimension(n),depend(n),intent(in,out):: s
    double precision dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double precision dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double precision intent(hide),dimension(3*n),depend(n):: work
    integer intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine dposvx


subroutine cposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,char*,float*,complex_float*,int*,complex_float*,int*,float*,float*,float*,complex_float*,float*,int*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    complex optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    real optional,dimension(n),depend(n),intent(in,out):: s
    complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    real intent(out):: rcond
    real intent(out),dimension(nrhs),depend(nrhs):: ferr
    real intent(out),dimension(nrhs),depend(nrhs):: berr
    complex intent(hide),dimension(2*n),depend(n):: work
    real intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine cposvx


subroutine zposvx(fact,n,nrhs,a,lda,af,ldaf,equed,s,b,ldb,x,ldx,rcond,ferr,berr,work,irwork,info,lower)
    ! Solve A * X = B for Symmetric/Hermitian A
    ! "expert" version of the ?POSV routines
    threadsafe
    callstatement (*f2py_func)(fact,(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,equed,s,b,&ldb,x,&ldx,&rcond,ferr,berr,work,irwork,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,char*,double*,complex_double*,int*,complex_double*,int*,double*,double*,double*,complex_double*,double*,int*
 
    character optional,intent(in):: fact = "E"
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double complex optional,intent(in,out,out=lu),dimension(n,n),depend(n):: af
    integer depend(af),intent(hide):: ldaf = shape(af,0)
    character optional,intent(in,out):: equed = "Y"
    double precision optional,dimension(n),depend(n),intent(in,out):: s
    double complex dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,copy,out,out=b_s):: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    double complex dimension(n,nrhs),depend(n,nrhs),intent(out):: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    double precision intent(out):: rcond
    double precision intent(out),dimension(nrhs),depend(nrhs):: ferr
    double precision intent(out),dimension(nrhs),depend(nrhs):: berr
    double complex intent(hide),dimension(2*n),depend(n):: work
    double precision intent(hide),dimension(n),depend(n):: irwork
    integer intent(out):: info
 
end subroutine zposvx



subroutine spocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,float*,int*,float*,float*,float*,int*,int*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    real depend(n),dimension(3*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine spocon


subroutine dpocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,double*,int*,double*,double*,double*,int*,int*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double precision depend(n),dimension(3*n),intent(hide,cache):: work
    integer depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine dpocon


subroutine cpocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,complex_float*,int*,float*,float*,complex_float*,float*,int*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    real intent(in):: anorm
    real intent(out):: rcond
    complex depend(n),dimension(2*n),intent(hide,cache):: work
    real depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine cpocon


subroutine zpocon(uplo,n,a,lda,anorm,rcond,work,irwork,info)
    ! Computes the 1- or inf- norm reciprocal condition number estimate
    ! for a positive definite symmetric/hermitian matrix.
    threadsafe
    callstatement (*f2py_func)(uplo,&n,a,&lda,&anorm,&rcond,work,irwork,&info)
    callprotoargument char*,int*,complex_double*,int*,double*,double*,complex_double*,double*,int*
 
    character optional,intent(in):: uplo = 'U'
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    double precision intent(in):: anorm
    double precision intent(out):: rcond
    double complex depend(n),dimension(2*n),intent(hide,cache):: work
    double precision depend(n),dimension(n),intent(hide,cache):: irwork
    integer intent(out):: info
 
end subroutine zpocon


 
subroutine spotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){int i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;}}
    callprotoargument char*,int*,float*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide) :: n = shape(a,0)
    real dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine spotrf

 
subroutine dpotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){int i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;}}
    callprotoargument char*,int*,double*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide) :: n = shape(a,0)
    double precision dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine dpotrf


 
subroutine cpotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){int i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}}}
    callprotoargument char*,int*,complex_float*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide):: n = shape(a,0)
    complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine cpotrf

 
subroutine zpotrf(n,a,lda,info,lower,clean)
    ! c,info = potrf(a,lower=0,clean=1,overwrite_a=0)
    ! Compute Cholesky decomposition of symmetric positive defined matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
    ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,&info); if(clean){int i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}}}
    callprotoargument char*,int*,complex_double*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(clean==0||clean==1) :: clean = 1
    integer depend(a),intent(hide):: n = shape(a,0)
    double complex dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    integer depend(n),intent(hide) :: lda = MAX(1,n)
    integer intent(out) :: info
 
end subroutine zpotrf


 
subroutine spotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,int*,int*,float*,int*,float*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    real dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    real dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine spotrs

 
subroutine dpotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,int*,int*,double*,int*,double*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double precision dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    double precision dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine dpotrs

 
subroutine cpotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,int*,int*,complex_float*,int*,complex_float*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    complex dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine cpotrs

 
subroutine zpotrs(n,nrhs,c,b,info,lower)
     ! x,info = potrs(c,b,lower=0=1,overwrite_b=0)
    ! Solve A * X = B.
    ! A is symmetric positive defined
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,c,&n,b,&n,&info)
    callprotoargument char*,int*,int*,complex_double*,int*,complex_double*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    double complex dimension(n,n),intent(in) :: c
    check(shape(c,0)==shape(c,1)) :: c
    double complex dimension(n,nrhs),intent(in,out,copy,out=x),depend(n):: b
    check(shape(c,0)==shape(b,0)) :: b
    integer intent(out) :: info
 
end subroutine zpotrs


 
subroutine spotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,float*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    real dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine spotri

 
subroutine dpotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,double*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    double precision dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine dpotri

 
subroutine cpotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,complex_float*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    complex dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine cpotri

 
subroutine zpotri(n,c,info,lower)
    ! inv_a,info = potri(c,lower=0,overwrite_c=0)
    ! Compute A inverse A^-1.
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,complex_double*,int*,int*
 
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
 
    integer depend(c),intent(hide):: n = shape(c,0)
    double complex dimension(n,n),intent(in,out,copy,out=inv_a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine zpotri


! Signatures for f2py-wrappers of FORTRAN LAPACK Positive Definite Tridiagonal Matrix functions.
!

subroutine sptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument int*, int*, float*, float*, float*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real dimension(n), intent(in,out,copy) :: d
    real dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    real dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine sptsv


subroutine dptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument int*, int*, double*, double*, double*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision dimension(n), intent(in,out,copy) :: d
    double precision dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    double precision dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine dptsv


subroutine cptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument int*, int*, float*, complex_float*, complex_float*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    real dimension(n), intent(in,out,copy) :: d
    complex dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine cptsv


subroutine zptsv(n, nrhs, d, e, b, info)
    callstatement (*f2py_func)(&n, &nrhs, d, e, b, &n, &info);
    callprotoargument int*, int*, double*, complex_double*, complex_double*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    double precision dimension(n), intent(in,out,copy) :: d
    double complex dimension(n-1), intent(in,out,copy,out=du), depend(n) :: e
    double complex dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine zptsv


! Signatures for f2py-wrappers of FORTRAN LAPACK Other Auxillary and Computational functions.
!

subroutine stgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alphar,alphai,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument int*,int*,int*,int*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,float*,int*,int*,float*,float*,float*,float*,int*,int*,int*,int*

    integer intent(hide) :: ijob=4
    integer intent(hide),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,1)
    real intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    real intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    real intent(out),dimension(n) :: alphar
    real intent(out),dimension(n) :: alphai
    real intent(out),dimension(n) :: beta
    real intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    real intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    integer intent(out) :: m
    real intent(out) :: pl
    real intent(out) :: pr
    real intent(out),dimension(2) :: dif
    real intent(out),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(m,n),check(lwork == -1 || lwork >= MAX(4*n+16,2*m*(n-m))) :: lwork=max(MAX(4*n+16,2*m*(n-m)),1)
    integer intent(out),dimension(MAX(1,liwork)) :: iwork
    integer optional,intent(in),depend(n),check(liwork == -1 || liwork >= n+6) :: liwork=n+6
    integer intent(out) :: info

end subroutine stgsen


subroutine dtgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alphar,alphai,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)

    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alphar,alphai,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument int*,int*,int*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,double*,int*,int*,double*,double*,double*,double*,int*,int*,int*,int*

    integer intent(hide) :: ijob=4
    integer intent(hide),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,1)
    double precision intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double precision intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double precision intent(out),dimension(n) :: alphar
    double precision intent(out),dimension(n) :: alphai
    double precision intent(out),dimension(n) :: beta
    double precision intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double precision intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    integer intent(out) :: m
    double precision intent(out) :: pl
    double precision intent(out) :: pr
    double precision intent(out),dimension(2) :: dif
    double precision intent(out),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(m,n),check(lwork == -1 || lwork >= MAX(4*n+16,2*m*(n-m))) :: lwork=max(MAX(4*n+16,2*m*(n-m)),1)
    integer intent(out),dimension(MAX(1,liwork)) :: iwork
    integer optional,intent(in),depend(n),check(liwork == -1 || liwork >= n+6) :: liwork=n+6
    integer intent(out) :: info

end subroutine dtgsen



subroutine ctgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alpha,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument int*,int*,int*,int*,int*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,complex_float*,int*,complex_float*,int*,int*,float*,float*,float*,complex_float*,int*,int*,int*,int*

    integer intent(hide) :: ijob=4
    integer intent(hide),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,1)
    complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    complex intent(out),dimension(n) :: alpha
    complex intent(out),dimension(n) :: beta
    complex intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    complex intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    integer intent(out) :: m
    real intent(out) :: pl
    real intent(out) :: pr
    real intent(out),dimension(2) :: dif
    complex intent(out),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(m,n),check(lwork == -1 || lwork >= 2*m*(n-m)) :: lwork=max(2*m*(n-m),1)
    integer intent(out),dimension(MAX(1,liwork)):: iwork
    integer optional,intent(in),depend(n),check(liwork == -1 || liwork>=n+2) :: liwork=n+2
    integer intent(out) :: info
end subroutine ctgsen


subroutine ztgsen(ijob,wantq,wantz,select,n,a,lda,b,ldb,alpha,beta,q,ldq,z,ldz,m,pl,pr,dif,work,lwork,iwork,liwork,info)
    callstatement (*f2py_func)(&ijob,&wantq,&wantz,select,&n,a,&lda,b,&ldb,alpha,beta,q,&ldq,z,&ldz,&m,&pl,&pr,dif,work,&lwork,iwork,&liwork,&info)
    callprotoargument int*,int*,int*,int*,int*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,complex_double*,int*,complex_double*,int*,int*,double*,double*,double*,complex_double*,int*,int*,int*,int*

    integer intent(hide) :: ijob=4
    integer intent(hide),check(wantq==0||wantq==1) :: wantq=1
    integer intent(hide),check(wantz==0||wantz==1) :: wantz=1
    logical intent(in),dimension(n) :: select
    integer intent(hide),depend(a) :: n=shape(a,1)
    double complex intent(in,out,copy),dimension(lda,n) :: a
    integer intent(hide),depend(a) :: lda=shape(a,0)
    double complex intent(in,out,copy),dimension(ldb,n) :: b
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    double complex intent(out),dimension(n) :: alpha
    double complex intent(out),dimension(n) :: beta
    double complex intent(in,out,copy),dimension(ldq,n) :: q
    integer intent(hide),depend(q) :: ldq=shape(q,0)
    double complex intent(in,out,copy),dimension(ldz,n) :: z
    integer intent(hide),depend(z) :: ldz=shape(z,0)
    integer intent(out) :: m
    double precision intent(out) :: pl
    double precision intent(out) :: pr
    double precision intent(out),dimension(2) :: dif
    double complex intent(out),dimension(MAX(lwork,1)) :: work
    integer optional,intent(in),depend(m,n),check(lwork == -1 || lwork >= 2*m*(n-m)) :: lwork=max(2*m*(n-m),1)
    integer intent(out),dimension(MAX(1,liwork)):: iwork
    integer optional,intent(in),depend(n),check(liwork == -1 || liwork>=n+2) :: liwork=n+2
    integer intent(out) :: info
end subroutine ztgsen



subroutine spbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,int*,int*,float*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine spbtrf


subroutine dpbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^T * U, C = U if lower = 0
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,int*,int*,double*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine dpbtrf



subroutine cpbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,int*,int*,complex_float*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine cpbtrf


subroutine zpbtrf(lower,n,kd,ab,ldab,info)
    ! Compute Cholesky decomposition of banded symmetric positive definite
    ! matrix:
    ! A = U^H * U, C = U if lower = 0
    ! A = L * L^H, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,ab,&ldab,&info);
    callprotoargument char*,int*,int*,complex_double*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine zpbtrf



subroutine spbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,float*,int*,float*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    real dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine spbtrs


subroutine dpbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,double*,int*,double*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double precision dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine dpbtrs



subroutine cpbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,complex_float*,int*,complex_float*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    complex dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine cpbtrs


subroutine zpbtrs(lower, n, kd, nrhs, ab, ldab, b, ldb, info)
    ! Solve a system of linear equations A*X = B with a symmetric
    ! positive definite band matrix A using the Cholesky factorization.
    ! AB is the triangular factur U or L from the Cholesky factorization
    ! previously computed with *PBTRF.
    ! A = U^T * U, AB = U if lower = 0
    ! A = L * L^T, AB = L if lower = 1

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,complex_double*,int*,complex_double*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double complex dimension(ldab,n),intent(in) :: ab
    integer intent(out) :: info

end subroutine zpbtrs



subroutine strtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,int*,int*,float*,int*,float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    real dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    real dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine strtrs


subroutine dtrtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,int*,int*,double*,int*,double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    double precision dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double precision dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine dtrtrs


subroutine ctrtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    complex dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine ctrtrs


subroutine ztrtrs(lower, trans, unitdiag, n, nrhs, a, lda, b, ldb, info)

    ! Solve a system of linear equations A*X = B with a triangular
    ! matrix A.

    callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(unitdiag?"U":"N"),&n,&nrhs,a,&lda,b,&ldb,&info);
    callprotoargument char*,char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0
    integer optional,check(shape(a,0)==lda),depend(a) :: lda=shape(a,0)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)

    double complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double complex dimension(lda,n),intent(in) :: a
    integer intent(out) :: info

end subroutine ztrtrs



subroutine spbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    !
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N symmetric positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**T * U,  if lower=1, or
    !     A = L * L**T,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,float*,int*,float*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    real dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    real dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine spbsv


subroutine dpbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    !
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N symmetric positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**T * U,  if lower=1, or
    !     A = L * L**T,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,double*,int*,double*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double precision dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double precision dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine dpbsv



subroutine cpbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N Hermitian positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**H * U,  if lower=1, or
    !     A = L * L**H,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,complex_float*,int*,complex_float*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine cpbsv


subroutine zpbsv(lower,n,kd,nrhs,ab,ldab,b,ldb,info)
    ! Computes the solution to a real system of linear equations
    ! A * X = B,
    !  where A is an N-by-N Hermitian positive definite band matrix and X
    !  and B are N-by-NRHS matrices.
    !
    !  The Cholesky decomposition is used to factor A as
    !     A = U**H * U,  if lower=1, or
    !     A = L * L**H,  if lower=0
    !  where U is an upper triangular band matrix, and L is a lower
    !  triangular band matrix, with the same number of superdiagonals or
    !  subdiagonals as A.  The factored form of A is then used to solve the
    !  system of equations A * X = B.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&kd,&nrhs,ab,&ldab,b,&ldb,&info);
    callprotoargument char*,int*,int*,int*,complex_double*,int*,complex_double*,int*,int*

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1
    integer intent(hide),depend(b) :: ldb=shape(b,0)
    integer intent(hide),depend(b) :: nrhs=shape(b,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    double complex dimension(ldb, nrhs),intent(in,out,copy,out=x) :: b
    double complex dimension(ldab,n),intent(in,out,copy,out=c) :: ab
    integer intent(out) :: info

end subroutine zpbsv



subroutine sorghr(n,lo,hi,a,tau,work,lwork,info)
    !
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,float*,int*,float*,float*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    real dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    real dimension(n-1),intent(in),depend(n) :: tau
    real dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine sorghr


subroutine dorghr(n,lo,hi,a,tau,work,lwork,info)
    !
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,double*,int*,double*,double*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double precision dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double precision dimension(n-1),intent(in),depend(n) :: tau
    double precision dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine dorghr



subroutine sorghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation ofr orghr
    fortranname sorghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,float*,int*,float*,float*,int*,int*
    integer intent(in) :: n
    real intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    real intent(hide) :: tau
    real intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine sorghr_lwork


subroutine dorghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation ofr orghr
    fortranname dorghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,double*,int*,double*,double*,int*,int*
    integer intent(in) :: n
    double precision intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    double precision intent(hide) :: tau
    double precision intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine dorghr_lwork



subroutine cunghr(n,lo,hi,a,tau,work,lwork,info)
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    complex dimension(n-1),intent(in),depend(n) :: tau
    complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine cunghr


subroutine zunghr(n,lo,hi,a,tau,work,lwork,info)
    ! q,info = orghr(a,tau,lo=0,hi=n-1,lwork=n,overwrite_a=0)
    ! Compute orthogonal matrix Q for Hessenberg reduction from the matrix
    ! that was computed by gehrd
    !
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,a,&n,tau,work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*
    integer intent(hide),depend(a) :: n = shape(a,0)
    double complex dimension(n,n),intent(in,out,copy,out=ht,aligned8),check(shape(a,0)==shape(a,1)) :: a
    integer intent(in),optional :: lo = 0
    integer intent(in),optional,depend(n) :: hi = n-1
    double complex dimension(n-1),intent(in),depend(n) :: tau
    double complex dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(in),optional,depend(n),check(lwork>=hi-lo) :: lwork = max(hi-lo,1)
    integer intent(out) :: info

end subroutine zunghr



subroutine cunghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for orghr
    fortranname cunghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*
    integer intent(in) :: n
    complex intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    complex intent(hide) :: tau
    complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine cunghr_lwork


subroutine zunghr_lwork(n,lo,hi,a,tau,work,lwork,info)
    ! LWORK computation for orghr
    fortranname zunghr
    callstatement { hi++; lo++; (*f2py_func)(&n,&lo,&hi,&a,&n,&tau,&work,&lwork,&info); }
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*
    integer intent(in) :: n
    double complex intent(hide) :: a
    integer intent(in), optional :: lo = 0
    integer intent(in), optional, depend(n) :: hi = n-1
    double complex intent(hide) :: tau
    double complex intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine zunghr_lwork



subroutine sorgqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    real dimension(m,n),intent(in,out,copy,out=q) :: a
    real dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sorgqr


subroutine dorgqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double precision dimension(m,n),intent(in,out,copy,out=q) :: a
    double precision dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dorgqr



subroutine cungqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    complex dimension(m,n),intent(in,out,copy,out=q) :: a
    complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cungqr


subroutine zungqr(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungqr(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double complex dimension(m,n),intent(in,out,copy,out=q) :: a
    double complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1) :: lwork=max(3*n,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zungqr



subroutine sormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = ormqr(side,trans,a,tau,c,lwork)
    ! multiplies the real matrix C with the real orthogonal matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,float*,int*,float*,float*,int*,float*,int*,int*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='T'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    real dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    real dimension(k),intent(in):: tau
    real dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    real dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine sormqr


subroutine dormqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = ormqr(side,trans,a,tau,c,lwork)
    ! multiplies the real matrix C with the real orthogonal matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,double*,int*,double*,double*,int*,double*,int*,int*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='T'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    double precision dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    double precision dimension(k),intent(in):: tau
    double precision dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    double precision dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine dormqr



subroutine cunmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = unmqr(side,trans,a,tau,c,lwork)
    ! multiplies the complex matrix C with the complex unitary matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,complex_float*,int*,int*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='C'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    complex dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    complex dimension(k),intent(in):: tau
    complex dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    complex dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine cunmqr


subroutine zunmqr(side,trans,m,n,k,a,lda,tau,c,ldc,work,lwork,info)
    ! cq,work,info = unmqr(side,trans,a,tau,c,lwork)
    ! multiplies the complex matrix C with the complex unitary matrix Q,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of geqrf)

    threadsafe
    callstatement (*f2py_func)(side,trans,&m,&n,&k,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,complex_double*,int*,int*

    character intent(in),check(*side=='L'||*side=='R'):: side
    character intent(in),check(*trans=='N'||*trans=='C'):: trans
    integer intent(hide),depend(c):: m = shape(c,0)
    integer intent(hide),depend(c):: n = shape(c,1)
    integer intent(hide),depend(a):: k = shape(a,1)
    double complex dimension(lda,k),intent(in):: a
    integer intent(hide),depend(a):: lda = shape(a, 0)
    double complex dimension(k),intent(in):: tau
    double complex dimension(ldc,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = shape(c, 0)
    double complex dimension(MAX(lwork,1)),intent(out):: work
    integer intent(in):: lwork
    integer intent(out) :: info

end subroutine zunmqr



subroutine sormrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,float*,int*,float*,float*,int*,float*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    real dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    real dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    real dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    real dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine sormrz


subroutine dormrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,double*,int*,double*,double*,int*,double*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    double precision dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double precision dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    double precision dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    double precision dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine dormrz


subroutine cunmrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,complex_float*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    complex dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    complex dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    complex dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    complex dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine cunmrz


subroutine zunmrz(side,trans,m,n,k,l,a,lda,nt,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,a,&lda,tau,c,&ldc,work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,complex_double*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(hide),depend(c),check(m>=0):: m=shape(c,0)
    integer intent(hide),depend(c),check(n>=0):: n=shape(c,1)
    integer intent(hide),depend(a):: k=shape(a,0)
    integer intent(hide),depend(a):: l=shape(a,1)-shape(a,0)
    double complex dimension(k,nt),intent(in),check(shape(a,1)>=shape(a,0)):: a
    integer intent(hide),depend(a,side,n,m),check((*side=='L'?m:n)==nt):: nt=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double complex dimension(k),depend(k),check(rank(tau)==1),intent(in):: tau
    double complex dimension(m,n),intent(in,out,copy,out=cq):: c
    integer intent(hide),depend(c):: ldc = MAX(shape(c,0),1)
    double complex dimension(lwork),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(side,m,n),check(lwork>=(*side=='L'?n:m)||lwork==-1):: lwork=MAX((side[0]=='L'?n:m),1)
    integer intent(out):: info

end subroutine zunmrz



subroutine sormrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname sormrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,float*,int*,float*,float*,int*,float*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    real intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    real intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    real intent(hide):: tau
    real intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info
    
end subroutine sormrz_lwork


subroutine dormrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname dormrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,double*,int*,double*,double*,int*,double*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    double precision intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    double precision intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    double precision intent(hide):: tau
    double precision intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info
    
end subroutine dormrz_lwork


subroutine cunmrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname cunmrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,complex_float*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    complex intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    complex intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    complex intent(hide):: tau
    complex intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info
    
end subroutine cunmrz_lwork


subroutine zunmrz_lwork(side,trans,m,n,k,l,a,lda,tau,c,ldc,work,lwork,info)
    !
    ! ?OR/UNMRZ overwrites the general complex M-by-N matrix C with
    !
    !                 SIDE = 'L'     SIDE = 'R'
    ! TRANS = 'N':      Q * C          C * Q
    ! TRANS = 'C':      Q**H * C       C * Q**H
    !
    ! where Q is a complex unitary matrix defined as the product of k
    ! elementary reflectors
    !
    !       Q = H(1) H(2) . . . H(k)
    !
    ! as returned by ?TZRZF. Q is of order M if SIDE = 'L' and of order N
    ! if SIDE = 'R'.
    !
    fortranname zunmrz
    callstatement (*f2py_func)(side,trans,&m,&n,&k,&l,&a,&lda,&tau,&c,&ldc,&work,&lwork,&info)
    callprotoargument char*,char*,int*,int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,complex_double*,int*,int*
    
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(side,m,n):: k=(*side=='L'?m:n)
    integer intent(hide):: l
    double complex intent(hide):: a
    integer intent(hide),depend(k):: lda=k
    double complex intent(hide):: c
    integer intent(hide),depend(m):: ldc=m
    double complex intent(hide):: tau
    double complex intent(out):: work
    integer intent(hide):: lwork=-1
    integer intent(out):: info
    
end subroutine zunmrz_lwork



subroutine sorgrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    real dimension(m,n),intent(in,out,copy,out=q) :: a
    real dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    real dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine sorgrq


subroutine dorgrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = orgrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N real matrix Q with orthonormal columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double precision dimension(m,n),intent(in,out,copy,out=q) :: a
    double precision dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double precision dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine dorgrq



subroutine cungrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    complex dimension(m,n),intent(in,out,copy,out=q) :: a
    complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine cungrq


subroutine zungrq(m,n,k,a,tau,work,lwork,info)
    ! q,work,info = ungrq(a,lwork=3*n,overwrite_a=0)
    ! Generates an M-by-N complex matrix Q with unitary columns,
    ! which is defined as the first N columns of a product of K elementary
    ! reflectors of order M (e.g. output of gerqf)

    threadsafe
    callstatement (*f2py_func)(&m,&n,&k,a,&m,tau,work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*

    integer intent(hide),depend(a):: m = shape(a,0)
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(tau):: k = shape(tau,0)
    double complex dimension(m,n),intent(in,out,copy,out=q) :: a
    double complex dimension(k),intent(in) :: tau

    integer optional,intent(in),depend(m),check(lwork>=m||lwork==-1) :: lwork=max(3*m,1)
    double complex dimension(MAX(lwork,1)),intent(out),depend(lwork) :: work
    integer intent(out) :: info

end subroutine zungrq



subroutine strtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,int*,float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    real dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine strtri


subroutine dtrtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,int*,double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double precision dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine dtrtri


subroutine ctrtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    complex dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine ctrtri


subroutine ztrtri(n,c,info,lower,unitdiag)

    ! inv_c,info = trtri(c,lower=0,unitdiag=1,overwrite_c=0)
    ! Compute C inverse C^-1 where
    ! C = U if lower = 0
    ! C = L if lower = 1
    ! C is non-unit triangular matrix if unitdiag = 0
    ! C is unit triangular matrix if unitdiag = 1

    callstatement (*f2py_func)((lower?"L":"U"),(unitdiag?"U":"N"),&n,c,&n,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(unitdiag==0||unitdiag==1) :: unitdiag = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double complex dimension(n,n),intent(in,out,copy,out=inv_c) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine ztrtri



subroutine strsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,int*,int*,int*,float*,int*,float*,int*,float*,int*,float*,int*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    real dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    real dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    real dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    real intent(out) :: scale

    integer intent(out) :: info

end subroutine strsyl


subroutine dtrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,int*,int*,int*,double*,int*,double*,int*,double*,int*,double*,int*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    double precision dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    double precision dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    double precision dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    double precision intent(out) :: scale

    integer intent(out) :: info

end subroutine dtrsyl


subroutine ctrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,int*,int*,int*,complex_float*,int*,complex_float*,int*,complex_float*,int*,float*,int*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    complex dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    complex dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    complex dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    real intent(out) :: scale

    integer intent(out) :: info

end subroutine ctrsyl


subroutine ztrsyl(trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, info)
    ! x,scale,info = trsyl(trana='N', tranb='N', isgn, a, b, c)
    !
    ! Solves the real Sylvester matrix equation:
    !
    !    op(A)*X + X*op(B) = scale*C or op(A)*X - X*op(B) = scale*C
    !
    ! where A and B are both quasi-triangular matrices.  A and B must be in
    ! Schur canonical form.  op(A) and op(B) are specified via trana and tranb
    ! respectively, and may take the forms 'N' (no transpose), 'T' (transpose),
    ! or 'C' (conjugate transpose, where applicable) to indicate the operation
    ! to be performed.  The value of isgn (1 or -1) specifies the sign of the
    ! X*op(B) term in the equation.
    !
    ! Upon exit, x contains the solution, scale represnets scale factor, set
    ! <= 1 to avoid overflow in the solution, and info contains the exit
    ! status:
    !
    !      0: success
    !      < 0: if info = -i, the i-th argument had an illegal value
    !      1: A and B have common or very close eigenvalues; perturbed values
    !         were used to solve the equation

    callstatement (*f2py_func)(trana,tranb,&isgn,&m,&n,a,&lda,b,&ldb,c,&ldc,&scale,&info)
    callprotoargument char*,char*,int*,int*,int*,complex_double*,int*,complex_double*,int*,complex_double*,int*,double*,int*

    character optional,intent(in),check(*trana=='N'||*trana=='T'||*trana=='C'):: trana='N'
    character optional,intent(in),check(*tranb=='N'||*tranb=='T'||*tranb=='C'):: tranb='N'

    integer optional,intent(in),check(isgn==1||isgn==-1)::isgn=1

    integer depend(a),intent(hide):: m = shape(a,0)
    integer depend(b),intent(hide):: n = shape(b,0)

    double complex dimension(m,m),intent(in) :: a
    check(shape(a,0)==shape(a,1)) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)

    double complex dimension(n,n),intent(in) :: b
    check(shape(b,0)==shape(b,1)) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)

    double complex dimension(m,n),intent(in,out,copy,out=x) :: c
    integer depend(c),intent(hide):: ldc = shape(c,0)

    double precision intent(out) :: scale

    integer intent(out) :: info

end subroutine ztrsyl



subroutine chbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! in :Band:zubevd.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,int*,float*,complex_float*,int*,complex_float*,int*,float*,int*,int*,int*,int*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    complex dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    ! case n=0 is omitted in calculaton of lwork, lrwork, liwork
    ! so we forbid it
    check( n>0 ) n
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    real dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    complex dimension(ldz,ldz),intent(out),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?2*n*n:n),1)
    complex dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional, check(lrwork>=(compute_v?1+5*n+2*n*n:n)),depend(n) :: lrwork=(compute_v?1+5*n+2*n*n:n)

    real intent(hide),dimension(lrwork),depend(lrwork) :: rwork

    ! documentation says liwork >=2+5*n, but that crashes, +1 helps
    integer optional, check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine chbevd


subroutine zhbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! in :Band:zubevd.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,int*,double*,complex_double*,int*,complex_double*,int*,double*,int*,int*,int*,int*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double complex dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    ! case n=0 is omitted in calculaton of lwork, lrwork, liwork
    ! so we forbid it
    check( n>0 ) n
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    double precision dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double complex dimension(ldz,ldz),intent(out),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?2*n*n:n),1)
    double complex dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional, check(lrwork>=(compute_v?1+5*n+2*n*n:n)),depend(n) :: lrwork=(compute_v?1+5*n+2*n*n:n)

    double precision intent(hide),dimension(lrwork),depend(lrwork) :: rwork

    ! documentation says liwork >=2+5*n, but that crashes, +1 helps
    integer optional, check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine zhbevd



subroutine chbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,rwork,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,rwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,int*,int*,complex_float*,int*,complex_float*,int*,float*,float*,int*,int*,float*,int*,float*,complex_float*,int*,complex_float*,float*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    complex dimension(ldab,n),intent(in, overwrite) :: ab

    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    complex dimension(ldq,ldq),intent(hide),depend(ldq) :: q

    real :: vl
    real :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    real optional,intent(in):: abstol=0.0

    real dimension(n),intent(out),depend(n) :: w

    complex dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    complex dimension(n),depend(n),intent(hide) :: work
    real dimension(7*n),depend(n),intent(hide) :: rwork
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine chbevx


subroutine zhbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,rwork,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,rwork,iwork,ifail,&info)
    callprotoargument char*,char*,char*,int*,int*,complex_double*,int*,complex_double*,int*,double*,double*,int*,int*,double*,int*,double*,complex_double*,int*,complex_double*,double*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double complex dimension(ldab,n),intent(in, overwrite) :: ab

    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    double complex dimension(ldq,ldq),intent(hide),depend(ldq) :: q

    double precision :: vl
    double precision :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    double precision optional,intent(in):: abstol=0.0

    double precision dimension(n),intent(out),depend(n) :: w

    double complex dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    double complex dimension(n),depend(n),intent(hide) :: work
    double precision dimension(7*n),depend(n),intent(hide) :: rwork
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine zhbevx



subroutine sgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,int*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    real dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    real dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    real dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    real dimension(p),depend(p),intent(in,copy) :: d
    real dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    real intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine sgglse


subroutine dgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,int*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    double precision dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    double precision dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    double precision dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    double precision dimension(p),depend(p),intent(in,copy) :: d
    double precision dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    double precision intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine dgglse


subroutine cgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,complex_float*,complex_float*,int*,int*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    complex dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    complex dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    complex dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    complex dimension(p),depend(p),intent(in,copy) :: d
    complex dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    complex intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine cgglse


subroutine zgglse(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    ! Solves the linear equality-constrained least squares (LSE)
    ! problem:
    !
    !         minimize || c - A*x ||_2   subject to   B*x = d
    !
    ! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
    ! M-vector, and d is a given P-vector. It is assumed that
    ! P <= N <= M+P, and
    !
    !          rank(B) = P and  rank( (A) ) = N.
    !                               ( (B) )
    !
    ! These conditions ensure that the LSE problem has a unique solution,
    ! which is obtained using a generalized RQ factorization of the
    ! matrices (B, A) given by
    !
    !    B = (0 R)*Q,   A = Z*T*Q.

    callstatement (*f2py_func)(&m,&n,&p,a,&lda,b,&ldb,c,d,x,work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,complex_double*,complex_double*,int*,int*

    integer intent(hide),depend(a),check(m>=0) :: m = shape(a,0)
    integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
    integer intent(out) :: info

    double complex dimension(m,n),intent(in,out,copy,out=t) :: a
    integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
    double complex dimension(p,n),depend(n),intent(in,out,copy,out=r) :: b
    integer intent(hide),depend(b) :: ldb = MAX(shape(b,0),1)
    integer intent(hide),depend(b,m,n),check((p>=n-m)&&(p>=0)) :: p = shape(b,0)

    double complex dimension(m),depend(m),intent(in,out,copy,out=res) :: c
    double complex dimension(p),depend(p),intent(in,copy) :: d
    double complex dimension(n),depend(n),intent(out) :: x

    integer optional,intent(in),depend(p,m,n),check((lwork==-1)||(lwork>=1)) :: lwork = max(m+n+p,1)
    double complex intent(hide),dimension(lwork),depend(lwork) :: work

end subroutine zgglse




subroutine sgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname sgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument int*,int*,int*,float*,int*,float*,int*,float*,float*,float*,float*,int*,int*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    real intent(out) :: work

    real intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    real intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    real intent(hide) :: c
    real intent(hide) :: d
    real intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine sgglse_lwork



subroutine dgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname dgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument int*,int*,int*,double*,int*,double*,int*,double*,double*,double*,double*,int*,int*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    double precision intent(out) :: work

    double precision intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    double precision intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    double precision intent(hide) :: c
    double precision intent(hide) :: d
    double precision intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine dgglse_lwork



subroutine cgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname cgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,complex_float*,complex_float*,int*,int*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    complex intent(out) :: work

    complex intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    complex intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    complex intent(hide) :: c
    complex intent(hide) :: d
    complex intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine cgglse_lwork



subroutine zgglse_lwork(m,n,p,a,lda,b,ldb,c,d,x,work,lwork,info)
    !
    ! lwork routine for ?gglse
    !
    fortranname zgglse
    callstatement (*f2py_func)(&m,&n,&p,&a,&lda,&b,&ldb,&c,&d,&x,&work,&lwork,&info)
    callprotoargument int*,int*,int*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,complex_double*,complex_double*,int*,int*

    integer intent(in),check(m>=0) :: m
    integer intent(in),check(n>=0) :: n
    integer intent(in),depend(m,n),check((p>=n-m)&&(p>=0)&&p<=n) :: p
    integer intent(out) :: info
    double complex intent(out) :: work

    double complex intent(hide) :: a
    integer intent(hide),depend(m) :: lda = max(1,m)
    double complex intent(hide) :: b
    integer intent(hide),depend(p) :: ldb = max(1,p)
    double complex intent(hide) :: c
    double complex intent(hide) :: d
    double complex intent(hide) :: x
    integer intent(hide) :: lwork = -1

end subroutine zgglse_lwork



subroutine ssbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info)
    ! in :Band:dsbev.f
    ! principally ssbevd does the same, and are recommended for use.
    ! (see man dsbevd)

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&info)

    callprotoargument char*,char*,int*,int*,float*,int*,float*,float*,int*,float*,int*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    real dimension(ldab,n), intent(in,overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    real dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    real dimension(ldz,ldz),intent(out),depend(ldz) :: z

    real dimension(MAX(1,3*n-1)),intent(hide),depend(n) :: work
    integer intent(out)::info

end subroutine ssbev


subroutine dsbev(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,info)
    ! in :Band:dsbev.f
    ! principally dsbevd does the same, and are recommended for use.
    ! (see man dsbevd)

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&info)

    callprotoargument char*,char*,int*,int*,double*,int*,double*,double*,int*,double*,int*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double precision dimension(ldab,n), intent(in,overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    double precision dimension(n),intent(out),depend(n) :: w

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double precision dimension(ldz,ldz),intent(out),depend(ldz) :: z

    double precision dimension(MAX(1,3*n-1)),intent(hide),depend(n) :: work
    integer intent(out)::info

end subroutine dsbev



subroutine ssbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,liwork,info)
    ! in :Band:dsbevd.f
    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,int*,float*,int*,float*,float*,int*,float*,int*,int*,int*,int*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    real dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    real dimension(n),intent(out),depend(n) :: w
    real dimension(ldz,ldz),intent(out),depend(ldz) :: z

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    real dimension(ldz,ldz),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?1+5*n+2*n*n:2*n),1)
    real dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional,check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine ssbevd


subroutine dsbevd(ab,compute_v,lower,n,ldab,kd,w,z,ldz,work,lwork,iwork,liwork,info)
    ! in :Band:dsbevd.f
    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,&kd,ab,&ldab,w,z,&ldz,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,int*,double*,int*,double*,double*,int*,double*,int*,int*,int*,int*

    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double precision dimension(ldab,n), intent(in, overwrite) :: ab

    integer optional,intent(in):: compute_v = 1
    check( compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    double precision dimension(n),intent(out),depend(n) :: w
    double precision dimension(ldz,ldz),intent(out),depend(ldz) :: z

    ! For compute_v=1 z is used and contains the eigenvectors
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double precision dimension(ldz,ldz),depend(ldz) :: z

    integer intent(hide),depend(n) :: lwork=max((compute_v?1+5*n+2*n*n:2*n),1)
    double precision dimension(lwork),intent(hide),depend(lwork) :: work
    integer intent(out)::info

    integer optional,check(liwork>=(compute_v?3+5*n:1)),depend(n) :: liwork=(compute_v?3+5*n:1)
    integer intent(hide),dimension(liwork),depend(liwork) :: iwork

end subroutine dsbevd



subroutine ssbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,iwork,ifail,&info)
    callprotoargument char*,char*,char*,int*,int*,float*,int*,float*,int*,float*,float*,int*,int*,float*,int*,float*,float*,int*,float*, int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range


    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    real dimension(ldab,n),intent(in, overwrite) :: ab


    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    real dimension(ldq,ldq),intent(hide),depend(ldq) :: q


    real :: vl
    real :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    real optional,intent(in):: abstol=0.0

    real dimension(n),intent(out),depend(n) :: w

    real dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    real dimension(7*n),depend(n),intent(hide) :: work
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine ssbevx


subroutine dsbevx(ab,ldab,compute_v,range,lower,n,kd,q,ldq,vl,vu,il,iu,abstol,w,z,m,mmax,ldz,work,iwork,ifail,info) ! in :Band:dsbevx.f

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),(lower?"L":"U"),&n,&kd,ab,&ldab,q,&ldq,&vl,&vu,&il,&iu,&abstol,&m,w,z,&ldz,work,iwork,ifail,&info)
    callprotoargument char*,char*,char*,int*,int*,double*,int*,double*,int*,double*,double*,int*,int*,double*,int*,double*,double*,int*,double*, int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer optional,check(shape(ab,0)==ldab),depend(ab) :: ldab=shape(ab,0)
    integer intent(hide),depend(ab) :: n=shape(ab,1)
    integer intent(hide),depend(ab) :: kd=shape(ab,0)-1

    integer optional,intent(in):: range = 0
    check(range==2||range==1||range==0) range


    ! Remark: if ab is fortran contigous on input
    !         and overwrite_ab=1  ab will be overwritten.
    double precision dimension(ldab,n),intent(in, overwrite) :: ab


    ! FIXME: do we need to make q available for outside usage ???
    !        If so: how to make this optional
    !*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)
    !*          If JOBZ = 'V', the N-by-N orthogonal matrix used in the
    !*                         reduction to tridiagonal form.
    !*          If JOBZ = 'N', the array Q is not referenced.
    integer intent(hide),depend(n,compute_v) :: ldq=(compute_v?n:1)
    double precision dimension(ldq,ldq),intent(hide),depend(ldq) :: q


    double precision :: vl
    double precision :: vu
    integer,check((il>=1 && il<=n)),depend(n) :: il
    integer,check((iu>=1 && iu<=n && iu>=il)),depend(n,il) :: iu

    ! Remark, we don't use python indexing here, because
    !  if someone uses ?sbevx directly,
    !  he should expect Fortran style indexing.
    !integer,check((il>=0 && il<n)),depend(n) :: il+1
    !integer,check((iu>=0 && iu<n && iu>=il)),depend(n,il) :: iu+1

    ! Remark:
    ! Eigenvalues will be computed most accurately when ABSTOL is
    ! set to twice the underflow threshold 2*DLAMCH('S'), not zero.
    !
    ! The easiest is to wrap DLAMCH (done below)
    ! and let the user provide the value.
    double precision optional,intent(in):: abstol=0.0

    double precision dimension(n),intent(out),depend(n) :: w

    double precision dimension(ldz,mmax),depend(ldz,mmax),intent(out) :: z
    integer intent(hide),depend(n,compute_v) :: ldz=(compute_v?n:1)

    ! We use the mmax parameter to fix the size of z
    ! (only if eigenvalues are requested)
    ! Otherwise we would allocate a (possibly) huge
    ! region of memory for the eigenvectors, even
    ! in cases where only a few are requested.
    ! If RANGE = 'V' (range=1) we a priori don't know the
    ! number of eigenvalues in the interval in advance.
    ! As default we use the maximum value
    ! but the user should use an appropriate mmax.
    integer intent(in),depend(n,iu,il,compute_v,range) :: mmax=(compute_v?(range==2?(iu-il+1):n):1)
    integer intent(out) :: m

    double precision dimension(7*n),depend(n),intent(hide) :: work
    integer dimension(5*n),depend(n),intent(hide) :: iwork
    integer dimension((compute_v?n:1)),depend(n,compute_v),intent(out) :: ifail
    integer intent(out):: info

end subroutine dsbevx



subroutine sstebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,w,iblock,isplit,info)
    ! computes all or selected eigenvalues of a real, symmetric tridiagonal
    ! matrix.

    callstatement (*f2py_func)((range>0?(range==1?"V":"I"):"A"),order,&n,&vl,&vu,&il,&iu,&tol,d,e,&m,&nsplit,w,iblock,isplit,work,iwork,&info)
    callprotoargument char*,char*,int*,float*,float*,int*,int*,float*,float*,float*,int*,int*,float*,int*,int*,float*,int*,int*

    real dimension(n),intent(in) :: d
    real dimension(n-1),depend(n),intent(in) :: e
    real intent(in) :: vl
    real intent(in) :: vu
    character intent(in) :: order
    integer intent(in) :: il
    integer intent(in) :: iu
    real intent(in) :: tol
    integer intent(in) :: range
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    real dimension(4*n),depend(n),intent(hide) :: work
    integer dimension(3*n),depend(n),intent(hide) :: iwork
    integer intent(out) :: m
    integer intent(hide) :: nsplit
    real dimension(n),depend(n),intent(out) :: w
    integer dimension(n),depend(n),intent(out) :: iblock
    integer dimension(n),depend(n),intent(out) :: isplit
    integer intent(out) :: info

end subroutine sstebz


subroutine dstebz(d,e,range,vl,vu,il,iu,tol,order,n,work,iwork,m,nsplit,w,iblock,isplit,info)
    ! computes all or selected eigenvalues of a real, symmetric tridiagonal
    ! matrix.

    callstatement (*f2py_func)((range>0?(range==1?"V":"I"):"A"),order,&n,&vl,&vu,&il,&iu,&tol,d,e,&m,&nsplit,w,iblock,isplit,work,iwork,&info)
    callprotoargument char*,char*,int*,double*,double*,int*,int*,double*,double*,double*,int*,int*,double*,int*,int*,double*,int*,int*

    double precision dimension(n),intent(in) :: d
    double precision dimension(n-1),depend(n),intent(in) :: e
    double precision intent(in) :: vl
    double precision intent(in) :: vu
    character intent(in) :: order
    integer intent(in) :: il
    integer intent(in) :: iu
    double precision intent(in) :: tol
    integer intent(in) :: range
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    double precision dimension(4*n),depend(n),intent(hide) :: work
    integer dimension(3*n),depend(n),intent(hide) :: iwork
    integer intent(out) :: m
    integer intent(hide) :: nsplit
    double precision dimension(n),depend(n),intent(out) :: w
    integer dimension(n),depend(n),intent(out) :: iblock
    integer dimension(n),depend(n),intent(out) :: isplit
    integer intent(out) :: info

end subroutine dstebz



subroutine ssterf(d,e,n,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&info)
    callprotoargument int*,float*,float*,int*

    real dimension(n),intent(in,out,copy,out=vals) :: d
    real dimension(n-1),depend(n),intent(in,copy) :: e
    integer depend(d),intent(hide) :: n = shape(d,0)
    integer intent(out) :: info

end subroutine ssterf


subroutine dsterf(d,e,n,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&info)
    callprotoargument int*,double*,double*,int*

    double precision dimension(n),intent(in,out,copy,out=vals) :: d
    double precision dimension(n-1),depend(n),intent(in,copy) :: e
    integer depend(d),intent(hide) :: n = shape(d,0)
    integer intent(out) :: info

end subroutine dsterf



subroutine sstein(d,e,w,iblock,isplit,m,n,z,ldz,work,iwork,ifail,info)
    ! computes eigenvectors corresponding to eigenvalues of a real, symmetric
    ! tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&m,w,iblock,isplit,z,&ldz,work,iwork,ifail,&info)
    callprotoargument int*,float*,float*,int*,float*,int*,int*,float*,int*,float*,int*,int*,int*

    real dimension(n),intent(in) :: d
    real dimension(n-1),depend(n),intent(in) :: e
    real dimension(m),intent(in) :: w
    integer depend(w),intent(hide) :: m = shape(w,0)
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    integer dimension(n),depend(n),intent(in) :: iblock
    integer dimension(n),depend(n),intent(in) :: isplit
    real dimension(ldz,m),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = n
    real dimension(5*n),intent(hide) :: work
    integer dimension(n),intent(hide) :: iwork
    integer dimension(m),depend(m),intent(hide) :: ifail
    integer intent(out) :: info

end subroutine sstein


subroutine dstein(d,e,w,iblock,isplit,m,n,z,ldz,work,iwork,ifail,info)
    ! computes eigenvectors corresponding to eigenvalues of a real, symmetric
    ! tridiagonal matrix.

    callstatement (*f2py_func)(&n,d,e,&m,w,iblock,isplit,z,&ldz,work,iwork,ifail,&info)
    callprotoargument int*,double*,double*,int*,double*,int*,int*,double*,int*,double*,int*,int*,int*

    double precision dimension(n),intent(in) :: d
    double precision dimension(n-1),depend(n),intent(in) :: e
    double precision dimension(m),intent(in) :: w
    integer depend(w),intent(hide) :: m = shape(w,0)
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    integer dimension(n),depend(n),intent(in) :: iblock
    integer dimension(n),depend(n),intent(in) :: isplit
    double precision dimension(ldz,m),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = n
    double precision dimension(5*n),intent(hide) :: work
    integer dimension(n),intent(hide) :: iwork
    integer dimension(m),depend(m),intent(hide) :: ifail
    integer intent(out) :: info

end subroutine dstein



subroutine sstemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,float*,float*,float*,float*,int*,int*,int*,float*,float*,int*,int*,int*,int*,float*,int*,int*,int*,int*

    real dimension(n),intent(in,copy) :: d
    real dimension(n),intent(in) :: e
    integer intent(in) :: range
    real intent(in) :: vl
    real intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(out) :: m
    real dimension(n),depend(n),intent(out) :: w
    real dimension(n,n),depend(n),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),optional,intent(in),check(lwork>=(compute_v?18*n:12*n)) :: lwork = max((compute_v?18*n:12*n),1)
    real dimension(lwork),depend(lwork),intent(hide) :: work
    integer depend(n),optional,intent(in),check(liwork>=(compute_v?10*n:8*n)) :: liwork = (compute_v?10*n:8*n)
    integer dimension(liwork),depend(liwork),intent(hide) :: iwork
    integer intent(out) :: info

end subroutine sstemr


subroutine dstemr(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! computes all eigenvalues of a real, symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,double*,double*,double*,double*,int*,int*,int*,double*,double*,int*,int*,int*,int*,double*,int*,int*,int*,int*

    double precision dimension(n),intent(in,copy) :: d
    double precision dimension(n),intent(in) :: e
    integer intent(in) :: range
    double precision intent(in) :: vl
    double precision intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(out) :: m
    double precision dimension(n),depend(n),intent(out) :: w
    double precision dimension(n,n),depend(n),intent(out) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),optional,intent(in),check(lwork>=(compute_v?18*n:12*n)) :: lwork = max((compute_v?18*n:12*n),1)
    double precision dimension(lwork),depend(lwork),intent(hide) :: work
    integer depend(n),optional,intent(in),check(liwork>=(compute_v?10*n:8*n)) :: liwork = (compute_v?10*n:8*n)
    integer dimension(liwork),depend(liwork),intent(hide) :: iwork
    integer intent(out) :: info

end subroutine dstemr



subroutine sstemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! LWORK=-1, LIWORK=-1 call for STEMR

    fortranname cstemr
    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,int*,float*,float*,float*,float*,int*,int*,int*,float*,float*,int*,int*,int*,int*,float*,int*,int*,int*,int*

    real dimension(n),intent(in,copy) :: d
    real dimension(n),intent(in,copy) :: e
    integer intent(in) :: range
    real intent(in) :: vl
    real intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(hide) :: m
    real dimension(n),depend(n),intent(hide) :: w
    real dimension(n,n),depend(n),intent(hide) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),intent(hide) :: lwork = -1
    real intent(out) :: work
    integer intent(hide) :: liwork = -1
    integer intent(out) :: iwork
    integer intent(out) :: info
end subroutine sstemr_lwork


subroutine dstemr_lwork(d,e,range,vl,vu,il,iu,compute_v,n,m,w,z,ldz,nzc,isuppz,tryrac,work,lwork,iwork,liwork,info)
    ! LWORK=-1, LIWORK=-1 call for STEMR

    fortranname zstemr
    callstatement (*f2py_func)((compute_v?"V":"N"),(range>0?(range==1?"V":"I"):"A"),&n,d,e,&vl,&vu,&il,&iu,&m,w,z,&ldz,&nzc,isuppz,&tryrac,&work,&lwork,&iwork,&liwork,&info)
    callprotoargument char*,char*,int*,double*,double*,double*,double*,int*,int*,int*,double*,double*,int*,int*,int*,int*,double*,int*,int*,int*,int*

    double precision dimension(n),intent(in,copy) :: d
    double precision dimension(n),intent(in,copy) :: e
    integer intent(in) :: range
    double precision intent(in) :: vl
    double precision intent(in) :: vu
    integer intent(in) :: il
    integer intent(in) :: iu
    integer optional,intent(in) :: compute_v = 1
    integer intent(hide),depend(d),check(n>0) :: n = shape(d,0)
    integer intent(hide) :: m
    double precision dimension(n),depend(n),intent(hide) :: w
    double precision dimension(n,n),depend(n),intent(hide) :: z
    integer depend(n),intent(hide) :: ldz = (compute_v?n:1)  ! could be made more efficient for index queries
    integer depend(n),intent(hide) :: nzc = n  ! can also be passed as -1 to do a query
    integer dimension((compute_v?2*n:1)),depend(n),intent(hide) :: isuppz
    integer intent(hide) :: tryrac = 1
    integer depend(n),intent(hide) :: lwork = -1
    double precision intent(out) :: work
    integer intent(hide) :: liwork = -1
    integer intent(out) :: iwork
    integer intent(out) :: info
end subroutine dstemr_lwork



subroutine sstev(d,e,compute_v,n,z,ldz,work,info)
    ! computes all eigenvalues, and, optionally eigvectors of a real,
    ! symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),&n,d,e,z,&ldz,work,&info)
    callprotoargument char*,int*,float*,float*,float*,int*,float*,int*

    integer optional,intent(in):: compute_v = 1
    real dimension(n),intent(in,out,copy,out=vals) :: d
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    real depend(n),dimension(MAX(n-1,1)),intent(in,copy) :: e
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    real dimension(ldz,(compute_v?n:1)),intent(out),depend(n,ldz) :: z
    real dimension((compute_v?MAX(1,2*n-2):1)),depend(n),intent(hide) :: work
    integer intent(out) :: info

end subroutine sstev


subroutine dstev(d,e,compute_v,n,z,ldz,work,info)
    ! computes all eigenvalues, and, optionally eigvectors of a real,
    ! symmetric tridiagonal matrix.

    callstatement (*f2py_func)((compute_v?"V":"N"),&n,d,e,z,&ldz,work,&info)
    callprotoargument char*,int*,double*,double*,double*,int*,double*,int*

    integer optional,intent(in):: compute_v = 1
    double precision dimension(n),intent(in,out,copy,out=vals) :: d
    integer depend(d),intent(hide),check(n>0) :: n = shape(d,0)
    double precision depend(n),dimension(MAX(n-1,1)),intent(in,copy) :: e
    integer intent(hide),depend(n) :: ldz=(compute_v?n:1)
    double precision dimension(ldz,(compute_v?n:1)),intent(out),depend(n,ldz) :: z
    double precision dimension((compute_v?MAX(1,2*n-2):1)),depend(n),intent(hide) :: work
    integer intent(out) :: info

end subroutine dstev



subroutine ssfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    ! 
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,int*,int*,float*,float*,int*,float*,float*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    real intent(in):: alpha
    real intent(in):: beta
    real dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    real dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine ssfrk


subroutine dsfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    ! 
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,int*,int*,double*,double*,int*,double*,double*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    double precision intent(in):: alpha
    double precision intent(in):: beta
    double precision dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    double precision dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine dsfrk


subroutine chfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    ! 
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,int*,int*,float*,complex_float*,int*,float*,complex_float*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    real intent(in):: alpha
    real intent(in):: beta
    complex dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    complex dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine chfrk


subroutine zhfrk(transr,uplo,trans,n,k,nt,ka,alpha,a,lda,beta,c)
    !
    ! (S/D)SFRK - (C/Z)HFRK performs one of the Sym/Hermitian rank--k operations
    !
    !    C := alpha*A*A**H + beta*C,  or C := alpha*A**H*A + beta*C
    ! 
    ! where alpha and beta are real scalars, C is an n--by--n Sym/Hermitian
    ! matrix and A is an n--by--k matrix in the first case and a k--by--n
    ! matrix in the second case.

    callstatement (*f2py_func)(transr,uplo,trans,&n,&k,&alpha,a,&lda,&beta,c)
    callprotoargument char*,char*,char*,int*,int*,double*,complex_double*,int*,double*,complex_double*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    integer intent(in), check(n>=0):: n
    integer intent(in), check(k>=0):: k
    double precision intent(in):: alpha
    double precision intent(in):: beta
    double complex dimension(lda,ka),intent(in):: a
    integer intent(hide),depend(a,trans,n,k),check(ka==(*trans=='N'?k:n)):: ka=shape(a,1)
    integer intent(hide),depend(trans,a,n,k):: lda = MAX((*trans=='N'?n:k),1)
    double complex dimension(nt),intent(in,out,copy,out=cout):: c
    integer intent(hide),depend(c),check(nt==(n*(n+1)/2)):: nt=shape(c,0)

end subroutine zhfrk



subroutine stpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,int*,float*,float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    real dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine stpttf


subroutine dtpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,int*,double*,double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double precision dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine dtpttf


subroutine ctpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,int*,complex_float*,complex_float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    complex dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine ctpttf


subroutine ztpttf(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,ap,arf,&info)
    callprotoargument char*,char*,int*,complex_double*,complex_double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double complex dimension(nt),intent(out),depend(nt):: arf
    integer intent(out):: info

end subroutine ztpttf



subroutine stpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !
    
    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,int*,float*,float*,int*,int*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    real dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine stpttr


subroutine dtpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !
    
    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,int*,double*,double*,int*,int*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double precision dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine dtpttr


subroutine ctpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !
    
    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,int*,complex_float*,complex_float*,int*,int*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    complex dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine ctpttr


subroutine ztpttr(uplo,n,nt,ap,a,lda,info)
    !
    ! TPTTR copies a triangular matrix from the standard packed format (TP)
    ! to the standard full format (TR).
    !
    
    callstatement (*f2py_func)(uplo,&n,ap,a,&lda,&info)
    callprotoargument char*,int*,complex_double*,complex_double*,int*,int*

    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: ap
    integer intent(hide),depend(ap,n),check(nt==(n*(n+1)/2)):: nt=shape(ap,0)
    double complex dimension(n,n),intent(out),depend(n):: a
    integer intent(hide),depend(n):: lda=MAX(n,1)
    integer intent(out):: info

end subroutine ztpttr



subroutine stfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,int*,float*,float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    real dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine stfttp


subroutine dtfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,int*,double*,double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double precision dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine dtfttp


subroutine ctfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,int*,complex_float*,complex_float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    complex dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine ctfttp


subroutine ztfttp(transr,uplo,n,nt,ap,arf,info)
    !
    ! copies a triangular matrix from the standard packed format (TP) to the
    ! rectangular full packed format (TF).
    !
    
    callstatement (*f2py_func)(transr,uplo,&n,arf,ap,&info)
    callprotoargument char*,char*,int*,complex_double*,complex_double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double complex dimension(nt),intent(out),depend(nt):: ap
    integer intent(out):: info

end subroutine ztfttp



subroutine stfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR). 
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,int*,float*,float*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    real dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine stfttr


subroutine dtfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR). 
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,int*,double*,double*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double precision dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine dtfttr


subroutine ctfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR). 
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,int*,complex_float*,complex_float*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    complex dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine ctfttr


subroutine ztfttr(transr,uplo,n,nt,arf,a,lda,info)
    !
    ! TFTTR copies a triangular matrix from the rectangular full packed
    ! format (TF) to the standard full format (TR). 
    !
    callstatement (*f2py_func)(transr,uplo,&n,arf,a,&lda,&info)
    callprotoargument char*,char*,int*,complex_double*,complex_double*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: arf
    integer intent(hide),depend(arf,n),check(nt==(n*(n+1)/2)):: nt=shape(arf,0)
    double complex dimension(lda,n),depend(lda,n),intent(out):: a
    integer intent(hide),depend(n):: lda = MAX(n,1)
    integer intent(out):: info

end subroutine ztfttr



subroutine strttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,int*,float*,int*,float*,int*
    
    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    real dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    real dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine strttf


subroutine dtrttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,int*,double*,int*,double*,int*
    
    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double precision dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double precision dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine dtrttf


subroutine ctrttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,int*,complex_float*,int*,complex_float*,int*
    
    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    complex dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine ctrttf


subroutine ztrttf(transr,uplo,n,a,lda,arf,info)
    !
    ! TRTTF copies a triangular matrix A from standard full format (TR)
    ! to rectangular full packed format (TF).
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&lda,arf,&info)
    callprotoargument char*,char*,int*,complex_double*,int*,complex_double*,int*
    
    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double complex dimension(n*(n+1)/2),intent(out),depend(n):: arf
    integer intent(out):: info

end subroutine ztrttf



subroutine strttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP). 
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,int*,float*,int*,float*,int*
    
    character optional, intent(int),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    real dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    real dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine strttp


subroutine dtrttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP). 
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,int*,double*,int*,double*,int*
    
    character optional, intent(int),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double precision dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double precision dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine dtrttp


subroutine ctrttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP). 
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,int*,complex_float*,int*,complex_float*,int*
    
    character optional, intent(int),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    complex dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine ctrttp


subroutine ztrttp(uplo,n,a,lda,ap,info)
    !
    ! TRTTP copies a triangular matrix from the standard full format (TR) to
    ! the standard packed format (TP). 
    !
    callstatement (*f2py_func)(uplo,&n,a,&lda,ap,&info)
    callprotoargument char*,int*,complex_double*,int*,complex_double*,int*
    
    character optional, intent(int),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(hide),depend(a):: n = shape(a,1)
    integer intent(hide),depend(a):: lda = MAX(shape(a,0),1)
    double complex dimension(lda,n),intent(in),check(shape(a,0)==shape(a,1)):: a
    double complex dimension(n*(n+1)/2),intent(out),depend(n):: ap
    integer intent(out):: info

end subroutine ztrttp



subroutine stfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,int*,int*,float*,float*,float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    real intent(in):: alpha
    real dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    real dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine stfsm


subroutine dtfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,int*,int*,double*,double*,double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='T'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    double precision intent(in):: alpha
    double precision dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    double precision dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine dtfsm


subroutine ctfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,int*,int*,complex_float*,complex_float*,complex_float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    complex intent(in):: alpha
    complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    complex dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine ctfsm


subroutine ztfsm(transr,side,uplo,trans,diag,m,n,nt,alpha,a,b,ldb)
    !
    ! Level 3 BLAS like routine for A in RFP Format.
    !
    ! TFSM  solves the matrix equation
    !
    !        op( A )*X = alpha*B  or  X*op( A ) = alpha*B
    !
    ! where alpha is a scalar, X and B are m by n matrices, A is a unit, or
    ! non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
    !
    !    op( A ) = A   or   op( A ) = A**H.
    !
    ! A is in Rectangular Full Packed (RFP) Format. The matrix X is overwritten on B.
    !

    callstatement (*f2py_func)(transr,side,uplo,trans,diag,&m,&n,&alpha,a,b,&ldb)
    callprotoargument char*,char*,char*,char*,char*,int*,int*,complex_double*,complex_double*,complex_double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*side=='L'||*side=='R'):: side = 'L'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    character optional,intent(in),check(*trans=='N'||*trans=='C'):: trans = 'N'
    character optional,intent(in),check(*diag=='U'||*diag=='N'):: diag = 'N'
    integer intent(hide),depend(b):: m=shape(b,0)
    integer intent(hide),depend(b):: n=shape(b,1)
    double complex intent(in):: alpha
    double complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,m,n,side),check(*side=='L'?nt==(m*(m+1)/2):nt==(n*(n+1)/2)):: nt=shape(a,0)
    double complex dimension(m,n),intent(in,out,copy,out=x):: b
    integer intent(hide),depend(b):: ldb=MAX(shape(b,0),1)

end subroutine ztfsm



subroutine spftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)    
    integer intent(out):: info

end subroutine spftrf


subroutine dpftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)    
    integer intent(out):: info

end subroutine dpftrf


subroutine cpftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,complex_float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)    
    integer intent(out):: info

end subroutine cpftrf


subroutine zpftrf(transr,uplo,n,nt,a,info)
    !
    ! Computes the Cholesky factorization of a complex Hermitian positive definite matrix A.
    ! The factorization has the form
    !
    !    A = U**H * U,  if UPLO = 'U', or   A = L  * L**H,  if UPLO = 'L',
    !
    ! where U is an upper triangular matrix and L is lower triangular.
    ! This is the block version of the algorithm, calling Level 3 BLAS.
    !
    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,complex_double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in,out,copy,out=achol):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)    
    integer intent(out):: info

end subroutine zpftrf



subroutine spftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)  
    integer intent(out):: info

end subroutine spftri


subroutine dpftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)  
    integer intent(out):: info

end subroutine dpftri


subroutine cpftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,complex_float*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)  
    integer intent(out):: info

end subroutine cpftri


subroutine zpftri(transr,uplo,n,nt,a,info)
    !
    ! Computes the inverse of a real/complex Sym/Hermitian positive definite
    ! matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
    ! computed by ?PFTRF.
    !

    callstatement (*f2py_func)(transr,uplo,&n,a,&info)
    callprotoargument char*,char*,int*,complex_double*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in,out,copy,out=ainv):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)  
    integer intent(out):: info

end subroutine zpftri



subroutine spftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,int*,int*,float*,float*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    real dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    real dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinespftrs


subroutine dpftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,int*,int*,double*,double*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='T'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double precision dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    double precision dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinedpftrs


subroutine cpftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    complex dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinecpftrs


subroutine zpftrs(transr,uplo,n,nhrs,nt,a,b,ldb,info)
    !
    ! ?PFTRS solves a system of linear equations A*X = B with a Sym/Hermitian
    ! positive definite matrix A using the Cholesky factorization
    ! A = U**H*U or A = L*L**H computed by ?PFTRF.
    !
    callstatement (*f2py_func)(transr,uplo,&n,&nhrs,a,b,&ldb,&info)
    callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,int*

    character optional,intent(in),check(*transr=='N'||*transr=='C'):: transr = 'N'
    character optional,intent(in),check(*uplo=='U'||*uplo=='L'):: uplo = 'U'
    integer intent(in), check(n>=0):: n
    double complex dimension(nt),intent(in):: a
    integer intent(hide),depend(a,n),check(nt==(n*(n+1)/2)):: nt=shape(a,0)
    double complex dimension(ldb, nhrs),intent(in,out,copy,out=x),depend(n),check(shape(b,0)>=n):: b
    integer intent(hide),depend(b):: nhrs = shape(b,1)
    integer intent(hide),depend(b):: ldb = MAX(shape(b,0),1)
    integer intent(out):: info

end subroutinezpftrs



subroutine stzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument int*,int*,float*,int*,float*,float*,int*,int*
    
    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    real dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    real dimension(m),intent(out),depend(m):: tau
    real dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info
    
end subroutinestzrzf


subroutine dtzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument int*,int*,double*,int*,double*,double*,int*,int*
    
    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double precision dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    double precision dimension(m),intent(out),depend(m):: tau
    double precision dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info
    
end subroutinedtzrzf


subroutine ctzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*
    
    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    complex dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    complex dimension(m),intent(out),depend(m):: tau
    complex dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info
    
end subroutinectzrzf


subroutine ztzrzf(m,n,a,lda,tau,work,lwork,info)
    ! TZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A
    ! to upper triangular form by means of unitary transformations.
    !
    ! The upper trapezoidal matrix A is factored as
    !
    !    A = ( R  0 ) * Z,
    !
    ! where Z is an N-by-N unitary matrix and R is an M-by-M upper
    ! triangular matrix.
    !
    callstatement (*f2py_func)(&m,&n,a,&lda,tau,work,&lwork,&info)
    callprotoargument int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*
    
    integer intent(hide),depend(a):: m=shape(a,0)
    integer intent(hide),depend(a):: n=shape(a,1)
    integer intent(hide),depend(a):: lda=MAX(shape(a,0),1)
    double complex dimension(m,n),intent(in,out,copy,out=rz),check(shape(a,1)>=shape(a,0)):: a
    double complex dimension(m),intent(out),depend(m):: tau
    double complex dimension(MAX(lwork,1)),depend(lwork),intent(hide,cache):: work
    integer optional, intent(in),depend(m),check(lwork>=m):: lwork = MAX(m,1)
    integer intent(out):: info
    
end subroutineztzrzf



subroutine stzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname stzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument int*,int*,float*,int*,float*,float*,int*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    real intent(hide) :: a
    real intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    real intent(out) :: work
    integer intent(out) :: info

end subroutinestzrzf_lwork


subroutine dtzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname dtzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument int*,int*,double*,int*,double*,double*,int*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    double precision intent(hide) :: a
    double precision intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    double precision intent(out) :: work
    integer intent(out) :: info

end subroutinedtzrzf_lwork


subroutine ctzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname ctzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument int*,int*,complex_float*,int*,complex_float*,complex_float*,int*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    complex intent(hide) :: a
    complex intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    complex intent(out) :: work
    integer intent(out) :: info

end subroutinectzrzf_lwork


subroutine ztzrzf_lwork(m,n,a,lda,tau,work,lwork,info)
    ! lwork computation for tzrzf
    fortranname ztzrzf
    callstatement (*f2py_func)(&m,&n,&a,&lda,&tau,&work,&lwork,&info)
    callprotoargument int*,int*,complex_double*,int*,complex_double*,complex_double*,int*,int*

    integer intent(in):: m
    integer intent(in):: n
    integer intent(hide),depend(m):: lda=MAX(m,1)
    double complex intent(hide) :: a
    double complex intent(hide) :: tau
    integer intent(hide) :: lwork = -1
    double complex intent(out) :: work
    integer intent(out) :: info

end subroutineztzrzf_lwork



subroutine slasd4( n, i, d, z, delta, rho, sigma, work, info )
	! sigma, delta, work, info = lasd4(d,z,i,rho=1.0)
   	! Computes i-th square root of eigenvalue of rank one augmented diagonal matrix. Needed by SVD update procedure

	callstatement { i++; (*f2py_func)( &n, &i, d, z, delta, &rho, &sigma, work, &info); }
    callprotoargument int*, int*, float*, float*, float*, float*, float*, float*, int*

	integer intent(hide),depend(d):: n = shape(d,0)
	integer intent(in),depend(d),check(i>=0 && i<=(shape(d,0)-1)):: i

	real dimension(n),intent(in)           :: d
	real dimension(n),intent(in),depend(n) :: z

	real intent(out) :: sigma
	real dimension(n),intent(out),depend(n) :: delta
	real intent(in),optional:: rho = 1.0

	real dimension(n),intent(out),depend(n) :: work
	integer intent(out) :: info

end subroutine slasd4


subroutine dlasd4( n, i, d, z, delta, rho, sigma, work, info )
	! sigma, delta, work, info = lasd4(d,z,i,rho=1.0)
   	! Computes i-th square root of eigenvalue of rank one augmented diagonal matrix. Needed by SVD update procedure

	callstatement { i++; (*f2py_func)( &n, &i, d, z, delta, &rho, &sigma, work, &info); }
    callprotoargument int*, int*, double*, double*, double*, double*, double*, double*, int*

	integer intent(hide),depend(d):: n = shape(d,0)
	integer intent(in),depend(d),check(i>=0 && i<=(shape(d,0)-1)):: i

	double precision dimension(n),intent(in)           :: d
	double precision dimension(n),intent(in),depend(n) :: z

	double precision intent(out) :: sigma
	double precision dimension(n),intent(out),depend(n) :: delta
	double precision intent(in),optional:: rho = 1.0

	double precision dimension(n),intent(out),depend(n) :: work
	integer intent(out) :: info

end subroutine dlasd4



subroutine slauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    real dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine slauum


subroutine dlauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double precision dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine dlauum


subroutine clauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,complex_float*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    complex dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine clauum


subroutine zlauum(n,c,info,lower)
    ! a,info = lauum(c,lower=0,overwrite_c=0)
    ! Compute product
    ! U^T * U, C = U if lower = 0
    ! L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.

    callstatement (*f2py_func)((lower?"L":"U"),&n,c,&n,&info)
    callprotoargument char*,int*,complex_double*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer depend(c),intent(hide):: n = shape(c,0)
    double complex dimension(n,n),intent(in,out,copy,out=a) :: c
    check(shape(c,0)==shape(c,1)) :: c
    integer intent(out) :: info

end subroutine zlauum



subroutine slaswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {int i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument int*,float*,int*,int*,int*,int*,int*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    real dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine slaswp


subroutine dlaswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {int i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument int*,double*,int*,int*,int*,int*,int*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double precision dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine dlaswp


subroutine claswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {int i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument int*,complex_float*,int*,int*,int*,int*,int*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    complex dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine claswp


subroutine zlaswp(n,a,nrows,k1,k2,piv,off,inc,m,npiv)
    ! a = laswp(a,piv,k1=0,k2=len(piv)-1,off=0,inc=1,overwrite_a=0)
    ! Perform row interchanges on the matrix A for each of row k1 through k2
    !
    ! piv pivots rows.

    callstatement {int i;m=len(piv);for(i=0;i<m;++piv[i++]);++k1;++k2; (*f2py_func)(&n,a,&nrows,&k1,&k2,piv+off,&inc); for(i=0;i<m;--piv[i++]);}
    callprotoargument int*,complex_double*,int*,int*,int*,int*,int*

    integer depend(a),intent(hide):: nrows = shape(a,0)
    integer depend(a),intent(hide):: n = shape(a,1)
    double complex dimension(nrows,n),intent(in,out,copy) :: a
    integer dimension(npiv),intent(in) :: piv
    integer intent(hide),depend(piv,nrows),check(npiv<=nrows) :: npiv = len(piv)
    !XXX: how to check that all elements in piv are < n?

    integer optional,intent(in),check(0<=k1) :: k1 = 0
    integer optional,intent(in),depend(k1,npiv,off),check(k1<=k2 && k2<npiv-off) :: k2 = npiv-1

    integer optional, intent(in),check(inc>0||inc<0) :: inc = 1
    integer optional,intent(in),depend(npiv),check(off>=0 && off<len(piv)) :: off=0
    integer intent(hide),depend(npiv,inc,off),check(npiv-off>(m-1)*abs(inc)) :: m = (len(piv)-off)/abs(inc)

end subroutine zlaswp



! dlamch = dlamch(cmach)
!
! determine double precision machine parameters
!  CMACH   (input) CHARACTER*1
!          Specifies the value to be returned by DLAMCH:
!          = 'E' or 'e',   DLAMCH := eps
!          = 'S' or 's ,   DLAMCH := sfmin
!          = 'B' or 'b',   DLAMCH := base
!          = 'P' or 'p',   DLAMCH := eps*base
!          = 'N' or 'n',   DLAMCH := t
!          = 'R' or 'r',   DLAMCH := rnd
!          = 'M' or 'm',   DLAMCH := emin
!          = 'U' or 'u',   DLAMCH := rmin
!          = 'L' or 'l',   DLAMCH := emax
!          = 'O' or 'o',   DLAMCH := rmax
!
!          where
!
!          eps   = relative machine precision
!          sfmin = safe minimum, such that 1/sfmin does not overflow
!          base  = base of the machine
!          prec  = eps*base
!          t     = number of (base) digits in the mantissa
!          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
!          emin  = minimum exponent before (gradual) underflow
!          rmin  = underflow threshold - base**(emin-1)
!          emax  = largest exponent before overflow
!          rmax  = overflow threshold  - (base**emax)*(1-eps)
function dlamch(cmach)
    character :: cmach
    double precision intent(out):: dlamch
end function dlamch

function slamch(cmach)
    character :: cmach
    real intent(out):: slamch
end function slamch

function slange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a real matrix A.
    real slange, n2
    callstatement (*f2py_func)(&slange,norm,&m,&n,a,&lda,work)
    callprotoargument float*,char*,int*,int*,float*,int*,float*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    real dimension(m,n),intent(in) :: a
    real dimension(m+1),intent(cache,hide) :: work
end function slange


function dlange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a real matrix A.
    double precision dlange, n2
    callstatement (*f2py_func)(&dlange,norm,&m,&n,a,&lda,work)
    callprotoargument double*,char*,int*,int*,double*,int*,double*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    double precision dimension(m,n),intent(in) :: a
    double precision dimension(m+1),intent(cache,hide) :: work
end function dlange



function clange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a complex matrix A.
    real clange, n2
    callstatement (*f2py_func)(&clange,norm,&m,&n,a,&lda,work)
    callprotoargument float*,char*,int*,int*,complex_float*,int*,float*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    complex dimension(m,n),intent(in) :: a
    real dimension(m+1),intent(cache,hide) :: work
end function clange


function zlange(norm,m,n,a,lda,work) result(n2)
    ! the one norm, or the Frobenius norm, or the  infinity norm, or the
    ! element of largest absolute value of a complex matrix A.
    double precision zlange, n2
    callstatement (*f2py_func)(&zlange,norm,&m,&n,a,&lda,work)
    callprotoargument double*,char*,int*,int*,complex_double*,int*,double*

    character intent(in),check(*norm=='M'||*norm=='m'||*norm=='1'||*norm=='O'||*norm=='o'||*norm=='I'||*norm=='i'||*norm=='F'||*norm=='f'||*norm=='E'||*norm=='e'):: norm
    integer intent(hide),depend(a,n) :: m = shape(a,0)
    integer intent(hide),depend(m) :: lda = max(1,m)
    integer intent(hide),depend(a) :: n = shape(a,1)
    double complex dimension(m,n),intent(in) :: a
    double precision dimension(m+1),intent(cache,hide) :: work
end function zlange



subroutine slarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    real intent(in,out) :: alpha
    real intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    real intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine slarfg


subroutine dlarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    double precision intent(in,out) :: alpha
    double precision intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    double precision intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine dlarfg


subroutine clarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    complex intent(in,out) :: alpha
    complex intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    complex intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine clarfg


subroutine zlarfg(n, alpha, x, incx, tau, lx)
    integer intent(in), check(n>=1) :: n
    double complex intent(in,out) :: alpha
    double complex intent(in,copy,out), dimension(lx) :: x
    integer intent(in), check(incx>0||incx<0) :: incx = 1
    double complex intent(out) :: tau
    integer intent(hide),depend(x,n,incx),check(lx > (n-2)*incx) :: lx = len(x)
end subroutine zlarfg



subroutine slarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    real intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    real intent(in) :: tau
    real dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    real intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine slarf


subroutine dlarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    double precision intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    double precision intent(in) :: tau
    double precision dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    double precision intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine dlarf


subroutine clarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    complex intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    complex intent(in) :: tau
    complex dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    complex intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine clarf


subroutine zlarf(side,m,n,v,incv,tau,c,ldc,work,lwork)
    character intent(in), check(side[0]=='L'||side[0]=='R') :: side = 'L'
    integer intent(in,hide), depend(c) :: m = shape(c,0)
    integer intent(in,hide), depend(c) :: n = shape(c,1)
    double complex intent(in),dimension((side[0]=='L'?(1 + (m-1)*abs(incv)):(1 + (n-1)*abs(incv)))),depend(n,m,side,incv) :: v
    integer intent(in), check(incv>0||incv<0) :: incv = 1
    double complex intent(in) :: tau
    double complex dimension(m,n), intent(in,copy,out) :: c
    integer intent(in,hide) :: ldc = max(1,shape(c,0))
    ! FIXME: work should not have been an input argument but kept here for backwards compatibility!
    double complex intent(in),dimension(lwork),depend(side,m,n) :: work
    integer intent(hide),depend(work),check(lwork >= (side[0]=='L'?n:m)) :: lwork = len(work)
end subroutine zlarf



subroutine slartg(f,g,cs,sn,r)
    real intent(in) :: f
    real intent(in) :: g
    real intent(out) :: cs
    real intent(out) :: sn
    real intent(out) :: r
end subroutine slartg


subroutine dlartg(f,g,cs,sn,r)
    double precision intent(in) :: f
    double precision intent(in) :: g
    double precision intent(out) :: cs
    double precision intent(out) :: sn
    double precision intent(out) :: r
end subroutine dlartg


subroutine clartg(f,g,cs,sn,r)
    complex intent(in) :: f
    complex intent(in) :: g
    real intent(out) :: cs
    complex intent(out) :: sn
    complex intent(out) :: r
end subroutine clartg


subroutine zlartg(f,g,cs,sn,r)
    double complex intent(in) :: f
    double complex intent(in) :: g
    double precision intent(out) :: cs
    double complex intent(out) :: sn
    double complex intent(out) :: r
end subroutine zlartg



subroutine crot(n,x,offx,incx,y,offy,incy,c,s,lx,ly)
    callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
    callprotoargument int*,complex_float*,int*,complex_float*,int*,float*,complex_float*
    complex dimension(lx),intent(in,out,copy) :: x
    complex dimension(ly),intent(in,out,copy) :: y
    integer intent(hide),depend(x) :: lx = len(x)
    integer intent(hide),depend(y) :: ly = len(y)
    real intent(in) :: c
    complex intent(in) :: s
    integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
    integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
    integer optional, intent(in), depend(lx), check(offx>=0 && offx<lx) :: offx=0
    integer optional, intent(in), depend(ly), check(offy>=0 && offy<ly) :: offy=0
    integer optional, intent(in), depend(lx,incx,offx,ly,incy,offy) :: n = (lx-1-offx)/abs(incx)+1
    check(lx-offx>(n-1)*abs(incx)) :: n
    check(ly-offy>(n-1)*abs(incy)) :: n
end subroutine crot


subroutine zrot(n,x,offx,incx,y,offy,incy,c,s,lx,ly)
    callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
    callprotoargument int*,complex_double*,int*,complex_double*,int*,double*,complex_double*
    double complex dimension(lx),intent(in,out,copy) :: x
    double complex dimension(ly),intent(in,out,copy) :: y
    integer intent(hide),depend(x) :: lx = len(x)
    integer intent(hide),depend(y) :: ly = len(y)
    double precision intent(in) :: c
    double complex intent(in) :: s
    integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
    integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
    integer optional, intent(in), depend(lx), check(offx>=0 && offx<lx) :: offx=0
    integer optional, intent(in), depend(ly), check(offy>=0 && offy<ly) :: offy=0
    integer optional, intent(in), depend(lx,incx,offx,ly,incy,offy) :: n = (lx-1-offx)/abs(incx)+1
    check(lx-offx>(n-1)*abs(incx)) :: n
    check(ly-offy>(n-1)*abs(incy)) :: n
end subroutine zrot



subroutine ilaver(major, minor, patch)
    integer intent(out) :: major
    integer intent(out) :: minor
    integer intent(out) :: patch
end subroutine ilaver

end interface

end python module _flapack

! This file was auto-generated with f2py (version:2.10.173).
! See http://cens.ioc.ee/projects/f2py2e/
