#line 1 "scipy/fftpack/src/dct.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* vim:syntax=c
 * vim:sw=4
 *
 * Interfaces to the DCT transforms of fftpack
 */
#include <math.h>

#include "fftpack.h"

enum normalize {
    DCT_NORMALIZE_NO = 0,
    DCT_NORMALIZE_ORTHONORMAL = 1
};

#line 21
extern void F_FUNC(costi, COSTI)(int*, float*);
extern void F_FUNC(cost, COST)(int*, float*, float*);
extern void F_FUNC(cosqi, COSQI)(int*, float*);
extern void F_FUNC(cosqb, COSQB)(int*, float*, float*);
extern void F_FUNC(cosqf, COSQF)(int*, float*, float*);

GEN_CACHE(dct1,(int n)
      ,float* wsave;
      ,(caches_dct1[i].n==n)
      ,caches_dct1[id].wsave = malloc(sizeof(float)*(3*n+15));
       F_FUNC(costi, COSTI)(&n, caches_dct1[id].wsave);
      ,free(caches_dct1[id].wsave);
      ,10)

GEN_CACHE(dct2,(int n)
      ,float* wsave;
      ,(caches_dct2[i].n==n)
      ,caches_dct2[id].wsave = malloc(sizeof(float)*(3*n+15));
       F_FUNC(cosqi,COSQI)(&n,caches_dct2[id].wsave);
      ,free(caches_dct2[id].wsave);
      ,10)

void dct4init(int n, float *wsave)
{
    float *C;
    int i;
    const double PI_2 = 1.57079632679489661923;
    F_FUNC(cosqi,COSQI)(&n,wsave);
    /* store extra constants at end of array */
    C = &wsave[3*n+15];
    for (i=0; i<n; i++) {
        C[i] = cos(PI_2*(i+0.5)/n);
    }
}

GEN_CACHE(dct4,(int n)
      ,float* wsave;
      ,(caches_dct4[i].n==n)
      ,caches_dct4[id].wsave = malloc(sizeof(float)*(4*n+15));
       dct4init(n,caches_dct4[id].wsave);
      ,free(caches_dct4[id].wsave);
      ,10)


void dct1(float * inout, int n, int howmany, int normalize)
{
    int i;
    float *ptr = inout;
    float *wsave = NULL;

    wsave = caches_dct1[get_cache_id_dct1(n)].wsave;


    for (i = 0; i < howmany; ++i, ptr += n) {
        if (normalize==DCT_NORMALIZE_ORTHONORMAL) {
            const float m0 = sqrt(2.0);
            ptr[0]   *= m0;
            ptr[n-1] *= m0;
        }

        F_FUNC(cost, COST)(&n, ptr, wsave);
    }

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            {
                float m0 = 0.5*sqrt(1. / (n-1));
                float m = 0.5*sqrt(2. / (n-1));
                int j;
                ptr = inout;
                for (i = 0; i < howmany; ++i, ptr += n) {
                    ptr[0] *= m0;
                    for (j=1; j<n-1; j++) {
                        ptr[j] *= m;
                    }
                    ptr[n-1] *= m0;
                }
            }
            break;
        default:
            fprintf(stderr, "dct1: normalize not yet supported=%d\n",
                    normalize);
            break;
    }
}

void dct2(float * inout, int n, int howmany, int normalize)
{
    int i, j;
    float *ptr = inout;
    float *wsave = NULL;
    float n1, n2;

    wsave = caches_dct2[get_cache_id_dct2(n)].wsave;

    for (i = 0; i < howmany; ++i, ptr += n) {
        F_FUNC(cosqb, COSQB)(&n, ptr, wsave);

    }

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            ptr = inout;
            /* 0.5 coeff comes from fftpack defining DCT as
             * 4 * sum(cos(something)), whereas most definition
             * use 2 */
            for (i = 0; i < n * howmany; ++i) {
                ptr[i] *= 0.5;
            }
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            ptr = inout;
            /* 0.5 coeff comes from fftpack defining DCT as
             * 4 * sum(cos(something)), whereas most definition
             * use 2 */
            n1 = 0.25 * sqrt(1./n);
            n2 = 0.25 * sqrt(2./n);
            for (i = 0; i < howmany; ++i, ptr+=n) {
                ptr[0] *= n1;
                for (j = 1; j < n; ++j) {
                    ptr[j] *= n2;
                }
            }
            break;
        default:
            fprintf(stderr, "dct2: normalize not yet supported=%d\n",
                    normalize);
            break;
    }
}

void dct3(float * inout, int n, int howmany, int normalize)
{
    int i, j;
    float *ptr = inout;
    float *wsave = NULL;
    float n1, n2;

    wsave = caches_dct2[get_cache_id_dct2(n)].wsave;

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            n1 = sqrt(1./n);
            n2 = sqrt(0.5/n);
            for (i = 0; i < howmany; ++i, ptr+=n) {
                ptr[0] *= n1;
                for (j = 1; j < n; ++j) {
                    ptr[j] *= n2;
                }
            }
            break;
        default:
            fprintf(stderr, "dct3: normalize not yet supported=%d\n",
                    normalize);
            break;
    }

    ptr = inout;
    for (i = 0; i < howmany; ++i, ptr += n) {
        F_FUNC(cosqf, COSQF)(&n, ptr, wsave);

    }

}

/*
DCT-IV from DCT-II, based on:
S.C. Chan, K.L. Ho, Direct methods for computing discrete sinusoidal transforms,
IEE Proceedings F, Volume 137, Issue 6, 1990
*/
void dct4(float * inout, int n, int howmany, int normalize)
{
    int i, j;
    float *ptr = inout;
    float *wsave = NULL;
    float m;
    float *C;

    wsave = caches_dct4[get_cache_id_dct4(n)].wsave;
    C = &wsave[3*n+15];
    for (i = 0; i < howmany; ++i, ptr += n) {
        for (j=0; j<n; j++) {
            ptr[j] *= C[j];
        }
        F_FUNC(cosqb, COSQB)(&n, ptr, wsave);
        ptr[0] *= 0.5;
        for (j=1; j<n; j++) {
            ptr[j] -= ptr[j-1];
        }
    }

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            ptr = inout;
            m = 0.5*sqrt(2./n);
            for (i = 0; i < n * howmany; ++i) {
                ptr[i] *= m;
            }
            break;
        default:
            fprintf(stderr, "dct4: normalize not yet supported=%d\n",
                    normalize);
            break;
    }
}


#line 21
extern void F_FUNC(dcosti, DCOSTI)(int*, double*);
extern void F_FUNC(dcost, DCOST)(int*, double*, double*);
extern void F_FUNC(dcosqi, DCOSQI)(int*, double*);
extern void F_FUNC(dcosqb, DCOSQB)(int*, double*, double*);
extern void F_FUNC(dcosqf, DCOSQF)(int*, double*, double*);

GEN_CACHE(ddct1,(int n)
      ,double* wsave;
      ,(caches_ddct1[i].n==n)
      ,caches_ddct1[id].wsave = malloc(sizeof(double)*(3*n+15));
       F_FUNC(dcosti, DCOSTI)(&n, caches_ddct1[id].wsave);
      ,free(caches_ddct1[id].wsave);
      ,10)

GEN_CACHE(ddct2,(int n)
      ,double* wsave;
      ,(caches_ddct2[i].n==n)
      ,caches_ddct2[id].wsave = malloc(sizeof(double)*(3*n+15));
       F_FUNC(dcosqi,DCOSQI)(&n,caches_ddct2[id].wsave);
      ,free(caches_ddct2[id].wsave);
      ,10)

void ddct4init(int n, double *wsave)
{
    double *C;
    int i;
    const double PI_2 = 1.57079632679489661923;
    F_FUNC(dcosqi,DCOSQI)(&n,wsave);
    /* store extra constants at end of array */
    C = &wsave[3*n+15];
    for (i=0; i<n; i++) {
        C[i] = cos(PI_2*(i+0.5)/n);
    }
}

GEN_CACHE(ddct4,(int n)
      ,double* wsave;
      ,(caches_ddct4[i].n==n)
      ,caches_ddct4[id].wsave = malloc(sizeof(double)*(4*n+15));
       ddct4init(n,caches_ddct4[id].wsave);
      ,free(caches_ddct4[id].wsave);
      ,10)


void ddct1(double * inout, int n, int howmany, int normalize)
{
    int i;
    double *ptr = inout;
    double *wsave = NULL;

    wsave = caches_ddct1[get_cache_id_ddct1(n)].wsave;


    for (i = 0; i < howmany; ++i, ptr += n) {
        if (normalize==DCT_NORMALIZE_ORTHONORMAL) {
            const double m0 = sqrt(2.0);
            ptr[0]   *= m0;
            ptr[n-1] *= m0;
        }

        F_FUNC(dcost, DCOST)(&n, ptr, wsave);
    }

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            {
                double m0 = 0.5*sqrt(1. / (n-1));
                double m = 0.5*sqrt(2. / (n-1));
                int j;
                ptr = inout;
                for (i = 0; i < howmany; ++i, ptr += n) {
                    ptr[0] *= m0;
                    for (j=1; j<n-1; j++) {
                        ptr[j] *= m;
                    }
                    ptr[n-1] *= m0;
                }
            }
            break;
        default:
            fprintf(stderr, "dct1: normalize not yet supported=%d\n",
                    normalize);
            break;
    }
}

void ddct2(double * inout, int n, int howmany, int normalize)
{
    int i, j;
    double *ptr = inout;
    double *wsave = NULL;
    double n1, n2;

    wsave = caches_ddct2[get_cache_id_ddct2(n)].wsave;

    for (i = 0; i < howmany; ++i, ptr += n) {
        F_FUNC(dcosqb, DCOSQB)(&n, ptr, wsave);

    }

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            ptr = inout;
            /* 0.5 coeff comes from fftpack defining DCT as
             * 4 * sum(cos(something)), whereas most definition
             * use 2 */
            for (i = 0; i < n * howmany; ++i) {
                ptr[i] *= 0.5;
            }
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            ptr = inout;
            /* 0.5 coeff comes from fftpack defining DCT as
             * 4 * sum(cos(something)), whereas most definition
             * use 2 */
            n1 = 0.25 * sqrt(1./n);
            n2 = 0.25 * sqrt(2./n);
            for (i = 0; i < howmany; ++i, ptr+=n) {
                ptr[0] *= n1;
                for (j = 1; j < n; ++j) {
                    ptr[j] *= n2;
                }
            }
            break;
        default:
            fprintf(stderr, "dct2: normalize not yet supported=%d\n",
                    normalize);
            break;
    }
}

void ddct3(double * inout, int n, int howmany, int normalize)
{
    int i, j;
    double *ptr = inout;
    double *wsave = NULL;
    double n1, n2;

    wsave = caches_ddct2[get_cache_id_ddct2(n)].wsave;

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            n1 = sqrt(1./n);
            n2 = sqrt(0.5/n);
            for (i = 0; i < howmany; ++i, ptr+=n) {
                ptr[0] *= n1;
                for (j = 1; j < n; ++j) {
                    ptr[j] *= n2;
                }
            }
            break;
        default:
            fprintf(stderr, "dct3: normalize not yet supported=%d\n",
                    normalize);
            break;
    }

    ptr = inout;
    for (i = 0; i < howmany; ++i, ptr += n) {
        F_FUNC(dcosqf, DCOSQF)(&n, ptr, wsave);

    }

}

/*
DCT-IV from DCT-II, based on:
S.C. Chan, K.L. Ho, Direct methods for computing discrete sinusoidal transforms,
IEE Proceedings F, Volume 137, Issue 6, 1990
*/
void ddct4(double * inout, int n, int howmany, int normalize)
{
    int i, j;
    double *ptr = inout;
    double *wsave = NULL;
    double m;
    double *C;

    wsave = caches_ddct4[get_cache_id_ddct4(n)].wsave;
    C = &wsave[3*n+15];
    for (i = 0; i < howmany; ++i, ptr += n) {
        for (j=0; j<n; j++) {
            ptr[j] *= C[j];
        }
        F_FUNC(dcosqb, DCOSQB)(&n, ptr, wsave);
        ptr[0] *= 0.5;
        for (j=1; j<n; j++) {
            ptr[j] -= ptr[j-1];
        }
    }

    switch (normalize) {
        case DCT_NORMALIZE_NO:
            break;
        case DCT_NORMALIZE_ORTHONORMAL:
            ptr = inout;
            m = 0.5*sqrt(2./n);
            for (i = 0; i < n * howmany; ++i) {
                ptr[i] *= m;
            }
            break;
        default:
            fprintf(stderr, "dct4: normalize not yet supported=%d\n",
                    normalize);
            break;
    }
}



