!%f90 -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN BLAS functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! $Revision$ $Date$
!


python module _fblas
    interface

!%f90 -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN LEVEL 1 BLAS functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! Modified: Fabian Pedregosa, 2011
!
! Implemented:
!
!   rotg, rotmg, rot, rotm, swap, scal, copy, axpy, dot, dotu, dotc
!   nrm2, asum, amax, iamax

! NOTE: Avoiding wrappers hack does not work under 64-bit Gentoo system
! with single precision routines, so they are removed.
!
! Shorthand notations
!
! 
! 
!
! 
! 
! 
! 
! 
!
! 
! 
! 
! 
! 
! 
! 
! 
!
! 
! 
! 
! 
! 
! 
! 
! 
!
!
! Level 1 BLAS
!


subroutine srotg(a,b,c,s)
  ! Computes the parameters for a Givens rotation.
  !
  ! Given the Cartesian coordinates (a, b) of a point, these routines return
  ! the parameters c, s, r, and z associated with the Givens rotation. The
  !  parameters c and s define a unitary matrix such that:
  !
  !                   ( c   s ) ( a )     ( r )
  !                   (       ) (   )  =  (   )
  !                   (-s   c ) ( b )  =  ( 0 )
  !
  ! The parameter z is defined such that if |a| > |b|, z is s; otherwise if c
  ! is not 0 z is 1/c; otherwise z is 1.
  !
  !
  ! Parameters
  ! ----------
  ! a : float or complex number
  !    Provides the x-coordinate for the point.
  !
  ! b : float or complex number
  !    Provides the y-coordinate.
  !
  ! Returns
  ! -------
  ! c, s :
  !     Parameter c associated with the Givens rotation.
  !
  ! Notes
  ! -----
  !   Unlike the FORTRAN implementation, this function will not return
  !   parameters r and z, as these can easily be computed from the
  !   returned parameters.
  !
  callprotoargument float*,float*,float*,float*

  real intent(in) :: a, b
  real intent(out,out=c) :: c
  real intent(out,out=s) :: s

end subroutine srotg



subroutine drotg(a,b,c,s)
  ! Computes the parameters for a Givens rotation.
  !
  ! Given the Cartesian coordinates (a, b) of a point, these routines return
  ! the parameters c, s, r, and z associated with the Givens rotation. The
  !  parameters c and s define a unitary matrix such that:
  !
  !                   ( c   s ) ( a )     ( r )
  !                   (       ) (   )  =  (   )
  !                   (-s   c ) ( b )  =  ( 0 )
  !
  ! The parameter z is defined such that if |a| > |b|, z is s; otherwise if c
  ! is not 0 z is 1/c; otherwise z is 1.
  !
  !
  ! Parameters
  ! ----------
  ! a : float or complex number
  !    Provides the x-coordinate for the point.
  !
  ! b : float or complex number
  !    Provides the y-coordinate.
  !
  ! Returns
  ! -------
  ! c, s :
  !     Parameter c associated with the Givens rotation.
  !
  ! Notes
  ! -----
  !   Unlike the FORTRAN implementation, this function will not return
  !   parameters r and z, as these can easily be computed from the
  !   returned parameters.
  !
  callprotoargument double*,double*,double*,double*

  double precision intent(in) :: a, b
  double precision intent(out,out=c) :: c
  double precision intent(out,out=s) :: s

end subroutine drotg



subroutine crotg(a,b,c,s)
  ! Computes the parameters for a Givens rotation.
  !
  ! Given the Cartesian coordinates (a, b) of a point, these routines return
  ! the parameters c, s, r, and z associated with the Givens rotation. The
  !  parameters c and s define a unitary matrix such that:
  !
  !                   ( c   s ) ( a )     ( r )
  !                   (       ) (   )  =  (   )
  !                   (-s   c ) ( b )  =  ( 0 )
  !
  ! The parameter z is defined such that if |a| > |b|, z is s; otherwise if c
  ! is not 0 z is 1/c; otherwise z is 1.
  !
  !
  ! Parameters
  ! ----------
  ! a : float or complex number
  !    Provides the x-coordinate for the point.
  !
  ! b : float or complex number
  !    Provides the y-coordinate.
  !
  ! Returns
  ! -------
  ! c, s :
  !     Parameter c associated with the Givens rotation.
  !
  ! Notes
  ! -----
  !   Unlike the FORTRAN implementation, this function will not return
  !   parameters r and z, as these can easily be computed from the
  !   returned parameters.
  !
  callprotoargument complex_float*,complex_float*,complex_float*,complex_float*

  complex intent(in) :: a, b
  complex intent(out,out=c) :: c
  complex intent(out,out=s) :: s

end subroutine crotg



subroutine zrotg(a,b,c,s)
  ! Computes the parameters for a Givens rotation.
  !
  ! Given the Cartesian coordinates (a, b) of a point, these routines return
  ! the parameters c, s, r, and z associated with the Givens rotation. The
  !  parameters c and s define a unitary matrix such that:
  !
  !                   ( c   s ) ( a )     ( r )
  !                   (       ) (   )  =  (   )
  !                   (-s   c ) ( b )  =  ( 0 )
  !
  ! The parameter z is defined such that if |a| > |b|, z is s; otherwise if c
  ! is not 0 z is 1/c; otherwise z is 1.
  !
  !
  ! Parameters
  ! ----------
  ! a : float or complex number
  !    Provides the x-coordinate for the point.
  !
  ! b : float or complex number
  !    Provides the y-coordinate.
  !
  ! Returns
  ! -------
  ! c, s :
  !     Parameter c associated with the Givens rotation.
  !
  ! Notes
  ! -----
  !   Unlike the FORTRAN implementation, this function will not return
  !   parameters r and z, as these can easily be computed from the
  !   returned parameters.
  !
  callprotoargument complex_double*,complex_double*,complex_double*,complex_double*

  double complex intent(in) :: a, b
  double complex intent(out,out=c) :: c
  double complex intent(out,out=s) :: s

end subroutine zrotg



subroutine srotmg(d1,d2,x1,y1,param)
  ! Computes the parameters for a modified Givens rotation.
  !
  ! Given Cartesian coordinates (x1, y1) of an input vector, this
  ! routine compute the components of a modified Givens
  ! transformation matrix H that zeros the y-component of the
  ! resulting vector:
  !
  !    [x]     [sqrt(d1) x1]
  !    [ ] = H [           ]
  !    [0]     [sqrt(d2) y1]
  !

  callstatement (*f2py_func)(&d1,&d2,&x1,&y1,param)
  callprotoargument float*,float*,float*,float*,float*

  real intent(in) :: d1, d2, x1, y1
  real intent(out), dimension(5) :: param

end subroutine srotmg


subroutine drotmg(d1,d2,x1,y1,param)
  ! Computes the parameters for a modified Givens rotation.
  !
  ! Given Cartesian coordinates (x1, y1) of an input vector, this
  ! routine compute the components of a modified Givens
  ! transformation matrix H that zeros the y-component of the
  ! resulting vector:
  !
  !    [x]     [sqrt(d1) x1]
  !    [ ] = H [           ]
  !    [0]     [sqrt(d2) y1]
  !

  callstatement (*f2py_func)(&d1,&d2,&x1,&y1,param)
  callprotoargument double*,double*,double*,double*,double*

  double precision intent(in) :: d1, d2, x1, y1
  double precision intent(out), dimension(5) :: param

end subroutine drotmg




subroutine srot(n,x,offx,incx,y,offy,incy,c,s)
  ! Applies a plane rotation with real cosine and complex sine to a
  ! pair of complex vectors and returns the modified vectors.
  !
  ! x, y are input vectors and c, s are values that define a rotation:
  !
  !                [ c        s]
  !                [           ]
  !                [-conj(s)  c]
  !
  ! where c*c + s*conjg(s) = 1.0.
  !

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,float*,int*,float*,int*,float*,float*

  real dimension(*),intent(in,out,copy) :: x,y
  real intent(in) :: c, s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in), depend(x) :: offx=0
  integer optional, intent(in), depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in), depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-1-offx)/abs(incx)+1
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine srot



subroutine drot(n,x,offx,incx,y,offy,incy,c,s)
  ! Applies a plane rotation with real cosine and complex sine to a
  ! pair of complex vectors and returns the modified vectors.
  !
  ! x, y are input vectors and c, s are values that define a rotation:
  !
  !                [ c        s]
  !                [           ]
  !                [-conj(s)  c]
  !
  ! where c*c + s*conjg(s) = 1.0.
  !

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,double*,int*,double*,int*,double*,double*

  double precision dimension(*),intent(in,out,copy) :: x,y
  double precision intent(in) :: c, s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in), depend(x) :: offx=0
  integer optional, intent(in), depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in), depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-1-offx)/abs(incx)+1
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine drot



subroutine csrot(n,x,offx,incx,y,offy,incy,c,s)
  ! Applies a plane rotation with real cosine and complex sine to a
  ! pair of complex vectors and returns the modified vectors.
  !
  ! x, y are input vectors and c, s are values that define a rotation:
  !
  !                [ c        s]
  !                [           ]
  !                [-conj(s)  c]
  !
  ! where c*c + s*conjg(s) = 1.0.
  !

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,complex_float*,int*,complex_float*,int*,float*,float*

  complex dimension(*),intent(in,out,copy) :: x,y
  real intent(in) :: c, s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in), depend(x) :: offx=0
  integer optional, intent(in), depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in), depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-1-offx)/abs(incx)+1
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine csrot



subroutine zdrot(n,x,offx,incx,y,offy,incy,c,s)
  ! Applies a plane rotation with real cosine and complex sine to a
  ! pair of complex vectors and returns the modified vectors.
  !
  ! x, y are input vectors and c, s are values that define a rotation:
  !
  !                [ c        s]
  !                [           ]
  !                [-conj(s)  c]
  !
  ! where c*c + s*conjg(s) = 1.0.
  !

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,&c,&s)
  callprotoargument int*,complex_double*,int*,complex_double*,int*,double*,double*

  double complex dimension(*),intent(in,out,copy) :: x,y
  double precision intent(in) :: c, s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in), depend(x) :: offx=0
  integer optional, intent(in), depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in), depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-1-offx)/abs(incx)+1
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zdrot




subroutine srotm(n,x,offx,incx,y,offy,incy,param)
  ! Performs rotation of points in the modified plane
  !
  ! Given two complex vectors x and y, each vector element of these vectors is
  ! replaced as follows:
  !
  !      x(i) = H*x(i) + H*y(i)
  !      y(i) = H*y(i) - H*x(i)
  !
  ! where H is a modified Givens transformation matrix whose values are stored
  ! in the param(2) through param(5) array.

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,param)
  callprotoargument int*,float*,int*,float*,int*,float*

  real dimension(*), intent(in,out,copy) :: x, y
  real dimension(5), intent(in) :: param
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine srotm



subroutine drotm(n,x,offx,incx,y,offy,incy,param)
  ! Performs rotation of points in the modified plane
  !
  ! Given two complex vectors x and y, each vector element of these vectors is
  ! replaced as follows:
  !
  !      x(i) = H*x(i) + H*y(i)
  !      y(i) = H*y(i) - H*x(i)
  !
  ! where H is a modified Givens transformation matrix whose values are stored
  ! in the param(2) through param(5) array.

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy,param)
  callprotoargument int*,double*,int*,double*,int*,double*

  double precision dimension(*), intent(in,out,copy) :: x, y
  double precision dimension(5), intent(in) :: param
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine drotm




subroutine sswap(n,x,offx,incx,y,offy,incy)
  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,float*,int*,float*,int*

  real dimension(*), intent(in,out) :: x, y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine sswap



subroutine dswap(n,x,offx,incx,y,offy,incy)
  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,double*,int*,double*,int*

  double precision dimension(*), intent(in,out) :: x, y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine dswap



subroutine cswap(n,x,offx,incx,y,offy,incy)
  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_float*,int*,complex_float*,int*

  complex dimension(*), intent(in,out) :: x, y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine cswap



subroutine zswap(n,x,offx,incx,y,offy,incy)
  ! Swap two arrays: x __l1 y

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*), intent(in,out) :: x, y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zswap




subroutine sscal(n,a,x,offx,incx)
  ! Computes the product of a vector by a scalar: y = a*x

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,float*,float*,int*

  real intent(in):: a
  real dimension(*), intent(in,out) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine sscal



subroutine dscal(n,a,x,offx,incx)
  ! Computes the product of a vector by a scalar: y = a*x

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,double*,double*,int*

  double precision intent(in):: a
  double precision dimension(*), intent(in,out) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine dscal



subroutine cscal(n,a,x,offx,incx)
  ! Computes the product of a vector by a scalar: y = a*x

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,complex_float*,complex_float*,int*

  complex intent(in):: a
  complex dimension(*), intent(in,out) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine cscal



subroutine zscal(n,a,x,offx,incx)
  ! Computes the product of a vector by a scalar: y = a*x

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,complex_double*,complex_double*,int*

  double complex intent(in):: a
  double complex dimension(*), intent(in,out) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine zscal




subroutine csscal(n,a,x,offx,incx)
  ! Computes the product of a vector by a scalar, scales a complex
  ! vector by a real constant
  ! y = a*x

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,float*,complex_float*,int*

  real intent(in) :: a
  complex dimension(*), intent(in,out,copy) :: x
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine csscal



subroutine zdscal(n,a,x,offx,incx)
  ! Computes the product of a vector by a scalar, scales a complex
  ! vector by a real constant
  ! y = a*x

  callstatement (*f2py_func)(&n,&a,x+offx,&incx)
  callprotoargument int*,double*,complex_double*,int*

  double precision intent(in) :: a
  double complex dimension(*), intent(in,out,copy) :: x
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end subroutine zdscal




subroutine scopy(n,x,offx,incx,y,offy,incy)
  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,float*,int*,float*,int*

  real dimension(*), intent(in) :: x
  real dimension(*), intent(in,out) :: y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine scopy



subroutine dcopy(n,x,offx,incx,y,offy,incy)
  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,double*,int*,double*,int*

  double precision dimension(*), intent(in) :: x
  double precision dimension(*), intent(in,out) :: y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine dcopy



subroutine ccopy(n,x,offx,incx,y,offy,incy)
  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_float*,int*,complex_float*,int*

  complex dimension(*), intent(in) :: x
  complex dimension(*), intent(in,out) :: y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine ccopy



subroutine zcopy(n,x,offx,incx,y,offy,incy)
  ! Copy y <- x

  callstatement (*f2py_func)(&n,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*), intent(in) :: x
  double complex dimension(*), intent(in,out) :: y
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zcopy




subroutine saxpy(n,a,x,offx,incx,y,offy,incy)
  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,float*,float*,int*,float*,int*

  real dimension(*), intent(in) :: x
  real dimension(*), intent(in,out,out=z) :: y
  real optional, intent(in):: a=1.0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine saxpy



subroutine daxpy(n,a,x,offx,incx,y,offy,incy)
  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,double*,double*,int*,double*,int*

  double precision dimension(*), intent(in) :: x
  double precision dimension(*), intent(in,out,out=z) :: y
  double precision optional, intent(in):: a=1.0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine daxpy



subroutine caxpy(n,a,x,offx,incx,y,offy,incy)
  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_float*,complex_float*,int*,complex_float*,int*

  complex dimension(*), intent(in) :: x
  complex dimension(*), intent(in,out,out=z) :: y
  complex optional, intent(in):: a=(1.0,0.0)
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine caxpy



subroutine zaxpy(n,a,x,offx,incx,y,offy,incy)
  ! Calculate z = a*x+y, where a is scalar.

  callstatement (*f2py_func)(&n,&a,x+offx,&incx,y+offy,&incy)
  callprotoargument int*,complex_double*,complex_double*,int*,complex_double*,int*

  double complex dimension(*), intent(in) :: x
  double complex dimension(*), intent(in,out,out=z) :: y
  double complex optional, intent(in):: a=(1.0,0.0)
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end subroutine zaxpy




function sdot(n,x,offx,incx,y,offy,incy) result (xy)
  ! Computes a vector-vector dot product.

  fortranname sdot

  callstatement (*f2py_func)(&sdot,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument float*,int*,float*,int*,float*,int*

  real dimension(*), intent(in) :: x
  real dimension(*), intent(in) :: y
  real sdot,xy
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function sdot


function ddot(n,x,offx,incx,y,offy,incy) result (xy)
  ! Computes a vector-vector dot product.

  callstatement (*f2py_func)(&ddot,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument double*,int*,double*,int*,double*,int*

  double precision dimension(*), intent(in) :: x
  double precision dimension(*), intent(in) :: y
  double precision ddot,xy
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer optional, intent(in),depend(x) :: offx=0
  integer optional, intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy
  integer optional, intent(in),depend(x,incx,offx,y,incy,offy) :: &
       n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function ddot


function cdotu(n,x,offx,incx,y,offy,incy) result(xy)

  complex :: cdotu, xy
  fortranname wcdotu

  callstatement (*f2py_func)(&cdotu,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_float*,int*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x
  complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) &
       :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function cdotu



function zdotu(n,x,offx,incx,y,offy,incy) result(xy)

  double complex :: zdotu, xy
  fortranname wzdotu

  callstatement (*f2py_func)(&zdotu,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_double*,int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x
  double complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) &
       :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function zdotu




function cdotc(n,x,offx,incx,y,offy,incy) result(xy)

  complex :: cdotc, xy
  fortranname wcdotc

  callstatement (*f2py_func)(&cdotc,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_float*,int*,complex_float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x
  complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function cdotc



function zdotc(n,x,offx,incx,y,offy,incy) result(xy)

  double complex :: zdotc, xy
  fortranname wzdotc

  callstatement (*f2py_func)(&zdotc,&n,x+offx,&incx,y+offy,&incy)
  callprotoargument complex_double*,int*,complex_double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x
  double complex dimension(*),intent(in) :: y

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1

  integer optional,intent(in),depend(x) :: offx=0
  integer optional,intent(in),depend(y) :: offy=0
  check(offx>=0 && offx<len(x)) :: offx
  check(offy>=0 && offy<len(y)) :: offy

  integer optional,intent(in),depend(x,incx,offx,y,incy,offy) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n
  check(len(y)-offy>(n-1)*abs(incy)) :: n

end function zdotc




function snrm2(n,x,offx,incx) result(n2)

  real snrm2, n2

  callstatement (*f2py_func)(&snrm2, &n,x+offx,&incx)
  callprotoargument float*,int*,float*,int*

  real dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function snrm2



function scnrm2(n,x,offx,incx) result(n2)

  real scnrm2, n2

  callstatement (*f2py_func)(&scnrm2, &n,x+offx,&incx)
  callprotoargument float*,int*,complex_float*,int*

  complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function scnrm2




function dnrm2(n,x,offx,incx) result(n2)

  double precision dnrm2, n2

  callstatement (*f2py_func)(&dnrm2, &n,x+offx,&incx)
  callprotoargument double*,int*,double*,int*

  double precision dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dnrm2



function dznrm2(n,x,offx,incx) result(n2)

  double precision dznrm2, n2

  callstatement (*f2py_func)(&dznrm2, &n,x+offx,&incx)
  callprotoargument double*,int*,complex_double*,int*

  double complex dimension(*),intent(in) :: x

  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1

  integer optional,intent(in),depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  integer optional,intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dznrm2




function sasum(n,x,offx,incx) result (s)
  ! Computes the sum of magnitudes of the vector elements

  callstatement (*f2py_func)(&sasum,&n,x+offx,&incx)
  callprotoargument float*,int*,float*,int*

  real dimension(*), intent(in) :: x
  real sasum,s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function sasum



function scasum(n,x,offx,incx) result (s)
  ! Computes the sum of magnitudes of the vector elements

  callstatement (*f2py_func)(&scasum,&n,x+offx,&incx)
  callprotoargument float*,int*,complex_float*,int*

  complex dimension(*), intent(in) :: x
  real scasum,s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function scasum




function dasum(n,x,offx,incx) result (s)
  ! Computes the sum of magnitudes of the vector elements

  callstatement (*f2py_func)(&dasum,&n,x+offx,&incx)
  callprotoargument double*,int*,double*,int*

  double precision dimension(*), intent(in) :: x
  double precision dasum,s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dasum



function dzasum(n,x,offx,incx) result (s)
  ! Computes the sum of magnitudes of the vector elements

  callstatement (*f2py_func)(&dzasum,&n,x+offx,&incx)
  callprotoargument double*,int*,complex_double*,int*

  double complex dimension(*), intent(in) :: x
  double precision dzasum,s
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function dzasum




function isamax(n,x,offx,incx) result(k)
  ! Finds the index of the element with maximum absolute value.

  callstatement isamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,float*,int*

  ! This is to avoid Fortran wrappers.
  integer isamax,k
  fortranname F_FUNC(isamax,ISAMAX)
  intent(c) isamax
  real dimension(*), intent(in) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function isamax



function idamax(n,x,offx,incx) result(k)
  ! Finds the index of the element with maximum absolute value.

  callstatement idamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,double*,int*

  ! This is to avoid Fortran wrappers.
  integer idamax,k
  fortranname F_FUNC(idamax,IDAMAX)
  intent(c) idamax
  double precision dimension(*), intent(in) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function idamax



function icamax(n,x,offx,incx) result(k)
  ! Finds the index of the element with maximum absolute value.

  callstatement icamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,complex_float*,int*

  ! This is to avoid Fortran wrappers.
  integer icamax,k
  fortranname F_FUNC(icamax,ICAMAX)
  intent(c) icamax
  complex dimension(*), intent(in) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function icamax



function izamax(n,x,offx,incx) result(k)
  ! Finds the index of the element with maximum absolute value.

  callstatement izamax_return_value = (*f2py_func)(&n,x+offx,&incx) - 1
  callprotoargument int*,complex_double*,int*

  ! This is to avoid Fortran wrappers.
  integer izamax,k
  fortranname F_FUNC(izamax,IZAMAX)
  intent(c) izamax
  double complex dimension(*), intent(in) :: x
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx
  integer optional, intent(in),depend(x,incx,offx) :: n = (len(x)-offx)/abs(incx)
  check(len(x)-offx>(n-1)*abs(incx)) :: n

end function izamax



! -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN LEVEL 2 BLAS functions.
!
! Author: Pearu Peterson
! Created: Jan-Feb 2002
! Modified: Fabian Pedregosa, 2011; Eric Moore, 2014
!
! Implemented:
!   gemv, hemv, symv, trmv, ger, geru, gerc, her, syr, hpr, spr, her2, syr2,
!   spmv, hpmv, hbmv, sbmv, hpr2, spr2, gbmv, trsv, tbmv, tpmv, tbsv, tpsv
!
!
! Level 2 BLAS
!


subroutine sgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! Computes a matrix-vector product using a general matrix
  !
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m, &
       x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,float*,float*,int*,float*,int*,float*, &
       float*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  real intent(in) :: alpha
  real intent(in), optional :: beta = 0.0

  real dimension(*), intent(in) :: x
  real dimension(ly), intent(in,copy,out), depend(ly),optional :: y
  integer intent(hide), depend(incy,rows,offy) :: ly = &
       (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  real dimension(m,n), intent(in) :: a
  integer depend(a), intent(hide):: m = shape(a,0)
  integer depend(a), intent(hide):: n = shape(a,1)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans), intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans), intent(hide) :: cols = (trans?m:n)

end subroutine sgemv



subroutine dgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! Computes a matrix-vector product using a general matrix
  !
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m, &
       x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,double*,double*,int*,double*,int*,double*, &
       double*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  double precision intent(in) :: alpha
  double precision intent(in), optional :: beta = 0.0

  double precision dimension(*), intent(in) :: x
  double precision dimension(ly), intent(in,copy,out), depend(ly),optional :: y
  integer intent(hide), depend(incy,rows,offy) :: ly = &
       (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  double precision dimension(m,n), intent(in) :: a
  integer depend(a), intent(hide):: m = shape(a,0)
  integer depend(a), intent(hide):: n = shape(a,1)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans), intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans), intent(hide) :: cols = (trans?m:n)

end subroutine dgemv



subroutine cgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! Computes a matrix-vector product using a general matrix
  !
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m, &
       x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*, &
       complex_float*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  complex intent(in) :: alpha
  complex intent(in), optional :: beta = (0.0,0.0)

  complex dimension(*), intent(in) :: x
  complex dimension(ly), intent(in,copy,out), depend(ly),optional :: y
  integer intent(hide), depend(incy,rows,offy) :: ly = &
       (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  complex dimension(m,n), intent(in) :: a
  integer depend(a), intent(hide):: m = shape(a,0)
  integer depend(a), intent(hide):: n = shape(a,1)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans), intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans), intent(hide) :: cols = (trans?m:n)

end subroutine cgemv



subroutine zgemv(m,n,alpha,a,x,beta,y,offx,incx,offy,incy,trans,rows,cols,ly)
  ! Computes a matrix-vector product using a general matrix
  !
  ! y = gemv(alpha,a,x,beta=0,y=0,offx=0,incx=1,offy=0,incy=0,trans=0)
  ! Calculate y <- alpha * op(A) * x + beta * y

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&alpha,a,&m, &
       x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*, &
       complex_double*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in), check(incy>0||incy<0) :: incy = 1
  double complex intent(in) :: alpha
  double complex intent(in), optional :: beta = (0.0,0.0)

  double complex dimension(*), intent(in) :: x
  double complex dimension(ly), intent(in,copy,out), depend(ly),optional :: y
  integer intent(hide), depend(incy,rows,offy) :: ly = &
       (y_capi==Py_None?1+offy+(rows-1)*abs(incy):-1)
  double complex dimension(m,n), intent(in) :: a
  integer depend(a), intent(hide):: m = shape(a,0)
  integer depend(a), intent(hide):: n = shape(a,1)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(cols-1)*abs(incx)) :: x
  depend(offx,cols,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(rows-1)*abs(incy)) :: y
  depend(offy,rows,incy) :: y

  integer depend(m,n,trans), intent(hide) :: rows = (trans?n:m)
  integer depend(m,n,trans), intent(hide) :: cols = (trans?m:n)

end subroutine zgemv




subroutine sgbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans,ly)
  ! Performs one of the matrix-vector operations
  !
  !    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
  !                               or   y := alpha*A**H*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are vectors and A is an
  ! m by n band matrix, with kl sub-diagonals and ku super-diagonals.

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&kl,&ku,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,int*,int*,float*,float*,int*,float*,int*,float*,float*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer intent(in), depend(ku,kl),check(m>=ku+kl+1) :: m
  integer intent(in),check(n>=0&&n==shape(a,1)),depend(a) :: n
  integer intent(in),check(kl>=0) :: kl
  integer intent(in),check(ku>=0) :: ku
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(m,n,incy,offy,trans) :: ly = &
      (y_capi==Py_None?1+offy+(trans==0?m-1:n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda,n),intent(in) :: a

  real dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(trans==0?m-1:n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  real dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(trans==0?m-1:n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine sgbmv



subroutine dgbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans,ly)
  ! Performs one of the matrix-vector operations
  !
  !    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
  !                               or   y := alpha*A**H*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are vectors and A is an
  ! m by n band matrix, with kl sub-diagonals and ku super-diagonals.

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&kl,&ku,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,int*,int*,double*,double*,int*,double*,int*,double*,double*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer intent(in), depend(ku,kl),check(m>=ku+kl+1) :: m
  integer intent(in),check(n>=0&&n==shape(a,1)),depend(a) :: n
  integer intent(in),check(kl>=0) :: kl
  integer intent(in),check(ku>=0) :: ku
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(m,n,incy,offy,trans) :: ly = &
      (y_capi==Py_None?1+offy+(trans==0?m-1:n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda,n),intent(in) :: a

  double precision dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(trans==0?m-1:n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double precision dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(trans==0?m-1:n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dgbmv



subroutine cgbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans,ly)
  ! Performs one of the matrix-vector operations
  !
  !    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
  !                               or   y := alpha*A**H*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are vectors and A is an
  ! m by n band matrix, with kl sub-diagonals and ku super-diagonals.

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&kl,&ku,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer intent(in), depend(ku,kl),check(m>=ku+kl+1) :: m
  integer intent(in),check(n>=0&&n==shape(a,1)),depend(a) :: n
  integer intent(in),check(kl>=0) :: kl
  integer intent(in),check(ku>=0) :: ku
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(m,n,incy,offy,trans) :: ly = &
      (y_capi==Py_None?1+offy+(trans==0?m-1:n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,n),intent(in) :: a

  complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(trans==0?m-1:n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(trans==0?m-1:n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine cgbmv



subroutine zgbmv(m,n,kl,ku,alpha,a,lda,x,incx,offx,beta,y,incy,offy,trans,ly)
  ! Performs one of the matrix-vector operations
  !
  !    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
  !                               or   y := alpha*A**H*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are vectors and A is an
  ! m by n band matrix, with kl sub-diagonals and ku super-diagonals.

  callstatement (*f2py_func)((trans?(trans==2?"C":"T"):"N"),&m,&n,&kl,&ku,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0
  integer intent(in), depend(ku,kl),check(m>=ku+kl+1) :: m
  integer intent(in),check(n>=0&&n==shape(a,1)),depend(a) :: n
  integer intent(in),check(kl>=0) :: kl
  integer intent(in),check(ku>=0) :: ku
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(m,n,incy,offy,trans) :: ly = &
      (y_capi==Py_None?1+offy+(trans==0?m-1:n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,n),intent(in) :: a

  double complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(trans==0?m-1:n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(trans==0?m-1:n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine zgbmv




subroutine ssbmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Performs the matrix-vector operation
  !
  !  y := alpha*A*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are n element vectors and
  ! A is an n by n symmetric band matrix, with k super-diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&k,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,float*,float*,int*,float*,int*,float*,float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda,n),intent(in) :: a

  real dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  real dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ssbmv



subroutine dsbmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Performs the matrix-vector operation
  !
  !  y := alpha*A*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are n element vectors and
  ! A is an n by n symmetric band matrix, with k super-diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&k,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,double*,double*,int*,double*,int*,double*,double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda,n),intent(in) :: a

  double precision dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double precision dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dsbmv



subroutine chbmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Performs the matrix-vector operation
  !
  !  y := alpha*A*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are n element vectors and
  ! A is an n by n symmetric band matrix, with k super-diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&k,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,n),intent(in) :: a

  complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine chbmv



subroutine zhbmv(n,k,alpha,a,lda,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Performs the matrix-vector operation
  !
  !  y := alpha*A*x + beta*y,
  !
  ! where alpha and beta are scalars, x and y are n element vectors and
  ! A is an n by n symmetric band matrix, with k super-diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&k,&alpha,a,&lda,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(hide),depend(a),check(n>=0) :: n = shape(a,1)
  integer intent(hide),depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,n),intent(in) :: a

  double complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine zhbmv




subroutine sspmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Computes a matrix-vector product for a symmetric matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,float*,float*,float*,int*,float*,float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(in),check(n>=0) :: n
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  real dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  real dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine sspmv



subroutine dspmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Computes a matrix-vector product for a symmetric matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,double*,double*,double*,int*,double*,double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(in),check(n>=0) :: n
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double precision dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double precision dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dspmv



subroutine cspmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Computes a matrix-vector product for a symmetric matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,complex_float*,complex_float*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(in),check(n>=0) :: n
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine cspmv



subroutine zspmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Computes a matrix-vector product for a symmetric matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,complex_double*,complex_double*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(in),check(n>=0) :: n
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine zspmv



subroutine chpmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Computes a matrix-vector product for a symmetric matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,complex_float*,complex_float*,complex_float*,int*,complex_float*,complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(in),check(n>=0) :: n
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine chpmv



subroutine zhpmv(n,alpha,ap,x,incx,offx,beta,y,incy,offy,lower,ly)
  ! Computes a matrix-vector product for a symmetric matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,ap,x+offx,&incx,&beta,y+offy,&incy)
  callprotoargument char*,int*,complex_double*,complex_double*,complex_double*,int*,complex_double*,complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer intent(in),check(n>=0) :: n
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  integer intent(hide),depend(incy,n,offy) :: ly = (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double complex dimension(ly), intent(in,out,copy,out=yout),depend(ly),optional :: y
  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

  double complex dimension(*), intent(in) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine zhpmv




subroutine ssymv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Computes a matrix-vector product for a symmetric/hermitian matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta, &
       y+offy,&incy)
  callprotoargument char*,int*,float*,float*,int*,float*,int*,float*, &
       float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(*), intent(in) :: x
  real dimension(ly), intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = &
       (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  real dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  ssymv



subroutine dsymv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Computes a matrix-vector product for a symmetric/hermitian matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta, &
       y+offy,&incy)
  callprotoargument char*,int*,double*,double*,int*,double*,int*,double*, &
       double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(*), intent(in) :: x
  double precision dimension(ly), intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = &
       (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  double precision dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  dsymv



subroutine chemv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Computes a matrix-vector product for a symmetric/hermitian matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta, &
       y+offy,&incy)
  callprotoargument char*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*, &
       complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(*), intent(in) :: x
  complex dimension(ly), intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = &
       (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  complex dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  chemv



subroutine zhemv(n,alpha,a,x,beta,y,offx,incx,offy,incy,lower,ly)
  ! Computes a matrix-vector product for a symmetric/hermitian matrix
  !
  ! Calculate y <- alpha * A * x + beta * y, A is symmmetric/hermitian

  callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,a,&n,x+offx,&incx,&beta, &
       y+offy,&incy)
  callprotoargument char*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*, &
       complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in),check(incx>0||incx<0) :: incx = 1
  integer optional, intent(in),check(incy>0||incy<0) :: incy = 1
  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(*), intent(in) :: x
  double complex dimension(ly), intent(in,copy,out),depend(ly),optional :: y
  integer intent(hide),depend(incy,n,offy) :: ly = &
       (y_capi==Py_None?1+offy+(n-1)*abs(incy):-1)
  double complex dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in) :: offx=0
  integer optional, intent(in) :: offy=0
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

  check(offy>=0 && offy<len(y)) :: y
  check(len(y)>offy+(n-1)*abs(incy)) :: y
  depend(offy,n,incy) :: y

end subroutine  zhemv




subroutine sger(m,n,alpha,x,incx,y,incy,a,lda)
  ! Performs a rank-1 update of a general matrix.
  !
  ! Calculate a <- alpha*x*y^T + a
  ! Calculate a <- alpha*x*y^H + a
  !

  integer intent(hide),depend(x) :: m = len(x)
  integer intent(hide),depend(y) :: n = len(y)

  real intent(in) :: alpha
  real dimension(m), intent(in,overwrite) :: x
  integer optional, intent(in),check(incx==1||incx==-1) :: incx = 1
  real dimension(n), intent(in,overwrite) :: y
  integer optional, intent(in),check(incy==1||incy==-1) :: incy = 1
  real dimension(m,n), intent(in,out,copy),optional :: &
       a = 0.0
  integer intent(hide), depend(m) :: lda=m

end subroutine sger



subroutine dger(m,n,alpha,x,incx,y,incy,a,lda)
  ! Performs a rank-1 update of a general matrix.
  !
  ! Calculate a <- alpha*x*y^T + a
  ! Calculate a <- alpha*x*y^H + a
  !

  integer intent(hide),depend(x) :: m = len(x)
  integer intent(hide),depend(y) :: n = len(y)

  double precision intent(in) :: alpha
  double precision dimension(m), intent(in,overwrite) :: x
  integer optional, intent(in),check(incx==1||incx==-1) :: incx = 1
  double precision dimension(n), intent(in,overwrite) :: y
  integer optional, intent(in),check(incy==1||incy==-1) :: incy = 1
  double precision dimension(m,n), intent(in,out,copy),optional :: &
       a = 0.0
  integer intent(hide), depend(m) :: lda=m

end subroutine dger



subroutine cgeru(m,n,alpha,x,incx,y,incy,a,lda)
  ! Performs a rank-1 update of a general matrix.
  !
  ! Calculate a <- alpha*x*y^T + a
  ! Calculate a <- alpha*x*y^H + a
  !

  integer intent(hide),depend(x) :: m = len(x)
  integer intent(hide),depend(y) :: n = len(y)

  complex intent(in) :: alpha
  complex dimension(m), intent(in,overwrite) :: x
  integer optional, intent(in),check(incx==1||incx==-1) :: incx = 1
  complex dimension(n), intent(in,overwrite) :: y
  integer optional, intent(in),check(incy==1||incy==-1) :: incy = 1
  complex dimension(m,n), intent(in,out,copy),optional :: &
       a = (0.0,0.0)
  integer intent(hide), depend(m) :: lda=m

end subroutine cgeru



subroutine zgeru(m,n,alpha,x,incx,y,incy,a,lda)
  ! Performs a rank-1 update of a general matrix.
  !
  ! Calculate a <- alpha*x*y^T + a
  ! Calculate a <- alpha*x*y^H + a
  !

  integer intent(hide),depend(x) :: m = len(x)
  integer intent(hide),depend(y) :: n = len(y)

  double complex intent(in) :: alpha
  double complex dimension(m), intent(in,overwrite) :: x
  integer optional, intent(in),check(incx==1||incx==-1) :: incx = 1
  double complex dimension(n), intent(in,overwrite) :: y
  integer optional, intent(in),check(incy==1||incy==-1) :: incy = 1
  double complex dimension(m,n), intent(in,out,copy),optional :: &
       a = (0.0,0.0)
  integer intent(hide), depend(m) :: lda=m

end subroutine zgeru



subroutine cgerc(m,n,alpha,x,incx,y,incy,a,lda)
  ! Performs a rank-1 update of a general matrix.
  !
  ! Calculate a <- alpha*x*y^T + a
  ! Calculate a <- alpha*x*y^H + a
  !

  integer intent(hide),depend(x) :: m = len(x)
  integer intent(hide),depend(y) :: n = len(y)

  complex intent(in) :: alpha
  complex dimension(m), intent(in,overwrite) :: x
  integer optional, intent(in),check(incx==1||incx==-1) :: incx = 1
  complex dimension(n), intent(in,overwrite) :: y
  integer optional, intent(in),check(incy==1||incy==-1) :: incy = 1
  complex dimension(m,n), intent(in,out,copy),optional :: &
       a = (0.0,0.0)
  integer intent(hide), depend(m) :: lda=m

end subroutine cgerc



subroutine zgerc(m,n,alpha,x,incx,y,incy,a,lda)
  ! Performs a rank-1 update of a general matrix.
  !
  ! Calculate a <- alpha*x*y^T + a
  ! Calculate a <- alpha*x*y^H + a
  !

  integer intent(hide),depend(x) :: m = len(x)
  integer intent(hide),depend(y) :: n = len(y)

  double complex intent(in) :: alpha
  double complex dimension(m), intent(in,overwrite) :: x
  integer optional, intent(in),check(incx==1||incx==-1) :: incx = 1
  double complex dimension(n), intent(in,overwrite) :: y
  integer optional, intent(in),check(incy==1||incy==-1) :: incy = 1
  double complex dimension(m,n), intent(in,out,copy),optional :: &
       a = (0.0,0.0)
  integer intent(hide), depend(m) :: lda=m

end subroutine zgerc




subroutine ssyr(alpha,x,lower,incx,offx,n,a)
  ! Performs a rank-1 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*x^T + a
  ! Calculate a <- alpha*x*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
    callprotoargument char*, int*, float*, float*, int*, float*, int*

    integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
    real intent(in) :: alpha

    real dimension(*), depend(offx) :: x
    check(offx >= 0 && offx < len(x)) :: x
    integer, intent(in), optional :: offx = 0
    integer, intent(in), optional, check(incx>0||incx<0) :: incx = 1

    integer, intent(in), optional :: n = (len(x)-1-offx)/abs(incx)+1
    check(n >= 0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    depend(x, offx, incx) :: n

    real dimension(n,n), intent(in,copy,out), optional :: a
    depend(x, offx, incx, n) :: a

end subroutine ssyr



subroutine dsyr(alpha,x,lower,incx,offx,n,a)
  ! Performs a rank-1 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*x^T + a
  ! Calculate a <- alpha*x*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
    callprotoargument char*, int*, double*, double*, int*, double*, int*

    integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
    double precision intent(in) :: alpha

    double precision dimension(*), depend(offx) :: x
    check(offx >= 0 && offx < len(x)) :: x
    integer, intent(in), optional :: offx = 0
    integer, intent(in), optional, check(incx>0||incx<0) :: incx = 1

    integer, intent(in), optional :: n = (len(x)-1-offx)/abs(incx)+1
    check(n >= 0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    depend(x, offx, incx) :: n

    double precision dimension(n,n), intent(in,copy,out), optional :: a
    depend(x, offx, incx, n) :: a

end subroutine dsyr



subroutine csyr(alpha,x,lower,incx,offx,n,a)
  ! Performs a rank-1 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*x^T + a
  ! Calculate a <- alpha*x*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
    callprotoargument char*, int*, complex_float*, complex_float*, int*, complex_float*, int*

    integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
    complex intent(in) :: alpha

    complex dimension(*), depend(offx) :: x
    check(offx >= 0 && offx < len(x)) :: x
    integer, intent(in), optional :: offx = 0
    integer, intent(in), optional, check(incx>0||incx<0) :: incx = 1

    integer, intent(in), optional :: n = (len(x)-1-offx)/abs(incx)+1
    check(n >= 0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    depend(x, offx, incx) :: n

    complex dimension(n,n), intent(in,copy,out), optional :: a
    depend(x, offx, incx, n) :: a

end subroutine csyr



subroutine zsyr(alpha,x,lower,incx,offx,n,a)
  ! Performs a rank-1 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*x^T + a
  ! Calculate a <- alpha*x*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
    callprotoargument char*, int*, complex_double*, complex_double*, int*, complex_double*, int*

    integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
    double complex intent(in) :: alpha

    double complex dimension(*), depend(offx) :: x
    check(offx >= 0 && offx < len(x)) :: x
    integer, intent(in), optional :: offx = 0
    integer, intent(in), optional, check(incx>0||incx<0) :: incx = 1

    integer, intent(in), optional :: n = (len(x)-1-offx)/abs(incx)+1
    check(n >= 0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    depend(x, offx, incx) :: n

    double complex dimension(n,n), intent(in,copy,out), optional :: a
    depend(x, offx, incx, n) :: a

end subroutine zsyr



subroutine cher(alpha,x,lower,incx,offx,n,a)
  ! Performs a rank-1 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*x^T + a
  ! Calculate a <- alpha*x*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
    callprotoargument char*, int*, complex_float*, complex_float*, int*, complex_float*, int*

    integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
    complex intent(in) :: alpha

    complex dimension(*), depend(offx) :: x
    check(offx >= 0 && offx < len(x)) :: x
    integer, intent(in), optional :: offx = 0
    integer, intent(in), optional, check(incx>0||incx<0) :: incx = 1

    integer, intent(in), optional :: n = (len(x)-1-offx)/abs(incx)+1
    check(n >= 0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    depend(x, offx, incx) :: n

    complex dimension(n,n), intent(in,copy,out), optional :: a
    depend(x, offx, incx, n) :: a

end subroutine cher



subroutine zher(alpha,x,lower,incx,offx,n,a)
  ! Performs a rank-1 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*x^T + a
  ! Calculate a <- alpha*x*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,a,&n)
    callprotoargument char*, int*, complex_double*, complex_double*, int*, complex_double*, int*

    integer, optional, intent(in), check(lower == 0 || lower == 1) :: lower = 0
    double complex intent(in) :: alpha

    double complex dimension(*), depend(offx) :: x
    check(offx >= 0 && offx < len(x)) :: x
    integer, intent(in), optional :: offx = 0
    integer, intent(in), optional, check(incx>0||incx<0) :: incx = 1

    integer, intent(in), optional :: n = (len(x)-1-offx)/abs(incx)+1
    check(n >= 0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    depend(x, offx, incx) :: n

    double complex dimension(n,n), intent(in,copy,out), optional :: a
    depend(x, offx, incx, n) :: a

end subroutine zher




subroutine ssyr2(alpha,x,y,lower,incx,offx,incy,offy,n,a)
  ! Performs a rank-2 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*y^T + alpha*y*x^T + a
  ! Calculate a <- alpha*x*y^H + alpha*y*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,a,&n)
    callprotoargument char*, int*, float*, float*, int*, float*, int*, float*, int*

    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    real intent(in) :: alpha
    real dimension(*), intent(in), check(offx >= 0 && offx < len(x)), depend(offx) :: x
    real dimension(*), intent(in), check(offy >= 0 && offy < len(y)), depend(offy) :: y
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offy = 0

    integer intent(in), optional :: n = ((len(x)-1-offx)/abs(incx)+1 <= (len(y)-1-offy)/abs(incy)+1 ? (len(x)-1-offx)/abs(incx)+1 : (len(y)-1-offy)/abs(incy)+1)
    depend(x,incx,offx,y,incy,offy) :: n
    check(n>=0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    check(n <= (len(y)-1-offy)/abs(incy)+1) :: n

    real dimension(n,n), intent(in,copy,out), optional :: a
    depend(incx, offx, x, incy, offy, y, n) :: a
end subroutine ssyr2



subroutine dsyr2(alpha,x,y,lower,incx,offx,incy,offy,n,a)
  ! Performs a rank-2 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*y^T + alpha*y*x^T + a
  ! Calculate a <- alpha*x*y^H + alpha*y*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,a,&n)
    callprotoargument char*, int*, double*, double*, int*, double*, int*, double*, int*

    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    double precision intent(in) :: alpha
    double precision dimension(*), intent(in), check(offx >= 0 && offx < len(x)), depend(offx) :: x
    double precision dimension(*), intent(in), check(offy >= 0 && offy < len(y)), depend(offy) :: y
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offy = 0

    integer intent(in), optional :: n = ((len(x)-1-offx)/abs(incx)+1 <= (len(y)-1-offy)/abs(incy)+1 ? (len(x)-1-offx)/abs(incx)+1 : (len(y)-1-offy)/abs(incy)+1)
    depend(x,incx,offx,y,incy,offy) :: n
    check(n>=0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    check(n <= (len(y)-1-offy)/abs(incy)+1) :: n

    double precision dimension(n,n), intent(in,copy,out), optional :: a
    depend(incx, offx, x, incy, offy, y, n) :: a
end subroutine dsyr2



subroutine cher2(alpha,x,y,lower,incx,offx,incy,offy,n,a)
  ! Performs a rank-2 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*y^T + alpha*y*x^T + a
  ! Calculate a <- alpha*x*y^H + alpha*y*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,a,&n)
    callprotoargument char*, int*, complex_float*, complex_float*, int*, complex_float*, int*, complex_float*, int*

    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    complex intent(in) :: alpha
    complex dimension(*), intent(in), check(offx >= 0 && offx < len(x)), depend(offx) :: x
    complex dimension(*), intent(in), check(offy >= 0 && offy < len(y)), depend(offy) :: y
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offy = 0

    integer intent(in), optional :: n = ((len(x)-1-offx)/abs(incx)+1 <= (len(y)-1-offy)/abs(incy)+1 ? (len(x)-1-offx)/abs(incx)+1 : (len(y)-1-offy)/abs(incy)+1)
    depend(x,incx,offx,y,incy,offy) :: n
    check(n>=0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    check(n <= (len(y)-1-offy)/abs(incy)+1) :: n

    complex dimension(n,n), intent(in,copy,out), optional :: a
    depend(incx, offx, x, incy, offy, y, n) :: a
end subroutine cher2



subroutine zher2(alpha,x,y,lower,incx,offx,incy,offy,n,a)
  ! Performs a rank-2 update of a symmetric/hermitian matrix.
  !
  ! Calculate a <- alpha*x*y^T + alpha*y*x^T + a
  ! Calculate a <- alpha*x*y^H + alpha*y*x^H + a
  !
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,a,&n)
    callprotoargument char*, int*, complex_double*, complex_double*, int*, complex_double*, int*, complex_double*, int*

    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    double complex intent(in) :: alpha
    double complex dimension(*), intent(in), check(offx >= 0 && offx < len(x)), depend(offx) :: x
    double complex dimension(*), intent(in), check(offy >= 0 && offy < len(y)), depend(offy) :: y
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offy = 0

    integer intent(in), optional :: n = ((len(x)-1-offx)/abs(incx)+1 <= (len(y)-1-offy)/abs(incy)+1 ? (len(x)-1-offx)/abs(incx)+1 : (len(y)-1-offy)/abs(incy)+1)
    depend(x,incx,offx,y,incy,offy) :: n
    check(n>=0) :: n
    check(n <= (len(x)-1-offx)/abs(incx)+1) :: n
    check(n <= (len(y)-1-offy)/abs(incy)+1) :: n

    double complex dimension(n,n), intent(in,copy,out), optional :: a
    depend(incx, offx, x, incy, offy, y, n) :: a
end subroutine zher2




subroutine sspr(n,alpha,x,incx,offx,ap,lower)
  ! Performs the symmetric rank 1 operation
  !
  !       A := alpha*x*x**T(H) + A,
  !
  ! where alpha is a scalar, x is an n element vector and A is an n x n
  ! symmetric/hermitian matrix, supplied in packed form.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
    callprotoargument char*,int*,float*,float*,int*,float*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    real intent(in) :: alpha

    real dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    real dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutine sspr



subroutine dspr(n,alpha,x,incx,offx,ap,lower)
  ! Performs the symmetric rank 1 operation
  !
  !       A := alpha*x*x**T(H) + A,
  !
  ! where alpha is a scalar, x is an n element vector and A is an n x n
  ! symmetric/hermitian matrix, supplied in packed form.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
    callprotoargument char*,int*,double*,double*,int*,double*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    double precision intent(in) :: alpha

    double precision dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    double precision dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutine dspr



subroutine cspr(n,alpha,x,incx,offx,ap,lower)
  ! Performs the symmetric rank 1 operation
  !
  !       A := alpha*x*x**T(H) + A,
  !
  ! where alpha is a scalar, x is an n element vector and A is an n x n
  ! symmetric/hermitian matrix, supplied in packed form.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
    callprotoargument char*,int*,complex_float*,complex_float*,int*,complex_float*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    complex intent(in) :: alpha

    complex dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    complex dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutine cspr



subroutine zspr(n,alpha,x,incx,offx,ap,lower)
  ! Performs the symmetric rank 1 operation
  !
  !       A := alpha*x*x**T(H) + A,
  !
  ! where alpha is a scalar, x is an n element vector and A is an n x n
  ! symmetric/hermitian matrix, supplied in packed form.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
    callprotoargument char*,int*,complex_double*,complex_double*,int*,complex_double*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    double complex intent(in) :: alpha

    double complex dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    double complex dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutine zspr



subroutine chpr(n,alpha,x,incx,offx,ap,lower)
  ! Performs the symmetric rank 1 operation
  !
  !       A := alpha*x*x**T(H) + A,
  !
  ! where alpha is a scalar, x is an n element vector and A is an n x n
  ! symmetric/hermitian matrix, supplied in packed form.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
    callprotoargument char*,int*,float*,complex_float*,int*,complex_float*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    real intent(in) :: alpha

    complex dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    complex dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutine chpr



subroutine zhpr(n,alpha,x,incx,offx,ap,lower)
  ! Performs the symmetric rank 1 operation
  !
  !       A := alpha*x*x**T(H) + A,
  !
  ! where alpha is a scalar, x is an n element vector and A is an n x n
  ! symmetric/hermitian matrix, supplied in packed form.

    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,ap)
    callprotoargument char*,int*,double*,complex_double*,int*,complex_double*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional :: offx = 0
    double precision intent(in) :: alpha

    double complex dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    double complex dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutine zhpr




subroutine sspr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower)
  ! Performs the symmetric rank 2 operation
  !
  !    A := alpha*x*y**T + alpha*y*x**T + A,
  !
  ! where alpha is a scalar, x and y are n element vectors and A is an
  ! n by n symmetric/hermitian matrix, supplied in packed form.
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,ap)
    callprotoargument char*,int*,float*,float*,int*,float*,int*,float*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional :: offy = 0
    real intent(in) :: alpha

    real dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    real dimension(*), intent(in) :: y
    check(offy>=0 && offy<len(y)) :: y
    check(len(y)>offy+(n-1)*abs(incy)) :: y
    depend(offy,n,incy) :: y

    real dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutinesspr2



subroutine dspr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower)
  ! Performs the symmetric rank 2 operation
  !
  !    A := alpha*x*y**T + alpha*y*x**T + A,
  !
  ! where alpha is a scalar, x and y are n element vectors and A is an
  ! n by n symmetric/hermitian matrix, supplied in packed form.
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,ap)
    callprotoargument char*,int*,double*,double*,int*,double*,int*,double*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional :: offy = 0
    double precision intent(in) :: alpha

    double precision dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    double precision dimension(*), intent(in) :: y
    check(offy>=0 && offy<len(y)) :: y
    check(len(y)>offy+(n-1)*abs(incy)) :: y
    depend(offy,n,incy) :: y

    double precision dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutinedspr2



subroutine chpr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower)
  ! Performs the symmetric rank 2 operation
  !
  !    A := alpha*x*y**T + alpha*y*x**T + A,
  !
  ! where alpha is a scalar, x and y are n element vectors and A is an
  ! n by n symmetric/hermitian matrix, supplied in packed form.
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,ap)
    callprotoargument char*,int*,complex_float*,complex_float*,int*,complex_float*,int*,complex_float*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional :: offy = 0
    complex intent(in) :: alpha

    complex dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    complex dimension(*), intent(in) :: y
    check(offy>=0 && offy<len(y)) :: y
    check(len(y)>offy+(n-1)*abs(incy)) :: y
    depend(offy,n,incy) :: y

    complex dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutinechpr2



subroutine zhpr2(n,alpha,x,incx,offx,y,incy,offy,ap,lower)
  ! Performs the symmetric rank 2 operation
  !
  !    A := alpha*x*y**T + alpha*y*x**T + A,
  !
  ! where alpha is a scalar, x and y are n element vectors and A is an
  ! n by n symmetric/hermitian matrix, supplied in packed form.
    callstatement (*f2py_func)((lower?"L":"U"),&n,&alpha,x+offx,&incx,y+offy,&incy,ap)
    callprotoargument char*,int*,complex_double*,complex_double*,int*,complex_double*,int*,complex_double*

    integer intent(in),check(n>=0) :: n
    integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
    integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
    integer intent(in), optional, check(incy>0||incy<0) :: incy = 1
    integer intent(in), optional :: offx = 0
    integer intent(in), optional :: offy = 0
    double complex intent(in) :: alpha

    double complex dimension(*), intent(in) :: x
    check(offx>=0 && offx<len(x)) :: x
    check(len(x)>offx+(n-1)*abs(incx)) :: x
    depend(offx,n,incx) :: x

    double complex dimension(*), intent(in) :: y
    check(offy>=0 && offy<len(y)) :: y
    check(len(y)>offy+(n-1)*abs(incy)) :: y
    depend(offy,n,incy) :: y

    double complex dimension(*),depend(n),intent(in,out,copy,out=apu) :: ap
    check(len(ap)>=(n*(n+1)/2)) :: ap

end subroutinezhpr2



subroutine stbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,float*,int*,float*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  real intent(in), dimension(lda,n) :: a

  real dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine stbsv


subroutine dtbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,double*,int*,double*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  double precision intent(in), dimension(lda,n) :: a

  double precision dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dtbsv


subroutine ctbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,complex_float*,int*,complex_float*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  complex intent(in), dimension(lda,n) :: a

  complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ctbsv


subroutine ztbsv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,complex_double*,int*,complex_double*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  double complex intent(in), dimension(lda,n) :: a

  double complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ztbsv




subroutine stpsv(n,ap,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,float*,float*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  real dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  real dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine stpsv



subroutine dtpsv(n,ap,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,double*,double*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  double precision dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double precision dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dtpsv



subroutine ctpsv(n,ap,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_float*,complex_float*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ctpsv



subroutine ztpsv(n,ap,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_double*,complex_double*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  double complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ztpsv




subroutine strmv(n,a,x,offx,incx,lower,trans,diag)
  ! Computes a matrix-vector product using a triangular matrix
  !
  ! x <- op(A) * x, A is triangular
  !

  callstatement (*f2py_func)((lower?"L":"U"), (trans?(trans==2?"C":"T"):"N"), &
       (diag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,float*,int*,float*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in), check(diag==0||diag==1) :: diag = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1

  real dimension(*), intent(in,out,copy) :: x
  real dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine strmv



subroutine dtrmv(n,a,x,offx,incx,lower,trans,diag)
  ! Computes a matrix-vector product using a triangular matrix
  !
  ! x <- op(A) * x, A is triangular
  !

  callstatement (*f2py_func)((lower?"L":"U"), (trans?(trans==2?"C":"T"):"N"), &
       (diag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,double*,int*,double*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in), check(diag==0||diag==1) :: diag = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1

  double precision dimension(*), intent(in,out,copy) :: x
  double precision dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine dtrmv



subroutine ctrmv(n,a,x,offx,incx,lower,trans,diag)
  ! Computes a matrix-vector product using a triangular matrix
  !
  ! x <- op(A) * x, A is triangular
  !

  callstatement (*f2py_func)((lower?"L":"U"), (trans?(trans==2?"C":"T"):"N"), &
       (diag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_float*,int*,complex_float*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in), check(diag==0||diag==1) :: diag = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1

  complex dimension(*), intent(in,out,copy) :: x
  complex dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine ctrmv



subroutine ztrmv(n,a,x,offx,incx,lower,trans,diag)
  ! Computes a matrix-vector product using a triangular matrix
  !
  ! x <- op(A) * x, A is triangular
  !

  callstatement (*f2py_func)((lower?"L":"U"), (trans?(trans==2?"C":"T"):"N"), &
       (diag?"U":"N"),&n,a,&n,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_double*,int*,complex_double*,int*

  integer optional, intent(in), check(trans>=0 && trans <=2) :: trans = 0
  integer optional, intent(in), check(lower==0||lower==1) :: lower = 0
  integer optional, intent(in), check(diag==0||diag==1) :: diag = 0
  integer optional, intent(in), check(incx>0||incx<0) :: incx = 1

  double complex dimension(*), intent(in,out,copy) :: x
  double complex dimension(n,n), intent(in),check(shape(a,0)==shape(a,1)) :: a
  integer depend(a), intent(hide):: n = shape(a,0)

  integer optional, intent(in), depend(x) :: offx=0
  check(offx>=0 && offx<len(x)) :: offx

  check(len(x)>offx+(n-1)*abs(incx)) :: n
  depend(x,offx,incx) :: n

end subroutine ztrmv




subroutine strsv(n,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,float*,int*,float*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,0)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in), optional :: offx = 0

  real intent(in), dimension(n,n), check(shape(a,0)==shape(a,1)) :: a

  real dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine strsv



subroutine dtrsv(n,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,double*,int*,double*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,0)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in), optional :: offx = 0

  double precision intent(in), dimension(n,n), check(shape(a,0)==shape(a,1)) :: a

  double precision dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dtrsv



subroutine ctrsv(n,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_float*,int*,complex_float*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,0)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in), optional :: offx = 0

  complex intent(in), dimension(n,n), check(shape(a,0)==shape(a,1)) :: a

  complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ctrsv



subroutine ztrsv(n,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix.
  !
  ! No test for singularity or near-singularity is included in this
  ! routine. Such tests must be performed before calling this routine.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_double*,int*,complex_double*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,0)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in), optional :: offx = 0

  double complex intent(in), dimension(n,n), check(shape(a,0)==shape(a,1)) :: a

  double complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ztrsv




subroutine stbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are an n element vector and  A is an n by n unit, or non-unit,
  ! upper or lower triangular band matrix, with ( k + 1 ) diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,float*,int*,float*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  real intent(in), dimension(lda,n) :: a

  real dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine stbmv



subroutine dtbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are an n element vector and  A is an n by n unit, or non-unit,
  ! upper or lower triangular band matrix, with ( k + 1 ) diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,double*,int*,double*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  double precision intent(in), dimension(lda,n) :: a

  double precision dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dtbmv



subroutine ctbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are an n element vector and  A is an n by n unit, or non-unit,
  ! upper or lower triangular band matrix, with ( k + 1 ) diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,complex_float*,int*,complex_float*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  complex intent(in), dimension(lda,n) :: a

  complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ctbmv



subroutine ztbmv(n,k,a,lda,x,incx,offx,lower,trans,diag)
  ! Solves one of the systems of equations
  !
  !    A*xout = x,   or   A**T*xout = x,   or   A**H*xout = x,
  !
  ! where xout and x are an n element vector and  A is an n by n unit, or non-unit,
  ! upper or lower triangular band matrix, with ( k + 1 ) diagonals.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,&k,a,&lda,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,int*,complex_double*,int*,complex_double*,int*

  integer intent(hide),check(n>=0),depend(a) :: n = shape(a,1)
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(hide), depend(a) :: lda = MAX(shape(a,0),1)
  integer intent(in),depend(lda),check(k>=0&&k<=lda-1) :: k
  integer intent(in), optional :: offx = 0

  double complex intent(in), dimension(lda,n) :: a

  double complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ztbmv




subroutine stpmv(n,ap,x,incx,offx,lower,trans,diag)
  ! performs one of the matrix-vector operations
  !
  !  x := A*x,   or   x := A**T*x,
  !
  ! where x is n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,float*,float*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  real dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  real dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine stpmv



subroutine dtpmv(n,ap,x,incx,offx,lower,trans,diag)
  ! performs one of the matrix-vector operations
  !
  !  x := A*x,   or   x := A**T*x,
  !
  ! where x is n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,double*,double*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  double precision dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double precision dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine dtpmv



subroutine ctpmv(n,ap,x,incx,offx,lower,trans,diag)
  ! performs one of the matrix-vector operations
  !
  !  x := A*x,   or   x := A**T*x,
  !
  ! where x is n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_float*,complex_float*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ctpmv



subroutine ztpmv(n,ap,x,incx,offx,lower,trans,diag)
  ! performs one of the matrix-vector operations
  !
  !  x := A*x,   or   x := A**T*x,
  !
  ! where x is n element vectors and A is an n by n unit, or
  ! non-unit, upper or lower triangular matrix, supplied in packed form.

  callstatement (*f2py_func)((lower?"L":"U"),(trans?(trans==2?"C":"T"):"N"),(diag?"U":"N"),&n,ap,x+offx,&incx)
  callprotoargument char*,char*,char*,int*,complex_double*,complex_double*,int*

  integer intent(in),check(n>=0) :: n
  integer intent(in), optional, check(lower == 0 || lower == 1) :: lower = 0
  integer intent(in), optional, check(trans >= 0 || trans <= 2) :: trans = 0
  integer intent(in), optional, check(diag == 0 || diag == 1) :: diag = 0
  integer intent(in), optional, check(incx>0||incx<0) :: incx = 1
  integer intent(in), optional :: offx = 0

  double complex dimension(*),depend(n),intent(in),check(len(ap)>=(n*(n+1)/2)) :: ap

  double complex dimension(*), intent(in,out,copy,out=xout) :: x
  check(offx>=0 && offx<len(x)) :: x
  check(len(x)>offx+(n-1)*abs(incx)) :: x
  depend(offx,n,incx) :: x

end subroutine ztpmv


! -*- f90 -*-
! Signatures for f2py-wrappers of FORTRAN LEVEL 3 BLAS functions.
!
! Author: Pearu Peterson
! Created: April 2002
! Modified: Fabian Pedregosa, 2011; Evgeni Burovski, 2013
!
! Implemented:
!   gemm, symm, hemm, syrk, herk, syr2k, her2k, trmm, trsm
!
!
! Level 3 BLAS
!


subroutine sgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product.
  !
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"), &
       (trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,float*,float*,int*,float*, &
       int*,float*,float*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda,ka),intent(in) :: a
  real dimension(ldb,kb),intent(in) :: b
  real dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k) :: &
       n = (trans_b?ldb:kb)

end subroutine sgemm



subroutine dgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product.
  !
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"), &
       (trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,double*,double*,int*,double*, &
       int*,double*,double*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda,ka),intent(in) :: a
  double precision dimension(ldb,kb),intent(in) :: b
  double precision dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k) :: &
       n = (trans_b?ldb:kb)

end subroutine dgemm



subroutine cgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product.
  !
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"), &
       (trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,complex_float*,complex_float*,int*,complex_float*, &
       int*,complex_float*,complex_float*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,ka),intent(in) :: a
  complex dimension(ldb,kb),intent(in) :: b
  complex dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k) :: &
       n = (trans_b?ldb:kb)

end subroutine cgemm



subroutine zgemm(m,n,k,alpha,a,b,beta,c,trans_a,trans_b,lda,ka,ldb,kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product.
  !
  ! c = gemm(alpha,a,b,beta=0,c=0,trans_a=0,trans_b=0,overwrite_c=0)
  ! Calculate C <- alpha * op(A) * op(B) + beta * C

  callstatement (*f2py_func)((trans_a?(trans_a==2?"C":"T"):"N"), &
       (trans_b?(trans_b==2?"C":"T"):"N"),&m,&n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,int*,complex_double*,complex_double*,int*,complex_double*, &
       int*,complex_double*,complex_double*,int*

  integer optional,intent(in),check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional,intent(in),check(trans_b>=0 && trans_b <=2) :: trans_b = 0
  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,ka),intent(in) :: a
  double complex dimension(ldb,kb),intent(in) :: b
  double complex dimension(m,n),intent(in,out,copy),depend(m,n),optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a,trans_a,ka,lda),intent(hide):: m = (trans_a?ka:lda)
  integer depend(a,trans_a,ka,lda),intent(hide):: k = (trans_a?lda:ka)
  integer depend(b,trans_b,kb,ldb,k),intent(hide),check(trans_b?kb==k:ldb==k) :: &
       n = (trans_b?ldb:kb)

end subroutine zgemm




subroutine ssymm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product, where one of the matrices is symmetric.
  !
  ! c = symm(alpha,a,b,beta=0,c=0,side=0,lower=0,overwrite_c=0)
  ! Calculate C <- alpha * A * B + beta * C, or
  !           C <- alpha * B * A + beta * C

  callstatement (*f2py_func)((side?"R":"L"), &
       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,float*,float*,int*,float*, &
       int*,float*,float*,int*

  integer optional, intent(in),check(side==0||side==1) :: side = 0
  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0

  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda,ka),intent(in) :: a
  real dimension(ldb,kb),intent(in) :: b
  real dimension(m,n),intent(in,out,copy),depend(m,n), optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a), intent(hide) :: lda=shape(a,0)
  integer depend(a), intent(hide) :: ka = shape(a,1)
  integer depend(b), intent(hide) :: ldb = shape(b,0)
  integer depend(b), intent(hide) :: kb = shape(b, 1)

  integer depend(side, a, lda, b, ldb), intent(hide) :: m= (side ? ldb : lda)
  integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
        check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)

end subroutine ssymm



subroutine dsymm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product, where one of the matrices is symmetric.
  !
  ! c = symm(alpha,a,b,beta=0,c=0,side=0,lower=0,overwrite_c=0)
  ! Calculate C <- alpha * A * B + beta * C, or
  !           C <- alpha * B * A + beta * C

  callstatement (*f2py_func)((side?"R":"L"), &
       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,double*,double*,int*,double*, &
       int*,double*,double*,int*

  integer optional, intent(in),check(side==0||side==1) :: side = 0
  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0

  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda,ka),intent(in) :: a
  double precision dimension(ldb,kb),intent(in) :: b
  double precision dimension(m,n),intent(in,out,copy),depend(m,n), optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a), intent(hide) :: lda=shape(a,0)
  integer depend(a), intent(hide) :: ka = shape(a,1)
  integer depend(b), intent(hide) :: ldb = shape(b,0)
  integer depend(b), intent(hide) :: kb = shape(b, 1)

  integer depend(side, a, lda, b, ldb), intent(hide) :: m= (side ? ldb : lda)
  integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
        check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)

end subroutine dsymm



subroutine csymm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product, where one of the matrices is symmetric.
  !
  ! c = symm(alpha,a,b,beta=0,c=0,side=0,lower=0,overwrite_c=0)
  ! Calculate C <- alpha * A * B + beta * C, or
  !           C <- alpha * B * A + beta * C

  callstatement (*f2py_func)((side?"R":"L"), &
       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,complex_float*, &
       int*,complex_float*,complex_float*,int*

  integer optional, intent(in),check(side==0||side==1) :: side = 0
  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,ka),intent(in) :: a
  complex dimension(ldb,kb),intent(in) :: b
  complex dimension(m,n),intent(in,out,copy),depend(m,n), optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a), intent(hide) :: lda=shape(a,0)
  integer depend(a), intent(hide) :: ka = shape(a,1)
  integer depend(b), intent(hide) :: ldb = shape(b,0)
  integer depend(b), intent(hide) :: kb = shape(b, 1)

  integer depend(side, a, lda, b, ldb), intent(hide) :: m= (side ? ldb : lda)
  integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
        check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)

end subroutine csymm



subroutine zsymm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product, where one of the matrices is symmetric.
  !
  ! c = symm(alpha,a,b,beta=0,c=0,side=0,lower=0,overwrite_c=0)
  ! Calculate C <- alpha * A * B + beta * C, or
  !           C <- alpha * B * A + beta * C

  callstatement (*f2py_func)((side?"R":"L"), &
       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,complex_double*, &
       int*,complex_double*,complex_double*,int*

  integer optional, intent(in),check(side==0||side==1) :: side = 0
  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,ka),intent(in) :: a
  double complex dimension(ldb,kb),intent(in) :: b
  double complex dimension(m,n),intent(in,out,copy),depend(m,n), optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a), intent(hide) :: lda=shape(a,0)
  integer depend(a), intent(hide) :: ka = shape(a,1)
  integer depend(b), intent(hide) :: ldb = shape(b,0)
  integer depend(b), intent(hide) :: kb = shape(b, 1)

  integer depend(side, a, lda, b, ldb), intent(hide) :: m= (side ? ldb : lda)
  integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
        check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)

end subroutine zsymm



subroutine chemm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product, where one of the matrices is symmetric.
  !
  ! c = symm(alpha,a,b,beta=0,c=0,side=0,lower=0,overwrite_c=0)
  ! Calculate C <- alpha * A * B + beta * C, or
  !           C <- alpha * B * A + beta * C

  callstatement (*f2py_func)((side?"R":"L"), &
       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,complex_float*, &
       int*,complex_float*,complex_float*,int*

  integer optional, intent(in),check(side==0||side==1) :: side = 0
  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,ka),intent(in) :: a
  complex dimension(ldb,kb),intent(in) :: b
  complex dimension(m,n),intent(in,out,copy),depend(m,n), optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a), intent(hide) :: lda=shape(a,0)
  integer depend(a), intent(hide) :: ka = shape(a,1)
  integer depend(b), intent(hide) :: ldb = shape(b,0)
  integer depend(b), intent(hide) :: kb = shape(b, 1)

  integer depend(side, a, lda, b, ldb), intent(hide) :: m= (side ? ldb : lda)
  integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
        check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)

end subroutine chemm



subroutine zhemm(m, n, alpha, a, b, beta, c, side, lower, lda, ka, ldb, kb)
  ! Computes a scalar-matrix-matrix product and adds the result to a
  ! scalar-matrix product, where one of the matrices is symmetric.
  !
  ! c = symm(alpha,a,b,beta=0,c=0,side=0,lower=0,overwrite_c=0)
  ! Calculate C <- alpha * A * B + beta * C, or
  !           C <- alpha * B * A + beta * C

  callstatement (*f2py_func)((side?"R":"L"), &
       (lower?"L":"U"),&m,&n,&alpha,a,&lda,b,&ldb,&beta,c,&m)
  callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,complex_double*, &
       int*,complex_double*,complex_double*,int*

  integer optional, intent(in),check(side==0||side==1) :: side = 0
  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,ka),intent(in) :: a
  double complex dimension(ldb,kb),intent(in) :: b
  double complex dimension(m,n),intent(in,out,copy),depend(m,n), optional :: c
  check(shape(c,0)==m && shape(c,1)==n) :: c

  integer depend(a), intent(hide) :: lda=shape(a,0)
  integer depend(a), intent(hide) :: ka = shape(a,1)
  integer depend(b), intent(hide) :: ldb = shape(b,0)
  integer depend(b), intent(hide) :: kb = shape(b, 1)

  integer depend(side, a, lda, b, ldb), intent(hide) :: m= (side ? ldb : lda)
  integer depend(side, a, lda, ka, b, ldb, kb), intent(hide), &
        check(side? kb==lda : ka==ldb) :: n = (side ? ka : kb)

end subroutine zhemm





subroutine ssyrk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
  !  performs one of the symmetric rank k operations
  !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
  !
  ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,float*,float*,int*,float*, &
        float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda,ka),intent(in) :: a
  real dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)

end subroutine ssyrk




subroutine dsyrk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
  !  performs one of the symmetric rank k operations
  !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
  !
  ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,double*,double*,int*,double*, &
        double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda,ka),intent(in) :: a
  double precision dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)

end subroutine dsyrk




subroutine csyrk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
  !  performs one of the symmetric rank k operations
  !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
  !
  ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,complex_float*, &
        complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,ka),intent(in) :: a
  complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)

end subroutine csyrk




subroutine zsyrk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
  !  performs one of the symmetric rank k operations
  !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
  !
  ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,complex_double*, &
        complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,ka),intent(in) :: a
  double complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)

end subroutine zsyrk




subroutine cherk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
  !  performs one of the symmetric rank k operations
  !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
  !
  ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,complex_float*, &
        complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda,ka),intent(in) :: a
  complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)

end subroutine cherk




subroutine zherk(n,k,alpha,a,beta,c,trans,lower,lda,ka)
  !  performs one of the symmetric rank k operations
  !     C := alpha*A*A**T + beta*C,  or   C := alpha*A**T*A + beta*C,
  !
  ! c = syrk(alpha,a,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,complex_double*, &
        complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda,ka),intent(in) :: a
  double complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, trans, ka, lda), intent(hide) :: k = (trans ? lda : ka)

end subroutine zherk




subroutine ssyr2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
  !  performs one of the symmetric/hermitian rank 2k operations
  !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
  !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
  !
  ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,float*,float*,int*,float*,int*, &
        float*, float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  real intent(in) :: alpha
  real intent(in),optional :: beta = 0.0

  real dimension(lda, ka), intent(in) :: a
  real dimension(ldb, kb), intent(in) :: b
  real dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
        check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)

end subroutine prefixsyr2k



subroutine dsyr2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
  !  performs one of the symmetric/hermitian rank 2k operations
  !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
  !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
  !
  ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,double*,double*,int*,double*,int*, &
        double*, double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  double precision intent(in) :: alpha
  double precision intent(in),optional :: beta = 0.0

  double precision dimension(lda, ka), intent(in) :: a
  double precision dimension(ldb, kb), intent(in) :: b
  double precision dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
        check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)

end subroutine prefixsyr2k



subroutine csyr2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
  !  performs one of the symmetric/hermitian rank 2k operations
  !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
  !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
  !
  ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*, &
        complex_float*, complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda, ka), intent(in) :: a
  complex dimension(ldb, kb), intent(in) :: b
  complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
        check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)

end subroutine prefixsyr2k



subroutine zsyr2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
  !  performs one of the symmetric/hermitian rank 2k operations
  !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
  !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
  !
  ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*, &
        complex_double*, complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda, ka), intent(in) :: a
  double complex dimension(ldb, kb), intent(in) :: b
  double complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
        check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)

end subroutine prefixsyr2k



subroutine cher2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
  !  performs one of the symmetric/hermitian rank 2k operations
  !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
  !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
  !
  ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_float*,complex_float*,int*,complex_float*,int*, &
        complex_float*, complex_float*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  complex intent(in) :: alpha
  complex intent(in),optional :: beta = (0.0,0.0)

  complex dimension(lda, ka), intent(in) :: a
  complex dimension(ldb, kb), intent(in) :: b
  complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
        check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)

end subroutine prefixher2k



subroutine zher2k(n,k,alpha,a,b,beta,c,trans,lower,lda,ka, ldb, kb)
  !  performs one of the symmetric/hermitian rank 2k operations
  !     C := alpha*A*B**T + alpha*B*A**T + beta*C,  or
  !     C:=alpha*A**T*B + alpha*B**T*A + beta*C
  !
  ! c = syr2k(alpha,a,b,beta=0,c=0,trans=0,lower=0,overwrite_c=0)
  !
  callstatement (*f2py_func)((lower?"L":"U"), &
        (trans?(trans==2?"C":"T"):"N"), &n,&k,&alpha,a,&lda,b,&ldb,&beta,c,&n)
  callprotoargument char*,char*,int*,int*,complex_double*,complex_double*,int*,complex_double*,int*, &
        complex_double*, complex_double*,int*

  integer optional, intent(in),check(lower==0||lower==1) :: lower = 0
  integer optional,intent(in),check(trans>=0 && trans <=2) :: trans = 0

  double complex intent(in) :: alpha
  double complex intent(in),optional :: beta = (0.0,0.0)

  double complex dimension(lda, ka), intent(in) :: a
  double complex dimension(ldb, kb), intent(in) :: b
  double complex dimension(n,n),intent(in,out,copy),depend(n),optional :: c
  check(shape(c,0)==n && shape(c,1)==n) :: c

  integer depend(a),intent(hide) :: lda = shape(a,0)
  integer depend(a),intent(hide) :: ka = shape(a,1)
  integer depend(b),intent(hide) :: ldb = shape(b,0)
  integer depend(b),intent(hide) :: kb = shape(b,1)

  integer depend(a, trans, ka, lda), intent(hide) :: n = (trans ? ka : lda)
  integer depend(a, b, trans, ka, lda, kb, ldb), intent(hide), &
        check(trans ? lda==ldb: ka==kb) :: k = (trans ? lda : ka)

end subroutine prefixher2k




subroutine strmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, diag)

  !  performs one of the matrix-matrix operations
  !
  !     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
  !
  !  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.
  !
  ! c = trmm(alpha, a, b, side=0, lower=0, trans_a=0, diag=0)

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, float*,float*,int*,float*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0

  real intent(in) :: alpha

  real dimension(lda, k), intent(in) :: a
  real dimension(ldb, n), intent(in, out, copy) :: b

  integer depend(a), intent(hide) :: lda = shape(a, 0)
  integer depend(a), intent(hide) :: k = shape(a, 1)

  integer depend(b), intent(hide) :: ldb = shape(b, 0)
  integer depend(b), intent(hide) :: n = shape(b, 1)

  integer depend(side, a, b, n, k), intent(hide) :: m = (side ? n : k)

end subroutine strmm



subroutine dtrmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, diag)

  !  performs one of the matrix-matrix operations
  !
  !     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
  !
  !  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.
  !
  ! c = trmm(alpha, a, b, side=0, lower=0, trans_a=0, diag=0)

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, double*,double*,int*,double*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0

  double precision intent(in) :: alpha

  double precision dimension(lda, k), intent(in) :: a
  double precision dimension(ldb, n), intent(in, out, copy) :: b

  integer depend(a), intent(hide) :: lda = shape(a, 0)
  integer depend(a), intent(hide) :: k = shape(a, 1)

  integer depend(b), intent(hide) :: ldb = shape(b, 0)
  integer depend(b), intent(hide) :: n = shape(b, 1)

  integer depend(side, a, b, n, k), intent(hide) :: m = (side ? n : k)

end subroutine dtrmm



subroutine ctrmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, diag)

  !  performs one of the matrix-matrix operations
  !
  !     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
  !
  !  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.
  !
  ! c = trmm(alpha, a, b, side=0, lower=0, trans_a=0, diag=0)

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, complex_float*,complex_float*,int*,complex_float*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0

  complex intent(in) :: alpha

  complex dimension(lda, k), intent(in) :: a
  complex dimension(ldb, n), intent(in, out, copy) :: b

  integer depend(a), intent(hide) :: lda = shape(a, 0)
  integer depend(a), intent(hide) :: k = shape(a, 1)

  integer depend(b), intent(hide) :: ldb = shape(b, 0)
  integer depend(b), intent(hide) :: n = shape(b, 1)

  integer depend(side, a, b, n, k), intent(hide) :: m = (side ? n : k)

end subroutine ctrmm



subroutine ztrmm(m, n, k, alpha, a, b, lda, ldb, side, lower, trans_a, diag)

  !  performs one of the matrix-matrix operations
  !
  !     B := alpha*op( A )*B,   or   B := alpha*B*op( A )
  !
  !  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !     op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.
  !
  ! c = trmm(alpha, a, b, side=0, lower=0, trans_a=0, diag=0)

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, complex_double*,complex_double*,int*,complex_double*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0

  double complex intent(in) :: alpha

  double complex dimension(lda, k), intent(in) :: a
  double complex dimension(ldb, n), intent(in, out, copy) :: b

  integer depend(a), intent(hide) :: lda = shape(a, 0)
  integer depend(a), intent(hide) :: k = shape(a, 1)

  integer depend(b), intent(hide) :: ldb = shape(b, 0)
  integer depend(b), intent(hide) :: n = shape(b, 1)

  integer depend(side, a, b, n, k), intent(hide) :: m = (side ? n : k)

end subroutine ztrmm




subroutine strsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
  !
  !  Solves one of the matrix equations
  !
  !    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
  !
  !  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !  op( A ) = A   or   op( A ) = A**T.
  !

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, float*,float*,int*,float*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0
  integer depend(a), intent(hide) :: lda = MAX(shape(a, 0),1)
  ! integer depend(a), intent(hide) :: k = shape(a, 1)
  integer depend(b), intent(hide) :: ldb = MAX(shape(b, 0),1)
  integer depend(b), intent(hide) :: n = shape(b, 1)
  integer depend(b), intent(hide) :: m = shape(b, 0)

  real intent(in) :: alpha
  real dimension(ldb, n), intent(in, out, copy, out=x) :: b

  real dimension(lda, *), depend(m, n), intent(in) :: a
  check(shape(a,0)==shape(a,1)) :: a
  check(shape(a,0)==(side?n:m)) :: a

end subroutine strsm



subroutine dtrsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
  !
  !  Solves one of the matrix equations
  !
  !    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
  !
  !  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !  op( A ) = A   or   op( A ) = A**T.
  !

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, double*,double*,int*,double*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0
  integer depend(a), intent(hide) :: lda = MAX(shape(a, 0),1)
  ! integer depend(a), intent(hide) :: k = shape(a, 1)
  integer depend(b), intent(hide) :: ldb = MAX(shape(b, 0),1)
  integer depend(b), intent(hide) :: n = shape(b, 1)
  integer depend(b), intent(hide) :: m = shape(b, 0)

  double precision intent(in) :: alpha
  double precision dimension(ldb, n), intent(in, out, copy, out=x) :: b

  double precision dimension(lda, *), depend(m, n), intent(in) :: a
  check(shape(a,0)==shape(a,1)) :: a
  check(shape(a,0)==(side?n:m)) :: a

end subroutine dtrsm



subroutine ctrsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
  !
  !  Solves one of the matrix equations
  !
  !    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
  !
  !  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !  op( A ) = A   or   op( A ) = A**T.
  !

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, complex_float*,complex_float*,int*,complex_float*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0
  integer depend(a), intent(hide) :: lda = MAX(shape(a, 0),1)
  ! integer depend(a), intent(hide) :: k = shape(a, 1)
  integer depend(b), intent(hide) :: ldb = MAX(shape(b, 0),1)
  integer depend(b), intent(hide) :: n = shape(b, 1)
  integer depend(b), intent(hide) :: m = shape(b, 0)

  complex intent(in) :: alpha
  complex dimension(ldb, n), intent(in, out, copy, out=x) :: b

  complex dimension(lda, *), depend(m, n), intent(in) :: a
  check(shape(a,0)==shape(a,1)) :: a
  check(shape(a,0)==(side?n:m)) :: a

end subroutine ctrsm



subroutine ztrsm(m, n, alpha, a, b, lda, ldb, side, lower, trans_a, diag)
  !
  !  Solves one of the matrix equations
  !
  !    op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
  !
  !  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
  !  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
  !
  !  op( A ) = A   or   op( A ) = A**T.
  !

  callstatement (*f2py_func)((side?"R":"L"), (lower?"L":"U"), &
        (trans_a?(trans_a==2?"C":"T"):"N"), (diag?"U":"N"), &m, &n, &alpha, a, &lda, b, &ldb)
  callprotoargument char*, char*, char*, char*, int*, int*, complex_double*,complex_double*,int*,complex_double*, int*

  integer optional, intent(in), check(side==0 || side==1) :: side = 0
  integer optional, intent(in), check(lower==0 || lower==1) :: lower = 0
  integer optional, intent(in), check(trans_a>=0 && trans_a <=2) :: trans_a = 0
  integer optional, intent(in), check(diag==0 || diag==1) :: diag = 0
  integer depend(a), intent(hide) :: lda = MAX(shape(a, 0),1)
  ! integer depend(a), intent(hide) :: k = shape(a, 1)
  integer depend(b), intent(hide) :: ldb = MAX(shape(b, 0),1)
  integer depend(b), intent(hide) :: n = shape(b, 1)
  integer depend(b), intent(hide) :: m = shape(b, 0)

  double complex intent(in) :: alpha
  double complex dimension(ldb, n), intent(in, out, copy, out=x) :: b

  double complex dimension(lda, *), depend(m, n), intent(in) :: a
  check(shape(a,0)==shape(a,1)) :: a
  check(shape(a,0)==(side?n:m)) :: a

end subroutine ztrsm



    end interface
end python module _fblas
